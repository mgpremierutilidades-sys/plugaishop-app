===== PATH: .github\copilot-instructions.md =====
# Copilot Instructions — plugaishop-app (2026)

## Objective
This repository is the Plugaí Shop mobile app built with Expo + Expo Router + TypeScript. Generate production-grade code with minimal churn, prioritizing incremental improvements only.

## Non-negotiables
- DO NOT redesign UI/layout. Layout is approved and must be preserved.
- Prefer incremental functional improvements; never restart the project.
- Keep the bottom tab bar fixed and always available.
- Ensure a consistent “Back/Home” access on screens that are not tabs, without breaking layout.
- Always output complete, ready-to-paste files when modifying code.

## Project structure (root)
- Root folders: `app/`, `assets/`, `components/`, `constants/`, `context/`, `data/`, `hooks/`, `scripts/`, `utils/`.
- `components/` is ONLY at the project root (same level as `app/`).

## Import rules (strict)
### Theme
- `constants/theme.ts` MUST export:
  - `export default theme`
  - named exports: `Colors`, `Radius`, `Spacing`
- Always import as:
  - `import theme from "../../constants/theme";` (or correct relative path)
  - `import { Colors, Radius, Spacing } from "../../constants/theme";`
- Avoid `src/constants/...` paths.
- Avoid `import { theme } ...`.

### ProductCardVertical
- Must use:
  - `import { Colors, Radius, Spacing } from "../../constants/theme";`
  - `import type { Product } from "../../data/catalog";`

### AppHeader pathing
- From screens inside `app/(tabs)/*`:
  - `import AppHeader from "../../components/AppHeader";`
- From `app/_layout.tsx`:
  - `import AppHeader from "../components/AppHeader";`

## Home banner path (strict)
- `app/(tabs)/index.tsx` must always use:
  - `source={require("../../assets/banners/banner-home.png")}`

## Typography behavior (approved)
- Explore > Main Categories:
  - Names with spaces can wrap up to 2 lines.
  - Single-word long names must stay on 1 line using `adjustsFontSizeToFit` + `minimumFontScale`.
  - Keep centered; do not change this section’s layout.

## Tabs navigation
- Keep tabs stable and fixed.
- Minimal changes only; do not rename routes unless explicitly required.

## Code quality
- TypeScript strictness: avoid `any`, avoid unsafe casts.
- Prefer small, targeted diffs.
- Keep functions/components readable and cohesive.
- Handle edge cases (null/undefined, empty states) without visual redesign.

## Deliverables
When asked to fix something:
- Provide the full updated file(s), not snippets.
- Ensure imports and paths match the repository structure.
- Do not introduce new dependencies unless requested and justified.



===== PATH: app.json =====
{
  "expo": {
    "name": "plugaishop-app",
    "slug": "plugaishop-app",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "plugaishopapp",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "backgroundColor": "#E6F4FE",
        "foregroundImage": "./assets/images/android-icon-foreground.png",
        "backgroundImage": "./assets/images/android-icon-background.png",
        "monochromeImage": "./assets/images/android-icon-monochrome.png"
      },
      "edgeToEdgeEnabled": true,
      "predictiveBackGestureEnabled": false
    },
    "web": {
      "output": "static",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/splash-icon.png",
          "imageWidth": 200,
          "resizeMode": "contain",
          "backgroundColor": "#ffffff",
          "dark": {
            "backgroundColor": "#000000"
          }
        }
      ],
      "expo-font",
      "expo-web-browser"
    ],
    "experiments": {
      "typedRoutes": true,
      "reactCompiler": true
    }
  }
}



===== PATH: app\_layout.tsx =====
// app/_layout.tsx
import { Stack } from "expo-router";

import GlobalChrome from "../components/global-chrome";

export default function RootLayout() {
  return (
    <Stack
      screenOptions={{
        headerShown: false,
        animation: "slide_from_right",
      }}
    >
      {/* Rotas reais de topo */}
      <Stack.Screen name="(tabs)" options={{ headerShown: false }} />
      <Stack.Screen name="orders" options={{ headerShown: false }} />

      {/* Modal (se existir app/modal.tsx) */}
      <Stack.Screen name="modal" options={{ presentation: "modal" }} />
    </Stack>
  );
}



===== PATH: app\(tabs)\_layout.tsx =====
import { Tabs } from "expo-router";
import IconSymbol from "../../components/ui/icon-symbol";
import theme from "../../constants/theme";

export default function TabsLayout() {
  return (
    <Tabs
      screenOptions={{
        headerShown: false,
        tabBarActiveTintColor: theme.colors.tabIconActive,
        tabBarInactiveTintColor: theme.colors.tabIconInactive,
        tabBarHideOnKeyboard: false,
        tabBarStyle: {
          borderTopColor: theme.colors.divider,
          backgroundColor: theme.colors.background,
          height: 64,
          paddingTop: 8,
          paddingBottom: 10,
        },
        tabBarLabelStyle: {
          fontSize: 11,
          fontWeight: "700",
        },
      }}
    >
      <Tabs.Screen
        name="index"
        options={{
          title: "Início",
          tabBarIcon: ({ color }) => (
            <IconSymbol name="home-outline" color={color} size={22} />
          ),
        }}
      />

      <Tabs.Screen
        name="explore"
        options={{
          title: "Explorar",
          tabBarIcon: ({ color }) => (
            <IconSymbol name="compass-outline" color={color} size={22} />
          ),
        }}
      />

      <Tabs.Screen
        name="cart"
        options={{
          title: "Carrinho",
          tabBarIcon: ({ color }) => (
            <IconSymbol name="cart-outline" color={color} size={22} />
          ),
        }}
      />

      <Tabs.Screen
        name="account"
        options={{
          title: "Conta",
          tabBarIcon: ({ color }) => (
            <IconSymbol name="receipt-outline" color={color} size={22} />
          ),
        }}
      />

      <Tabs.Screen
        name="profile"
        options={{
          title: "Perfil",
          tabBarIcon: ({ color }) => (
            <IconSymbol name="person-circle-outline" color={color} size={22} />
          ),
        }}
      />
    </Tabs>
  );
}



===== PATH: app\(tabs)\account.tsx =====
import { StyleSheet } from "react-native";
import { ThemedText } from "../../components/themed-text";
import { ThemedView } from "../../components/themed-view";

export default function AccountTab() {
  return (
    <ThemedView style={styles.container}>
      <ThemedText type="title">Conta</ThemedText>
      <ThemedText style={styles.subtitle}>Tela da conta (rota do Tab).</ThemedText>
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, padding: 16 },
  subtitle: { marginTop: 8, opacity: 0.8 },
});



===== PATH: app\(tabs)\cart.tsx =====
import { router } from "expo-router";
import { useEffect, useMemo, useState } from "react";
import {
  Image,
  Pressable,
  SectionList,
  StyleSheet,
  View,
  type ImageSourcePropType,
} from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";

import { ThemedText } from "../../components/themed-text";
import { ThemedView } from "../../components/themed-view";
import theme from "../../constants/theme";
import { useCart } from "../../context/CartContext";
import type { Product } from "../../data/catalog";
import { products } from "../../data/catalog";
import { formatCurrency } from "../../utils/formatCurrency";

const FONT_TITLE = "Arimo_400Regular";
const FONT_BODY = "OpenSans_400Regular";
const FONT_BODY_BOLD = "OpenSans_700Bold";

type Row = {
  type: "cart";
  id: string;
  title: string;
  price: number;
  oldPrice?: number;
  qty: number;
  image?: string;
};

type CartSection = {
  title: string;
  data: Row[];
};

function ProductThumb({ image, size = 72 }: { image?: string; size?: number }) {
  const src: ImageSourcePropType | null =
    typeof image === "string" && image.startsWith("http") ? { uri: image } : null;

  return (
    <View style={[styles.itemImage, { width: size, height: size }]}>
      {src ? (
        <Image
          source={src}
          style={{ width: "100%", height: "100%", borderRadius: 12 }}
          resizeMode="cover"
        />
      ) : (
        <View style={styles.itemImagePlaceholder} />
      )}
    </View>
  );
}

export default function CartTab() {
  const cartCtx = useCart() as any;

  // Fallback local (para o caso do contexto ainda não estar 100% pronto)
  const seededRows = useMemo<Row[]>(() => {
    const base = (products as Product[]).slice(0, 6);
    return base.map((p, idx) => ({
      type: "cart",
      id: p.id,
      title: p.title,
      price: p.price,
      oldPrice: idx % 2 === 0 ? Math.round(p.price * 1.18 * 100) / 100 : undefined,
      qty: 1 + (idx % 3),
      image: (p as any).image,
    }));
  }, []);

  const [localRows, setLocalRows] = useState<Row[]>(seededRows);

  // Se o contexto expuser itens, tentamos refletir (sem depender do formato exato)
  useEffect(() => {
    const ctxItems = cartCtx?.items ?? cartCtx?.cartItems ?? cartCtx?.cart ?? null;
    if (!ctxItems) return;

    if (Array.isArray(ctxItems)) {
      const mapped: Row[] = ctxItems
        .map((it: any) => {
          const p = it?.product ?? it;
          const qty = it?.qty ?? it?.quantity ?? 1;
          const id = p?.id ?? it?.id ?? it?.productId;
          if (!id) return null;

          return {
            type: "cart",
            id: String(id),
            title: String(p?.title ?? it?.title ?? "Produto"),
            price: Number(p?.price ?? it?.price ?? 0),
            oldPrice: p?.oldPrice ? Number(p.oldPrice) : undefined,
            qty: Math.max(1, Number(qty ?? 1)),
            image: p?.image ?? it?.image,
          } as Row;
        })
        .filter(Boolean) as Row[];

      if (mapped.length) setLocalRows(mapped);
      return;
    }

    if (typeof ctxItems === "object") {
      const mapped: Row[] = Object.keys(ctxItems).map((id) => {
        const qty = Number((ctxItems as any)[id] ?? 1);
        const p = (products as Product[]).find((x) => String(x.id) === String(id));
        return {
          type: "cart",
          id: String(id),
          title: String(p?.title ?? "Produto"),
          price: Number(p?.price ?? 0),
          qty: Math.max(1, qty),
          image: (p as any)?.image,
        };
      });
      if (mapped.length) setLocalRows(mapped);
    }
  }, [cartCtx, seededRows]);

  const [selected, setSelected] = useState<Record<string, boolean>>({});

  useEffect(() => {
    const next: Record<string, boolean> = {};
    for (const r of localRows) next[r.id] = true;
    setSelected(next);
  }, [localRows]);

  function toProduct(row: Row): Product {
    const p = (products as Product[]).find((x) => x.id === row.id);
    return (
      p ?? {
        id: row.id,
        title: row.title,
        price: row.price,
        category: "",
        image: row.image ?? "",
      }
    );
  }

  function toggleSelect(id: string) {
    setSelected((prev) => ({ ...prev, [id]: !prev[id] }));
  }

  function safeAdd(product: Product) {
    const any = cartCtx as any;
    const fn =
      any?.addItem?.bind(any) ||
      any?.add?.bind(any) ||
      any?.addToCart?.bind(any) ||
      any?.increase?.bind(any) ||
      any?.increment?.bind(any);

    if (fn) {
      fn(product, 1);
      return;
    }

    setLocalRows((prev) => prev.map((r) => (r.id === product.id ? { ...r, qty: r.qty + 1 } : r)));
  }

  function safeDec(product: Product) {
    const any = cartCtx as any;
    const fn =
      any?.decItem?.bind(any) ||
      any?.decrease?.bind(any) ||
      any?.dec?.bind(any) ||
      any?.decrement?.bind(any) ||
      any?.removeOne?.bind(any);

    if (fn) {
      fn(product, 1);
      return;
    }

    setLocalRows((prev) =>
      prev
        .map((r) => (r.id === product.id ? { ...r, qty: Math.max(1, r.qty - 1) } : r))
        .filter((r) => r.qty > 0)
    );
  }

  function safeRemove(product: Product) {
    const any = cartCtx as any;
    const fn =
      any?.removeItem?.bind(any) ||
      any?.remove?.bind(any) ||
      any?.removeFromCart?.bind(any) ||
      any?.deleteItem?.bind(any) ||
      any?.clearItem?.bind(any);

    if (fn) {
      fn(product.id);
      return;
    }

    setLocalRows((prev) => prev.filter((r) => r.id !== product.id));
  }

  const selectedSubtotal = useMemo(() => {
    return localRows.reduce((acc, r) => {
      if (!selected[r.id]) return acc;
      return acc + r.price * r.qty;
    }, 0);
  }, [localRows, selected]);

  const sections: CartSection[] = useMemo(() => {
    return [
      {
        title: "Produtos",
        data: localRows,
      },
    ];
  }, [localRows]);

  const renderRow = ({ item }: { item: Row }) => {
    const isChecked = !!selected[item.id];
    const product = toProduct(item);

    return (
      <View style={styles.itemCard}>
        <View style={styles.itemTop}>
          <Pressable
            onPress={() => toggleSelect(item.id)}
            hitSlop={10}
            style={[styles.checkbox, isChecked ? styles.checkboxChecked : styles.checkboxUnchecked]}
            accessibilityRole="button"
            accessibilityLabel={isChecked ? "Desmarcar item" : "Marcar item"}
          >
            {isChecked ? <View style={styles.checkboxDot} /> : null}
          </Pressable>

          <ProductThumb image={item.image} />

          <View style={styles.itemInfo}>
            <ThemedText numberOfLines={2} style={styles.itemTitle}>
              {item.title}
            </ThemedText>

            <View style={styles.priceRow}>
              <ThemedText style={styles.price}>{formatCurrency(item.price)}</ThemedText>
              <ThemedText style={styles.unit}> / un</ThemedText>
            </View>

            {item.oldPrice ? (
              <ThemedText style={styles.oldPrice}>{formatCurrency(item.oldPrice)}</ThemedText>
            ) : null}
          </View>
        </View>

        <View style={styles.qtyRow}>
          <Pressable onPress={() => safeDec(product)} style={styles.qtyBtn} hitSlop={10} accessibilityRole="button">
            <ThemedText style={styles.qtyBtnText}>-</ThemedText>
          </Pressable>

          <ThemedText style={styles.qtyText}>{item.qty}</ThemedText>

          <Pressable onPress={() => safeAdd(product)} style={styles.qtyBtn} hitSlop={10} accessibilityRole="button">
            <ThemedText style={styles.qtyBtnText}>+</ThemedText>
          </Pressable>

          <Pressable
            onPress={() => safeRemove(product)}
            hitSlop={10}
            accessibilityRole="button"
            style={{ marginLeft: "auto" }}
          >
            <ThemedText style={styles.remove}>✕</ThemedText>
          </Pressable>
        </View>
      </View>
    );
  };

  const goCheckout = () => {
    router.push("/checkout" as any);
  };

  return (
    <SafeAreaView style={styles.safe} edges={["top", "left", "right"]}>
      <ThemedView style={styles.container}>
        <View style={styles.header}>
          <Pressable onPress={() => router.back()} hitSlop={12} style={styles.backBtn} accessibilityRole="button">
            <ThemedText style={styles.backIcon}>←</ThemedText>
          </Pressable>

          <ThemedText style={styles.title}>Carrinho</ThemedText>

          <View style={styles.rightSpacer} />
        </View>

        <SectionList
          sections={sections}
          keyExtractor={(it) => `${it.type}-${it.id}`}
          renderItem={renderRow}
          renderSectionHeader={({ section }) => (
            <View style={styles.sectionHeader}>
              <ThemedText style={styles.sectionHeaderText}>{section.title.toUpperCase()}</ThemedText>
            </View>
          )}
          stickySectionHeadersEnabled
          showsVerticalScrollIndicator={false}
          contentContainerStyle={{ paddingBottom: 160 }}
        />

        {/* Rodapé fixo: TOTAL embaixo + botão */}
        <View style={styles.footerBar}>
          <View style={styles.totalBox}>
            <ThemedText style={styles.totalLabel}>TOTAL</ThemedText>
            <ThemedText style={styles.totalValue}>{formatCurrency(selectedSubtotal)}</ThemedText>
          </View>

          <Pressable onPress={goCheckout} style={styles.footerBtn} accessibilityRole="button">
            <ThemedText style={styles.footerBtnText}>CONTINUAR A COMPRA</ThemedText>
          </Pressable>
        </View>
      </ThemedView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safe: { flex: 1, backgroundColor: theme.colors.background },

  container: {
    flex: 1,
    backgroundColor: theme.colors.background,
    paddingHorizontal: 14,
  },

  header: {
    height: 44,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 6,
  },

  backBtn: {
    width: 40,
    height: 40,
    borderRadius: 999,
    alignItems: "center",
    justifyContent: "center",
  },
  backIcon: { fontSize: 22, fontFamily: FONT_BODY_BOLD },

  title: {
    fontSize: 24,
    fontFamily: FONT_TITLE,
    fontWeight: "700",
    textAlign: "center",
  },

  rightSpacer: { width: 40, height: 40 },

  // PRODUTOS fixo (sticky) e sempre visível
  sectionHeader: {
    paddingTop: 8,
    paddingBottom: 6,
    backgroundColor: theme.colors.background,
    zIndex: 10,
  },
  sectionHeaderText: { fontSize: 12, fontFamily: FONT_BODY_BOLD, opacity: 0.85 },

  itemCard: {
    backgroundColor: theme.colors.surface,
    borderRadius: 14,
    borderWidth: 1,
    borderColor: theme.colors.border,
    padding: 10,
    marginBottom: 8,
  },

  itemTop: { flexDirection: "row", gap: 10 },

  checkbox: {
    width: 18,
    height: 18,
    borderRadius: 6,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
    marginTop: 6,
  },
  checkboxUnchecked: { borderColor: theme.colors.divider, backgroundColor: theme.colors.surface },
  checkboxChecked: { borderColor: theme.colors.primary, backgroundColor: theme.colors.primary },
  checkboxDot: { width: 8, height: 8, borderRadius: 3, backgroundColor: "#fff" },

  itemImage: {
    borderRadius: 12,
    backgroundColor: theme.colors.surfaceAlt,
    overflow: "hidden",
  },
  itemImagePlaceholder: { flex: 1, borderRadius: 12, backgroundColor: theme.colors.surfaceAlt },

  itemInfo: { flex: 1 },
  itemTitle: { fontSize: 11, fontFamily: FONT_BODY_BOLD },
  priceRow: { marginTop: 6, flexDirection: "row", alignItems: "center" },
  price: { fontSize: 11, fontFamily: FONT_BODY_BOLD, opacity: 0.9 },
  unit: { fontSize: 11, fontFamily: FONT_BODY, opacity: 0.7 },
  oldPrice: {
    marginTop: 3,
    fontSize: 11,
    fontFamily: FONT_BODY,
    opacity: 0.6,
    textDecorationLine: "line-through",
  },

  qtyRow: {
    marginTop: 8,
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
  },

  qtyBtn: {
    width: 30,
    height: 30,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: theme.colors.divider,
    alignItems: "center",
    justifyContent: "center",
  },
  qtyBtnText: { fontSize: 15, fontFamily: FONT_BODY_BOLD },

  qtyText: { fontSize: 11, fontFamily: FONT_BODY_BOLD, minWidth: 18, textAlign: "center" },

  remove: { fontSize: 12, fontFamily: FONT_BODY_BOLD, opacity: 0.85 },

  // Rodapé: TOTAL + CTA
  footerBar: {
    position: "absolute",
    left: 14,
    right: 14,
    bottom: 10,
    gap: 8,
  },

  totalBox: {
    backgroundColor: "#F59E0B",
    borderRadius: 14,
    paddingVertical: 10,
    paddingHorizontal: 14,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  totalLabel: { fontSize: 12, fontFamily: FONT_BODY_BOLD, color: "#000" },
  totalValue: { fontSize: 14, fontFamily: FONT_BODY_BOLD, color: "#000" },

  footerBtn: {
    height: 44,
    borderRadius: 14,
    backgroundColor: "#3F5A3A",
    alignItems: "center",
    justifyContent: "center",
  },
  footerBtnText: {
    fontSize: 16,
    fontFamily: FONT_BODY_BOLD,
    color: "#FFFFFF",
    textTransform: "uppercase",
  },
});



===== PATH: app\(tabs)\checkout\_layout.tsx =====
// app/checkout/_layout.tsx
import { Stack } from "expo-router";

export default function CheckoutLayout() {
  return (
    <Stack
      screenOptions={{
        headerShown: false,
        animation: "slide_from_right",
      }}
    />
  );
}



===== PATH: app\(tabs)\checkout\address.tsx =====
import { router } from "expo-router";
import { useMemo, useState } from "react";
import { Pressable, StyleSheet, TextInput, View } from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";

import { ThemedText } from "../../../components/themed-text";
import { ThemedView } from "../../../components/themed-view";
import theme from "../../../constants/theme";

const FONT_BODY = "OpenSans_400Regular";
const FONT_BODY_BOLD = "OpenSans_700Bold";
const FONT_TITLE = "Arimo_400Regular";

type AddressForm = {
  cep: string;
  number: string;
  complement: string;
  street: string;
  district: string;
  cityUf: string;
};

function onlyDigits(v: string) {
  return v.replace(/\D/g, "");
}

function maskCep(v: string) {
  const d = onlyDigits(v).slice(0, 8);
  if (d.length <= 5) return d;
  return `${d.slice(0, 5)}-${d.slice(5)}`;
}

export default function CheckoutAddress() {
  const goBack = () => router.back();

  const [form, setForm] = useState<AddressForm>({
    cep: "",
    number: "",
    complement: "",
    street: "",
    district: "",
    cityUf: "",
  });

  const canContinue = useMemo(() => {
    const cepOk = onlyDigits(form.cep).length === 8;
    const numberOk = form.number.trim().length > 0;
    const streetOk = form.street.trim().length > 0;
    const districtOk = form.district.trim().length > 0;
    const cityOk = form.cityUf.trim().length > 0;
    return cepOk && numberOk && streetOk && districtOk && cityOk;
  }, [form]);

  const push = (path: string) => router.push(path as any);

  return (
    <SafeAreaView style={styles.safe} edges={["top", "left", "right"]}>
      <ThemedView style={styles.container}>
        <View style={styles.header}>
          <Pressable onPress={goBack} hitSlop={12} style={styles.backBtn} accessibilityRole="button">
            <ThemedText style={styles.backIcon}>←</ThemedText>
          </Pressable>

          <ThemedText style={styles.title}>Endereço</ThemedText>
          <View style={styles.rightSpacer} />
        </View>

        <View style={styles.card}>
          <ThemedText style={styles.sectionTitle}>Informe seu endereço</ThemedText>

          <ThemedText style={styles.label}>CEP</ThemedText>
          <TextInput
            value={form.cep}
            onChangeText={(t) => setForm((p) => ({ ...p, cep: maskCep(t) }))}
            placeholder="00000-000"
            placeholderTextColor="#94A3B8"
            keyboardType="number-pad"
            style={styles.input}
            maxLength={9}
            autoCorrect={false}
            autoCapitalize="none"
          />

          <View style={styles.twoCols}>
            <View style={{ flex: 1 }}>
              <ThemedText style={styles.label}>Número</ThemedText>
              <TextInput
                value={form.number}
                onChangeText={(t) => setForm((p) => ({ ...p, number: t }))}
                placeholder="Nº"
                placeholderTextColor="#94A3B8"
                keyboardType="number-pad"
                style={styles.input}
                autoCorrect={false}
                autoCapitalize="none"
              />
            </View>

            <View style={{ flex: 1 }}>
              <ThemedText style={styles.label}>Complemento</ThemedText>
              <TextInput
                value={form.complement}
                onChangeText={(t) => setForm((p) => ({ ...p, complement: t }))}
                placeholder="Apto, casa..."
                placeholderTextColor="#94A3B8"
                style={styles.input}
                autoCorrect={false}
              />
            </View>
          </View>

          <ThemedText style={styles.label}>Rua</ThemedText>
          <TextInput
            value={form.street}
            onChangeText={(t) => setForm((p) => ({ ...p, street: t }))}
            placeholder="Nome da rua"
            placeholderTextColor="#94A3B8"
            style={styles.input}
            autoCorrect={false}
          />

          <ThemedText style={styles.label}>Bairro</ThemedText>
          <TextInput
            value={form.district}
            onChangeText={(t) => setForm((p) => ({ ...p, district: t }))}
            placeholder="Seu bairro"
            placeholderTextColor="#94A3B8"
            style={styles.input}
            autoCorrect={false}
          />

          <ThemedText style={styles.label}>Cidade/UF</ThemedText>
          <TextInput
            value={form.cityUf}
            onChangeText={(t) => setForm((p) => ({ ...p, cityUf: t }))}
            placeholder="Goiânia/GO"
            placeholderTextColor="#94A3B8"
            style={styles.input}
            autoCorrect={false}
            autoCapitalize="words"
          />

          <Pressable
            onPress={() => push("/checkout/shipping")}
            style={[styles.primaryBtn, !canContinue ? styles.primaryBtnDisabled : null]}
            accessibilityRole="button"
            disabled={!canContinue}
          >
            <ThemedText style={styles.primaryBtnText}>CONTINUAR</ThemedText>
          </Pressable>

          {!canContinue ? (
            <ThemedText style={styles.hint}>
              Preencha CEP, número, rua, bairro e cidade/UF para continuar.
            </ThemedText>
          ) : null}
        </View>
      </ThemedView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safe: { flex: 1, backgroundColor: theme.colors.background },
  container: { flex: 1, paddingHorizontal: 14, paddingTop: 6, backgroundColor: theme.colors.background },

  header: {
    height: 44,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 10,
  },
  backBtn: { width: 40, height: 40, borderRadius: 999, alignItems: "center", justifyContent: "center" },
  backIcon: { fontSize: 22, fontFamily: FONT_BODY_BOLD },
  rightSpacer: { width: 40, height: 40 },
  title: { fontSize: 20, fontFamily: FONT_TITLE, textAlign: "center" },

  card: {
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.border,
    borderRadius: 14,
    padding: 14,
  },
  sectionTitle: { fontSize: 14, fontFamily: FONT_BODY_BOLD, marginBottom: 10 },

  label: { fontSize: 12, fontFamily: FONT_BODY, opacity: 0.9, marginTop: 10, marginBottom: 6 },
  input: {
    height: 44,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: theme.colors.divider,
    paddingHorizontal: 12,
    fontFamily: FONT_BODY,
    fontSize: 12,
    backgroundColor: theme.colors.surface,
  },

  twoCols: { flexDirection: "row", gap: 10 },

  primaryBtn: {
    marginTop: 16,
    height: 44,
    borderRadius: 14,
    backgroundColor: theme.colors.primary,
    alignItems: "center",
    justifyContent: "center",
  },
  primaryBtnDisabled: { opacity: 0.6 },
  primaryBtnText: {
    color: "#fff",
    fontSize: 12,
    fontFamily: FONT_BODY_BOLD,
    textTransform: "uppercase",
  },

  hint: { marginTop: 10, fontSize: 12, fontFamily: FONT_BODY, opacity: 0.75 },
});



===== PATH: app\(tabs)\checkout\index.tsx =====
import { router } from "expo-router";
import { Alert, Pressable, StyleSheet, View } from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";

import { ThemedText } from "../../../components/themed-text";
import { ThemedView } from "../../../components/themed-view";
import theme from "../../../constants/theme";

const FONT_BODY = "OpenSans_400Regular";
const FONT_BODY_BOLD = "OpenSans_700Bold";
const FONT_TITLE = "Arimo_400Regular";

function ComingSoon(title: string) {
  Alert.alert(title, "Em breve no Plugaí Shop.");
}

export default function CheckoutIndex() {
  const goBack = () => router.back();
  const push = (path: string) => router.push(path as any);

  return (
    <SafeAreaView style={styles.safe} edges={["top", "left", "right"]}>
      <ThemedView style={styles.container}>
        <View style={styles.header}>
          <Pressable onPress={goBack} hitSlop={12} style={styles.backBtn} accessibilityRole="button">
            <ThemedText style={styles.backIcon}>←</ThemedText>
          </Pressable>

          <ThemedText style={styles.title}>Finalizar compra</ThemedText>
          <View style={styles.rightSpacer} />
        </View>

        <View style={styles.card}>
          <ThemedText style={styles.sectionTitle}>Resumo</ThemedText>

          <View style={styles.row}>
            <ThemedText style={styles.label}>Entrega</ThemedText>
            <ThemedText style={styles.value}>Endereço + Frete</ThemedText>
          </View>

          <View style={styles.row}>
            <ThemedText style={styles.label}>Pagamento</ThemedText>
            <ThemedText style={styles.value}>Selecionar forma</ThemedText>
          </View>

          <View style={styles.row}>
            <ThemedText style={styles.label}>Revisão</ThemedText>
            <ThemedText style={styles.value}>Conferir pedido</ThemedText>
          </View>

          <Pressable
            onPress={() => push("/checkout/address")}
            style={styles.primaryBtn}
            accessibilityRole="button"
          >
            <ThemedText style={styles.primaryBtnText}>CONTINUAR</ThemedText>
          </Pressable>
        </View>

        {/* Espaço de banner / conteúdo (ocupa o “vazio” abaixo do botão e do texto) */}
        <View style={styles.promoWrap}>
          <Pressable onPress={() => ComingSoon("JOGOS")} style={[styles.promoCard, styles.promoCardA]} accessibilityRole="button">
            <ThemedText style={styles.promoTitle}>JOGOS</ThemedText>
            <ThemedText style={styles.promoSubtitle}>Desafios, prêmios e novidades</ThemedText>
          </Pressable>

          <Pressable onPress={() => ComingSoon("VÍDEOS")} style={[styles.promoCard, styles.promoCardB]} accessibilityRole="button">
            <ThemedText style={styles.promoTitle}>VÍDEOS</ThemedText>
            <ThemedText style={styles.promoSubtitle}>Conteúdo rápido e ofertas</ThemedText>
          </Pressable>

          <View style={styles.promoRow}>
            <Pressable onPress={() => ComingSoon("FOTOS")} style={[styles.promoMini, styles.promoMiniC]} accessibilityRole="button">
              <ThemedText style={styles.promoMiniText}>FOTOS</ThemedText>
            </Pressable>

            <Pressable onPress={() => ComingSoon("TEXTOS")} style={[styles.promoMini, styles.promoMiniD]} accessibilityRole="button">
              <ThemedText style={styles.promoMiniText}>TEXTOS</ThemedText>
            </Pressable>
          </View>
        </View>

        <View style={styles.helpCard}>
          <ThemedText style={styles.helpTitle}>Precisa de ajuda?</ThemedText>
          <ThemedText style={styles.helpText}>
            Você poderá editar endereço, frete e pagamento nas próximas etapas.
          </ThemedText>
        </View>
      </ThemedView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safe: { flex: 1, backgroundColor: theme.colors.background },
  container: { flex: 1, paddingHorizontal: 14, paddingTop: 6, backgroundColor: theme.colors.background },

  header: {
    height: 44,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 10,
  },
  backBtn: { width: 40, height: 40, borderRadius: 999, alignItems: "center", justifyContent: "center" },
  backIcon: { fontSize: 22, fontFamily: FONT_BODY_BOLD },
  rightSpacer: { width: 40, height: 40 },
  title: { fontSize: 20, fontFamily: FONT_TITLE, textAlign: "center" },

  card: {
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.border,
    borderRadius: 14,
    padding: 14,
  },
  sectionTitle: { fontSize: 14, fontFamily: FONT_BODY_BOLD, marginBottom: 10 },

  row: {
    paddingVertical: 10,
    borderTopWidth: 1,
    borderTopColor: theme.colors.divider,
    flexDirection: "row",
    justifyContent: "space-between",
    gap: 10,
  },
  label: { fontSize: 12, fontFamily: FONT_BODY, opacity: 0.85 },
  value: { fontSize: 12, fontFamily: FONT_BODY_BOLD },

  primaryBtn: {
    marginTop: 14,
    height: 44,
    borderRadius: 14,
    backgroundColor: theme.colors.primary,
    alignItems: "center",
    justifyContent: "center",
  },
  primaryBtnText: {
    color: "#fff",
    fontSize: 12,
    fontFamily: FONT_BODY_BOLD,
    textTransform: "uppercase",
  },

  promoWrap: {
    marginTop: 12,
    gap: 10,
  },
  promoCard: {
    borderRadius: 14,
    padding: 14,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  promoCardA: { backgroundColor: theme.colors.surface },
  promoCardB: { backgroundColor: theme.colors.surface },

  promoTitle: { fontSize: 12, fontFamily: FONT_BODY_BOLD, textTransform: "uppercase" },
  promoSubtitle: { marginTop: 6, fontSize: 12, fontFamily: FONT_BODY, opacity: 0.9 },

  promoRow: { flexDirection: "row", gap: 10 },
  promoMini: {
    flex: 1,
    height: 44,
    borderRadius: 14,
    alignItems: "center",
    justifyContent: "center",
    borderWidth: 1,
    borderColor: theme.colors.border,
    backgroundColor: theme.colors.surface,
  },
  promoMiniC: {},
  promoMiniD: {},
  promoMiniText: { fontSize: 12, fontFamily: FONT_BODY_BOLD, textTransform: "uppercase" },

  helpCard: {
    marginTop: 12,
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.border,
    borderRadius: 14,
    padding: 14,
  },
  helpTitle: { fontSize: 12, fontFamily: FONT_BODY_BOLD, marginBottom: 6 },
  helpText: { fontSize: 12, fontFamily: FONT_BODY, opacity: 0.9 },
});



===== PATH: app\(tabs)\checkout\payment.tsx =====
// app/(tabs)/checkout/payment.tsx
import { router } from "expo-router";
import { Pressable, StyleSheet, View } from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";

import { ThemedText } from "../../../components/themed-text";
import { ThemedView } from "../../../components/themed-view";
import theme from "../../../constants/theme";

const FONT_BODY = "OpenSans_400Regular";
const FONT_BODY_BOLD = "OpenSans_700Bold";
const FONT_TITLE = "Arimo_400Regular";

function Option({
  title,
  desc,
  selected,
  onPress,
}: {
  title: string;
  desc: string;
  selected?: boolean;
  onPress: () => void;
}) {
  return (
    <Pressable
      onPress={onPress}
      style={[styles.option, selected ? styles.optionSelected : null]}
      accessibilityRole="button"
    >
      <View style={{ flex: 1 }}>
        <ThemedText style={styles.optionTitle}>{title}</ThemedText>
        <ThemedText style={styles.optionDesc}>{desc}</ThemedText>
      </View>
      <ThemedText style={styles.optionMark}>{selected ? "✓" : ""}</ThemedText>
    </Pressable>
  );
}

export default function CheckoutPayment() {
  const goBack = () => router.back();

  const goNext = () => {
    router.push("/(tabs)/checkout/review" as any);
  };

  return (
    <SafeAreaView style={styles.safe} edges={["top", "left", "right"]}>
      <ThemedView style={styles.container}>
        <View style={styles.header}>
          <Pressable onPress={goBack} hitSlop={12} style={styles.backBtn} accessibilityRole="button">
            <ThemedText style={styles.backIcon}>←</ThemedText>
          </Pressable>

          <ThemedText style={styles.title}>Pagamento</ThemedText>
          <View style={styles.rightSpacer} />
        </View>

        <View style={styles.card}>
          <ThemedText style={styles.sectionTitle}>Escolha uma forma</ThemedText>

          <Option title="Pix" desc="Aprovação imediata" selected onPress={() => {}} />
          <Option title="Cartão de crédito" desc="Parcelamento disponível" onPress={() => {}} />
          <Option title="Boleto" desc="Compensação em até 2 dias úteis" onPress={() => {}} />

          <Pressable onPress={goNext} style={styles.primaryBtn} accessibilityRole="button">
            <ThemedText style={styles.primaryBtnText}>CONTINUAR</ThemedText>
          </Pressable>
        </View>
      </ThemedView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safe: { flex: 1, backgroundColor: theme.colors.background },
  container: { flex: 1, paddingHorizontal: 14, paddingTop: 6, backgroundColor: theme.colors.background },

  header: {
    height: 44,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 10,
  },
  backBtn: { width: 40, height: 40, borderRadius: 999, alignItems: "center", justifyContent: "center" },
  backIcon: { fontSize: 22, fontFamily: FONT_BODY_BOLD },
  rightSpacer: { width: 40, height: 40 },
  title: { fontSize: 20, fontFamily: FONT_TITLE, textAlign: "center" },

  card: {
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.border,
    borderRadius: 14,
    padding: 14,
  },
  sectionTitle: { fontSize: 14, fontFamily: FONT_BODY_BOLD, marginBottom: 10 },

  option: {
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
    padding: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: theme.colors.divider,
    backgroundColor: theme.colors.surface,
    marginBottom: 10,
  },
  optionSelected: { borderColor: theme.colors.primary },
  optionTitle: { fontSize: 12, fontFamily: FONT_BODY_BOLD },
  optionDesc: { fontSize: 12, fontFamily: FONT_BODY, opacity: 0.85, marginTop: 4 },
  optionMark: { width: 22, textAlign: "center", fontSize: 16, fontFamily: FONT_BODY_BOLD, color: theme.colors.primary },

  primaryBtn: {
    marginTop: 6,
    height: 44,
    borderRadius: 14,
    backgroundColor: theme.colors.primary,
    alignItems: "center",
    justifyContent: "center",
  },
  primaryBtnText: { color: "#fff", fontSize: 12, fontFamily: FONT_BODY_BOLD },
});



===== PATH: app\(tabs)\checkout\review.tsx =====
// app/(tabs)/checkout/review.tsx
import { router } from "expo-router";
import { useEffect, useState } from "react";
import { Pressable, Text, View } from "react-native";

import theme from "../../../constants/theme";
import type { OrderDraft } from "../../../types/order";
import { loadOrderDraft, saveOrderDraft } from "../../../utils/orderStorage";

export default function Review() {
  const [order, setOrder] = useState<OrderDraft | null>(null);

  useEffect(() => {
    let alive = true;

    (async () => {
      const d = await loadOrderDraft();
      if (!alive) return;
      setOrder(d);
    })();

    return () => {
      alive = false;
    };
  }, []);

  async function handleConfirm() {
    if (!order) return;

    // Bridge de pagamento (mock): marca como pendente e segue
    await saveOrderDraft({
      ...order,
      payment: { method: "pix", status: "pending" },
    });

    router.push("/checkout/success");
  }

  if (!order) {
    return (
      <View style={{ flex: 1, padding: 16 }}>
        <Text style={{ fontSize: 18 }}>Carregando revisão...</Text>
      </View>
    );
  }

  return (
    <View style={{ flex: 1, padding: 16 }}>
      <Text style={{ fontSize: 24, fontWeight: "bold" }}>Revisão do Pedido</Text>

      <Text style={{ marginTop: 12 }}>Itens: {order.items.length}</Text>

      <Text style={{ marginTop: 6 }}>Subtotal: R$ {order.subtotal.toFixed(2)}</Text>

      <Text style={{ marginTop: 6 }}>Desconto: R$ {order.discount.toFixed(2)}</Text>

      <Text style={{ marginTop: 6, fontWeight: "bold" }}>Total: R$ {order.total.toFixed(2)}</Text>

      <Pressable
        onPress={handleConfirm}
        style={{
          marginTop: 24,
          backgroundColor: theme.colors.success,
          padding: 14,
          borderRadius: 8,
        }}
      >
        <Text style={{ color: "#000", fontWeight: "bold", textAlign: "center" }}>
          Confirmar pedido
        </Text>
      </Pressable>
    </View>
  );
}



===== PATH: app\(tabs)\checkout\shipping.tsx =====
// app/(tabs)/checkout/shipping.tsx
import { router } from "expo-router";
import { useMemo, useState } from "react";
import { Pressable, StyleSheet, View } from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";

import { ThemedText } from "../../../components/themed-text";
import { ThemedView } from "../../../components/themed-view";
import theme from "../../../constants/theme";

const FONT_BODY = "OpenSans_400Regular";
const FONT_BODY_BOLD = "OpenSans_700Bold";
const FONT_TITLE = "Arimo_400Regular";

type ShippingOption = {
  id: "economico" | "normal" | "expresso";
  title: string;
  desc: string;
  price: string;
};

function Option({
  option,
  selected,
  onPress,
}: {
  option: ShippingOption;
  selected?: boolean;
  onPress: () => void;
}) {
  return (
    <Pressable
      onPress={onPress}
      style={[styles.option, selected ? styles.optionSelected : null]}
      accessibilityRole="button"
    >
      <View style={{ flex: 1 }}>
        <View style={styles.optionTop}>
          <ThemedText style={styles.optionTitle}>{option.title}</ThemedText>
          <ThemedText style={styles.optionPrice}>{option.price}</ThemedText>
        </View>
        <ThemedText style={styles.optionDesc}>{option.desc}</ThemedText>
      </View>
      <ThemedText style={styles.optionMark}>{selected ? "✓" : ""}</ThemedText>
    </Pressable>
  );
}

export default function CheckoutShipping() {
  const goBack = () => router.back();
  const push = (path: string) => router.push(path as any);

  const options: ShippingOption[] = useMemo(
    () => [
      { id: "economico", title: "Econômico", desc: "Entrega estimada: 6–10 dias úteis", price: "R$ 19,90" },
      { id: "normal", title: "Normal", desc: "Entrega estimada: 3–6 dias úteis", price: "R$ 29,90" },
      { id: "expresso", title: "Expresso", desc: "Entrega estimada: 1–3 dias úteis", price: "R$ 49,90" },
    ],
    []
  );

  const [selectedId, setSelectedId] = useState<ShippingOption["id"]>("normal");

  return (
    <SafeAreaView style={styles.safe} edges={["top", "left", "right"]}>
      <ThemedView style={styles.container}>
        <View style={styles.header}>
          <Pressable onPress={goBack} hitSlop={12} style={styles.backBtn} accessibilityRole="button">
            <ThemedText style={styles.backIcon}>←</ThemedText>
          </Pressable>

          <ThemedText style={styles.title}>Frete</ThemedText>
          <View style={styles.rightSpacer} />
        </View>

        <View style={styles.card}>
          <ThemedText style={styles.sectionTitle}>Escolha a melhor opção</ThemedText>

          {options.map((opt) => (
            <Option
              key={opt.id}
              option={opt}
              selected={selectedId === opt.id}
              onPress={() => setSelectedId(opt.id)}
            />
          ))}

          <View style={styles.summary}>
            <ThemedText style={styles.summaryLabel}>Selecionado</ThemedText>
            <ThemedText style={styles.summaryValue}>
              {options.find((o) => o.id === selectedId)?.title ?? "—"}
            </ThemedText>
          </View>

          <Pressable onPress={() => push("/(tabs)/checkout/payment")} style={styles.primaryBtn} accessibilityRole="button">
            <ThemedText style={styles.primaryBtnText}>CONTINUAR</ThemedText>
          </Pressable>

          <ThemedText style={styles.hint}>
            Integração futura: cálculo real por CEP via Nuvemshop/Bling (e regras de frete). Por ora, opções simuladas.
          </ThemedText>
        </View>
      </ThemedView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safe: { flex: 1, backgroundColor: theme.colors.background },
  container: { flex: 1, paddingHorizontal: 14, paddingTop: 6, backgroundColor: theme.colors.background },

  header: {
    height: 44,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 10,
  },
  backBtn: { width: 40, height: 40, borderRadius: 999, alignItems: "center", justifyContent: "center" },
  backIcon: { fontSize: 22, fontFamily: FONT_BODY_BOLD },
  rightSpacer: { width: 40, height: 40 },
  title: { fontSize: 20, fontFamily: FONT_TITLE, textAlign: "center" },

  card: {
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.border,
    borderRadius: 14,
    padding: 14,
  },
  sectionTitle: { fontSize: 14, fontFamily: FONT_BODY_BOLD, marginBottom: 10 },

  option: {
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
    padding: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: theme.colors.divider,
    backgroundColor: theme.colors.surface,
    marginBottom: 10,
  },
  optionSelected: { borderColor: theme.colors.primary },
  optionTop: { flexDirection: "row", alignItems: "center", justifyContent: "space-between", gap: 10 },
  optionTitle: { fontSize: 12, fontFamily: FONT_BODY_BOLD },
  optionPrice: { fontSize: 12, fontFamily: FONT_BODY_BOLD, color: theme.colors.primary },
  optionDesc: { fontSize: 12, fontFamily: FONT_BODY, opacity: 0.85, marginTop: 4 },
  optionMark: { width: 22, textAlign: "center", fontSize: 16, fontFamily: FONT_BODY_BOLD, color: theme.colors.primary },

  summary: {
    marginTop: 2,
    marginBottom: 10,
    paddingVertical: 10,
    borderTopWidth: 1,
    borderTopColor: theme.colors.divider,
    flexDirection: "row",
    justifyContent: "space-between",
    gap: 10,
  },
  summaryLabel: { fontSize: 12, fontFamily: FONT_BODY, opacity: 0.85 },
  summaryValue: { fontSize: 12, fontFamily: FONT_BODY_BOLD },

  primaryBtn: {
    marginTop: 4,
    height: 44,
    borderRadius: 14,
    backgroundColor: theme.colors.primary,
    alignItems: "center",
    justifyContent: "center",
  },
  primaryBtnText: { color: "#fff", fontSize: 12, fontFamily: FONT_BODY_BOLD },

  hint: { marginTop: 12, fontSize: 12, fontFamily: FONT_BODY, opacity: 0.75 },
});



===== PATH: app\(tabs)\checkout\success.tsx =====
// app/(tabs)/checkout/success.tsx
import { router } from "expo-router";
import { useCallback, useRef } from "react";
import { Alert, Pressable, StyleSheet, View } from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";

import { ThemedText } from "../../../components/themed-text";
import { ThemedView } from "../../../components/themed-view";
import theme, { Radius, Spacing } from "../../../constants/theme";
import { useCart } from "../../../context/CartContext";
import { addOrder, createOrderFromCart } from "../../../utils/ordersStore";

function normalizeCartItems(cartAny: any) {
  const raw =
    cartAny?.items ??
    cartAny?.cartItems ??
    cartAny?.cart ??
    cartAny?.products ??
    [];

  if (!Array.isArray(raw)) return [];

  return raw
    .map((it) => {
      const product = it?.product ?? it?.item ?? it;
      const productId = product?.id ?? it?.productId ?? it?.id;
      const title = product?.title ?? it?.title ?? "Produto";
      const price = product?.price ?? it?.price ?? 0;
      const qty = it?.qty ?? it?.quantity ?? 1;

      if (productId == null) return null;

      return {
        productId: String(productId),
        title: String(title),
        price: Number(price ?? 0),
        qty: Math.max(1, Number(qty ?? 1)),
      };
    })
    .filter(Boolean) as Array<{ productId: string; qty: number; price: number; title: string }>;
}

export default function CheckoutSuccessScreen() {
  const cartAny = useCart() as any;
  const creatingRef = useRef(false);

  const clearCart = useCallback(() => {
    if (typeof cartAny?.clearCart === "function") cartAny.clearCart();
    else if (typeof cartAny?.clear === "function") cartAny.clear();
    else if (typeof cartAny?.reset === "function") cartAny.reset();
  }, [cartAny]);

  const generateOrder = useCallback(async () => {
    if (creatingRef.current) return null;
    creatingRef.current = true;

    try {
      const items = normalizeCartItems(cartAny);
      if (!items.length) return null;

      // Importante:
      // status é TÉCNICO (created/paid/...) — label "Confirmado" é só para UI.
      const order = createOrderFromCart({
        items,
        discount: 0,
        shipping: 0,
      });

      await addOrder(order);
      return order;
    } finally {
      creatingRef.current = false;
    }
  }, [cartAny]);

  const goOrders = () => router.push("/orders" as any);
  const goHome = () => router.push("/(tabs)" as any);

  const goToLatestOrder = async () => {
    const order = await generateOrder();
    clearCart();

    if (order?.id) {
      router.push(`/orders/${order.id}` as any);
      return;
    }

    Alert.alert("Pedido", "Seu pedido foi confirmado.");
    goOrders();
  };

  const justGoOrders = async () => {
    await generateOrder();
    clearCart();
    goOrders();
  };

  return (
    <SafeAreaView edges={["top", "left", "right"]} style={styles.safe}>
      <ThemedView style={styles.container}>
        <View style={styles.topbar}>
          <Pressable onPress={() => router.back()} hitSlop={12} style={styles.backBtn}>
            <ThemedText style={styles.backArrow}>←</ThemedText>
          </Pressable>

          <ThemedText style={styles.title}>Compra concluída</ThemedText>

          <View style={{ width: 44 }} />
        </View>

        <ThemedView style={styles.card}>
          <ThemedText style={styles.h1}>Pedido confirmado</ThemedText>
          <ThemedText style={styles.p}>
            Seu pedido foi registrado com sucesso. Você pode acompanhar em “Pedidos”.
          </ThemedText>

          <View style={{ height: 6 }} />

          <Pressable onPress={goToLatestOrder} style={styles.primaryBtn}>
            <ThemedText style={styles.primaryBtnText}>Ver pedido agora</ThemedText>
          </Pressable>

          <Pressable onPress={justGoOrders} style={styles.secondaryBtn}>
            <ThemedText style={styles.secondaryBtnText}>Ir para Pedidos</ThemedText>
          </Pressable>

          <Pressable
            onPress={() => {
              clearCart();
              goHome();
            }}
            style={styles.ghostBtn}
          >
            <ThemedText style={styles.ghostBtnText}>Voltar ao início</ThemedText>
          </Pressable>
        </ThemedView>
      </ThemedView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safe: { flex: 1, backgroundColor: theme.colors.background },
  container: { flex: 1, paddingHorizontal: Spacing.lg, paddingBottom: Spacing.lg },

  topbar: {
    height: 54,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: Spacing.md,
  },
  backBtn: {
    width: 44,
    height: 44,
    borderRadius: 999,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.divider,
  },
  backArrow: { fontFamily: "Arimo", fontSize: 22, fontWeight: "700", color: theme.colors.text },
  title: { fontFamily: "Arimo", fontSize: 20, fontWeight: "700", color: theme.colors.text },

  card: {
    backgroundColor: theme.colors.surface,
    borderRadius: Radius.xl,
    borderWidth: 1,
    borderColor: theme.colors.divider,
    padding: Spacing.lg,
    gap: Spacing.md,
  },
  h1: { fontFamily: "Arimo", fontSize: 20, fontWeight: "700", color: theme.colors.text },
  p: { fontFamily: "OpenSans", fontSize: 12, color: "rgba(0,0,0,0.65)", lineHeight: 16 },

  primaryBtn: {
    paddingVertical: 12,
    borderRadius: Radius.lg,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.primary,
  },
  primaryBtnText: { fontFamily: "OpenSans", fontSize: 16, fontWeight: "700", color: "#FFFFFF" },

  secondaryBtn: {
    paddingVertical: 12,
    borderRadius: Radius.lg,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.primary,
  },
  secondaryBtnText: {
    fontFamily: "OpenSans",
    fontSize: 16,
    fontWeight: "700",
    color: theme.colors.primary,
  },

  ghostBtn: {
    paddingVertical: 12,
    borderRadius: Radius.lg,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.divider,
  },
  ghostBtnText: { fontFamily: "OpenSans", fontSize: 16, fontWeight: "700", color: theme.colors.text },
});



===== PATH: app\(tabs)\explore.tsx =====
import { router } from "expo-router";
import { StatusBar } from "expo-status-bar";
import { useMemo } from "react";
import { Image, Pressable, ScrollView, StyleSheet, Text, View } from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";

import IconSymbol from "../../components/ui/icon-symbol";
import theme from "../../constants/theme";
import type { Product } from "../../data/catalog";
import { products } from "../../data/catalog";
import { formatCurrency } from "../../utils/formatCurrency";

// Collapsible blindado
const CollapsibleModule = require("../../components/ui/collapsible");
const CollapsibleComp = CollapsibleModule?.default ?? CollapsibleModule?.Collapsible;

const SafeCollapsible =
  CollapsibleComp ??
  function FallbackCollapsible(props: any) {
    return (
      <View>
        {props?.title ? <View style={{ marginBottom: 8 }}>{props.title}</View> : null}
        <View>{props?.children}</View>
      </View>
    );
  };

type CategoryItem = { id: string; name: string };

function toCategoryId(name: string) {
  return name
    .toLowerCase()
    .normalize("NFD")
    .replace(/\p{Diacritic}/gu, "")
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/(^-|-$)/g, "");
}

function categoryIconName(categoryName: string) {
  const n = (categoryName || "").toLowerCase();

  if (n.includes("eletro") && !n.includes("eletrod")) return "tv-outline";
  if (n.includes("eletrod")) return "flash-outline";
  if (n.includes("inform")) return "laptop-outline";
  if (n.includes("casa") || n.includes("lar")) return "home-outline";
  if (n.includes("moda") || n.includes("vest")) return "shirt-outline";
  if (n.includes("brinqu")) return "game-controller-outline";
  if (n.includes("pet")) return "paw-outline";
  if (n.includes("beleza") || n.includes("perf")) return "sparkles-outline";
  if (n.includes("acess")) return "pricetag-outline";

  return "pricetag-outline";
}

export default function ExploreScreen() {
  // ✅ status bar normal (escuro) aqui, porque o topo é claro
  <StatusBar style="dark" />;

  const mainCategories = useMemo<CategoryItem[]>(() => {
    const map = new Map<string, CategoryItem>();

    for (const p of products as Product[]) {
      const raw = ((p as any).category ?? "").trim();
      if (!raw) continue;

      const id = toCategoryId(raw);
      if (map.has(id)) continue;

      map.set(id, { id, name: raw });
      if (map.size >= 8) break;
    }

    if (map.size === 0) {
      const fallback = [
        "Eletrônicos",
        "Eletrodomésticos",
        "Acessórios",
        "Informática",
        "Vestuário",
        "Casa",
        "Pet",
        "Beleza",
      ];

      for (const name of fallback) {
        const id = toCategoryId(name);
        map.set(id, { id, name });
      }
    }

    return Array.from(map.values());
  }, []);

  const featured = useMemo<Product[]>(() => (products as Product[]).slice(0, 12), []);

  return (
    <SafeAreaView style={styles.container} edges={["top"]}>
      <StatusBar style="dark" />

      <View style={styles.header}>
        <Text style={styles.headerTitle}>Explorar</Text>

        <Pressable style={styles.headerAction} onPress={() => {}}>
          <Text style={styles.headerActionText}>Buscar</Text>
        </Pressable>
      </View>

      <ScrollView contentContainerStyle={styles.content} showsVerticalScrollIndicator={false}>
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Categorias principais</Text>

          <View style={styles.grid}>
            {mainCategories.map((c) => {
              const oneWord = c.name.trim().split(/\s+/).length === 1;

              return (
                <Pressable
                  key={c.id}
                  style={styles.categoryCard}
                  onPress={() => router.push((`/category/${c.id}` as unknown) as any)}
                >
                  <View style={styles.categoryIconWrap}>
                    <IconSymbol
                      name={categoryIconName(c.name)}
                      size={20}
                      color={theme.colors.primary}
                    />
                  </View>

                  <Text
                    style={styles.categoryName}
                    numberOfLines={oneWord ? 1 : 2}
                    adjustsFontSizeToFit={oneWord}
                    minimumFontScale={oneWord ? 0.82 : 1}
                  >
                    {c.name}
                  </Text>
                </Pressable>
              );
            })}
          </View>
        </View>

        <View style={styles.section}>
          <SafeCollapsible
            title={
              <View style={styles.collapseTitle}>
                <Text style={styles.collapseTitleText}>Dicas e novidades</Text>
              </View>
            }
            initiallyExpanded={false}
          >
            <Text style={styles.helperText}>
              Promoções, avisos e conteúdo leve podem ficar aqui.
            </Text>
          </SafeCollapsible>
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Produtos em destaque</Text>

          <View style={styles.productsGrid}>
            {featured.map((p) => (
              <Pressable
                key={(p as any).id}
                style={styles.productCard}
                onPress={() => router.push((`/product/${(p as any).id}` as unknown) as any)}
              >
                <Image source={{ uri: (p as any).image }} style={styles.productImage} />
                <Text style={styles.productTitle} numberOfLines={2}>
                  {(p as any).title}
                </Text>
                <Text style={styles.productPrice}>{formatCurrency((p as any).price)}</Text>
              </Pressable>
            ))}
          </View>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: theme.colors.background },

  header: {
    paddingHorizontal: 16,
    // ✅ “abaixa só um pouquinho” (SafeArea já faz o grosso)
    paddingTop: 6,
    paddingBottom: 10,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },

  // ✅ mais vistoso (negrito)
  headerTitle: { fontSize: 24, fontWeight: "800", color: theme.colors.text },

  headerAction: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 12,
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.divider,
  },
  headerActionText: { fontSize: 12, fontWeight: "700", color: theme.colors.text },

  content: { padding: 16, paddingBottom: 28 },

  section: { marginBottom: 18 },
  sectionTitle: { fontSize: 16, marginBottom: 10, color: theme.colors.text },

  grid: {
    flexDirection: "row",
    flexWrap: "wrap",
    justifyContent: "space-between",
    gap: 10,
  },
  categoryCard: {
    width: "48%",
    padding: 12,
    borderRadius: 14,
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.divider,
    alignItems: "center",
  },
  categoryIconWrap: {
    width: 34,
    height: 34,
    borderRadius: 10,
    backgroundColor: theme.colors.surfaceAlt,
    marginBottom: 8,
    alignItems: "center",
    justifyContent: "center",
  },
  categoryName: { fontSize: 12, color: theme.colors.text, textAlign: "center" },

  collapseTitle: { flexDirection: "row", alignItems: "center", paddingVertical: 6 },
  collapseTitleText: { fontSize: 14, color: theme.colors.text, fontWeight: "700" },
  helperText: { fontSize: 12, color: theme.colors.textMuted, marginTop: 8 },

  productsGrid: {
    flexDirection: "row",
    flexWrap: "wrap",
    justifyContent: "space-between",
    gap: 10,
  },
  productCard: {
    width: "48%",
    padding: 12,
    borderRadius: 14,
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.divider,
  },
  productImage: {
    width: "100%",
    height: 120,
    borderRadius: 12,
    marginBottom: 10,
    backgroundColor: theme.colors.surfaceAlt,
  },
  productTitle: { fontSize: 12, color: theme.colors.text, marginBottom: 6 },
  productPrice: { fontSize: 12, color: theme.colors.primary },
});



===== PATH: app\(tabs)\index.tsx =====
import { Image } from "expo-image";
import { Link } from "expo-router";
import { StatusBar } from "expo-status-bar";
import { useMemo, useState } from "react";
import { Pressable, ScrollView, StyleSheet, TextInput, View } from "react-native";

import ParallaxScrollView from "../../components/parallax-scroll-view";
import { ProductCard } from "../../components/product-card";
import { ThemedText } from "../../components/themed-text";
import { ThemedView } from "../../components/themed-view";
import { categories, products } from "../../constants/products";
import { useColorScheme } from "../../hooks/use-color-scheme";

// fail-safe + outbox flush
import { useCheckoutFailSafe } from "../../hooks/useCheckoutFailSafe";
import { useOutboxAutoFlush } from "../../hooks/useOutboxAutoFlush";

export default function HomeScreen() {
  // retoma checkout se existir draft pendente
  useCheckoutFailSafe();

  // tenta enviar fila quando abrir o app
  useOutboxAutoFlush();

  const colorScheme = useColorScheme() ?? "light";
  const [query, setQuery] = useState("");
  const [selectedCategory, setSelectedCategory] =
    useState<(typeof categories)[number]>("Todos");

  const filteredProducts = useMemo(() => {
    const normalizedQuery = query.trim().toLowerCase();

    return products.filter((product) => {
      const matchesCategory =
        selectedCategory === "Todos" || product.category === selectedCategory;
      const matchesQuery =
        normalizedQuery.length === 0 ||
        product.name.toLowerCase().includes(normalizedQuery) ||
        product.description.toLowerCase().includes(normalizedQuery);

      return matchesCategory && matchesQuery;
    });
  }, [query, selectedCategory]);

  return (
    <>
      {/* ✅ iPhone: horas/bateria brancas sobre o banner */}
      <StatusBar style="light" />

      <ParallaxScrollView
        headerBackgroundColor={{ light: "#0E1720", dark: "#0E1720" }}
        headerImage={
          <Image
            source={require("../../assets/banners/banner-home.png")}
            style={styles.headerBanner}
            contentFit="cover"
          />
        }
      >
        <ThemedView style={styles.titleContainer}>
          {/* ✅ nome correto, sem acento */}
          <ThemedText type="title">PLUGAISHOP</ThemedText>
          <ThemedText type="defaultSemiBold">
            Soluções curadas para acelerar a operação e o varejo inteligente.
          </ThemedText>
        </ThemedView>

        <ThemedView style={styles.heroCard}>
          <View style={{ flex: 1, gap: 8 }}>
            <ThemedText type="subtitle">Kit rápido de vitrine</ThemedText>
            <ThemedText>
              Combine iluminação, organização e sinalização para deixar seu ponto de
              venda pronto em minutos.
            </ThemedText>

            <Link href="/explore" asChild>
              <Pressable style={styles.cta}>
                <ThemedText type="defaultSemiBold">Ver recomendações</ThemedText>
              </Pressable>
            </Link>
          </View>

          {/* ✅ Remove o “banner miniatura” repetido:
              em vez de usar o mesmo banner-home aqui, usamos o banner-splash */}
          <Image
            source={require("../../assets/banners/banner-splash.png")}
            style={styles.heroImage}
            contentFit="cover"
          />
        </ThemedView>

        <ThemedView style={styles.searchSection}>
          <ThemedText type="subtitle">Catálogo PlugaiShop</ThemedText>
          <TextInput
            placeholder="Buscar por categoria ou produto"
            placeholderTextColor={colorScheme === "light" ? "#6B7280" : "#9CA3AF"}
            value={query}
            onChangeText={setQuery}
            style={[
              styles.searchInput,
              {
                backgroundColor: colorScheme === "light" ? "#F3F4F6" : "#111315",
                borderColor: colorScheme === "light" ? "#E5E7EB" : "#2A2F38",
                color: colorScheme === "light" ? "#111827" : "#F9FAFB",
              },
            ]}
          />

          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            style={styles.chipRow}
          >
            {categories.map((category) => {
              const isSelected = selectedCategory === category;

              return (
                <Pressable
                  key={category}
                  onPress={() => setSelectedCategory(category)}
                  style={[styles.chip, isSelected && styles.chipSelected]}
                >
                  <ThemedText style={isSelected ? styles.chipSelectedText : undefined}>
                    {category}
                  </ThemedText>
                </Pressable>
              );
            })}
          </ScrollView>
        </ThemedView>

        <View style={styles.grid}>
          {filteredProducts.map((product) => (
            <ProductCard key={product.id} product={product} />
          ))}

          {filteredProducts.length === 0 ? (
            <ThemedText>Não encontramos itens para sua busca.</ThemedText>
          ) : null}
        </View>

        <ThemedView style={styles.tip}>
          <ThemedText type="defaultSemiBold">Dica de uso</ThemedText>
          <ThemedText>
            {`Use o botão abaixo para testar ações rápidas e visualizar a navegação com opções contextuais.`}
          </ThemedText>

          <Link href="/modal">
            <Link.Trigger>
              <ThemedText type="link">Abrir menu de ações</ThemedText>
            </Link.Trigger>
            <Link.Preview />
            <Link.Menu>
              <Link.MenuAction
                title="Solicitar demo"
                icon="cube"
                onPress={() => alert("Demo")}
              />
              <Link.MenuAction
                title="Compartilhar"
                icon="square.and.arrow.up"
                onPress={() => alert("Link copiado")}
              />
              <Link.Menu title="Mais" icon="ellipsis">
                <Link.MenuAction
                  title="Remover"
                  icon="trash"
                  destructive
                  onPress={() => alert("Item removido")}
                />
              </Link.Menu>
            </Link.Menu>
          </Link>
        </ThemedView>
      </ParallaxScrollView>
    </>
  );
}

const styles = StyleSheet.create({
  titleContainer: {
    gap: 8,
    marginBottom: 12,
  },

  heroCard: {
    flexDirection: "row",
    gap: 12,
    alignItems: "center",
    backgroundColor: "#E6F4FE",
    padding: 16,
    borderRadius: 16,
  },

  heroImage: {
    width: 96,
    height: 96,
    borderRadius: 18,
    backgroundColor: "#0E1720",
  },

  cta: {
    marginTop: 8,
    backgroundColor: "#0a7ea4",
    paddingVertical: 10,
    paddingHorizontal: 14,
    borderRadius: 12,
  },

  searchSection: {
    gap: 12,
    marginTop: 16,
  },

  searchInput: {
    width: "100%",
    borderWidth: 1,
    borderRadius: 12,
    padding: 12,
    fontSize: 16,
  },

  chipRow: {
    flexGrow: 0,
  },

  chip: {
    paddingVertical: 8,
    paddingHorizontal: 14,
    borderRadius: 999,
    borderWidth: StyleSheet.hairlineWidth,
    borderColor: "#CBD5E1",
    marginRight: 8,
  },

  chipSelected: {
    backgroundColor: "#0a7ea4",
    borderColor: "#0a7ea4",
  },

  chipSelectedText: {
    color: "#fff",
  },

  grid: {
    marginTop: 16,
    gap: 12,
  },

  tip: {
    gap: 8,
    marginTop: 16,
  },

  // ✅ Banner do Parallax: ocupa tudo (sem “quadrado”)
  headerBanner: {
    width: "100%",
    height: "100%",
  },
});



===== PATH: app\(tabs)\orders.tsx =====
import { useEffect, useState } from "react";
import { FlatList, Pressable, Text, View } from "react-native";
import { router } from "expo-router";

import type { Order } from "../../types/order";
import { listOrders } from "../../utils/ordersStorage";
import { useOrdersAutoProgress } from "../../hooks/useOrdersAutoProgress";

function formatBRL(value: number) {
  return `R$ ${value.toFixed(2)}`.replace(".", ",");
}

export default function Orders() {
  const [orders, setOrders] = useState<Order[]>([]);

  useOrdersAutoProgress();

  useEffect(() => {
    listOrders().then(setOrders);
  }, []);

  return (
    <View style={{ flex: 1, padding: 16 }}>
      <Text style={{ fontSize: 24, fontWeight: "bold" }}>Meus Pedidos</Text>

      {orders.length === 0 ? (
        <Text style={{ marginTop: 12, fontSize: 12, opacity: 0.7 }}>
          Nenhum pedido ainda.
        </Text>
      ) : (
        <FlatList
          data={orders}
          keyExtractor={(item) => item.id}
          contentContainerStyle={{ paddingTop: 12, paddingBottom: 24 }}
          renderItem={({ item }) => (
            <Pressable
              onPress={() => router.push(`/orders/${item.id}` as any)}
              style={{
                padding: 14,
                borderRadius: 14,
                backgroundColor: "#FFFFFF",
                borderWidth: 1,
                borderColor: "#E6E8EC",
                marginBottom: 12,
              }}
            >
              <Text style={{ fontSize: 12, fontWeight: "bold" }}>
                Pedido {item.id}
              </Text>
              <Text style={{ fontSize: 12, opacity: 0.7, marginTop: 4 }}>
                Total: {formatBRL(item.total)}
              </Text>
              <Text style={{ fontSize: 12, opacity: 0.7, marginTop: 4 }}>
                Status: {item.status}
              </Text>
            </Pressable>
          )}
        />
      )}
    </View>
  );
}



===== PATH: app\(tabs)\profile.tsx =====
import React from "react";
import { StyleSheet } from "react-native";
import { ThemedText } from "../../components/themed-text";
import { ThemedView } from "../../components/themed-view";

export default function ProfileTab() {
  return (
    <ThemedView style={styles.container}>
      <ThemedText type="title">Perfil</ThemedText>
      <ThemedText style={styles.subtitle}>Tela de perfil (rota do Tab).</ThemedText>
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, padding: 16 },
  subtitle: { marginTop: 8, opacity: 0.8 },
});



===== PATH: app\checkout\_layout.tsx =====
import React from "react";
import { Stack } from "expo-router";

export default function CheckoutLayout() {
  return (
    <Stack
      screenOptions={{
        headerShown: false,
        animation: "slide_from_right",
      }}
    >
      {/* Fluxo de checkout */}
      <Stack.Screen name="export-debug" />
      <Stack.Screen name="payment" />
      <Stack.Screen name="pix" />
      <Stack.Screen name="review" />
      <Stack.Screen name="shipping" />
      <Stack.Screen name="success" />
    </Stack>
  );
}



===== PATH: app\checkout\export-debug.tsx =====
import { useEffect, useState } from "react";
import { ScrollView, Text, View } from "react-native";

import type { Order } from "../../types/order";
import { listOrders } from "../../utils/ordersStorage";
import { exportOrder } from "../../utils/orderExport";

export default function ExportDebug() {
  const [json, setJson] = useState<string>("Carregando...");

  useEffect(() => {
    (async () => {
      const orders = await listOrders();
      const last = orders[0] as Order | undefined;

      if (!last) {
        setJson("Nenhum pedido encontrado em Meus Pedidos.");
        return;
      }

      const out = exportOrder(last);
      setJson(JSON.stringify(out, null, 2));
    })();
  }, []);

  return (
    <View style={{ flex: 1, padding: 16 }}>
      <Text style={{ fontSize: 20, fontWeight: "bold" }}>Export Debug</Text>
      <Text style={{ marginTop: 8, fontSize: 12, opacity: 0.7 }}>
        Último pedido salvo (canonical + bling + nuvemshop)
      </Text>

      <ScrollView style={{ marginTop: 12 }}>
        <Text style={{ fontSize: 11 }}>{json}</Text>
      </ScrollView>
    </View>
  );
}



===== PATH: app\checkout\payment.tsx =====
import { useEffect, useMemo, useState } from "react";
import { Pressable, Text, TextInput, View } from "react-native";
import { router } from "expo-router";

import theme from "../../constants/theme";
import type { OrderDraft, Payment } from "../../types/order";
import { loadOrderDraft, saveOrderDraft } from "../../utils/orderStorage";
import { patchOrderDraft } from "../../utils/orderDraftPatch";
import { createPayment, createPaymentPayload } from "../../utils/paymentBridge";

type Method = Payment["method"];

function Label({ children }: { children: string }) {
  return <Text style={{ marginTop: 12, fontSize: 12, opacity: 0.7 }}>{children}</Text>;
}

function CardOption({
  title,
  subtitle,
  active,
  onPress,
}: {
  title: string;
  subtitle: string;
  active: boolean;
  onPress: () => void;
}) {
  return (
    <Pressable
      onPress={onPress}
      style={{
        padding: 12,
        borderRadius: 14,
        borderWidth: 1,
        borderColor: active ? theme.colors.primary : theme.colors.divider,
        backgroundColor: theme.colors.surface,
        marginTop: 10,
      }}
    >
      <Text style={{ fontSize: 12, fontWeight: "bold" }}>{title}</Text>
      <Text style={{ fontSize: 12, opacity: 0.7, marginTop: 4 }}>{subtitle}</Text>
    </Pressable>
  );
}

export default function PaymentScreen() {
  const [draft, setDraft] = useState<OrderDraft | null>(null);
  const [method, setMethod] = useState<Method>("pix");

  // mock card fields
  const [cardNumber, setCardNumber] = useState("");
  const [cardBrand, setCardBrand] = useState<"visa" | "mastercard" | "elo" | "amex" | "other">("other");

  useEffect(() => {
    (async () => {
      const d = await loadOrderDraft();
      setDraft(d);

      const m = d?.payment?.method;
      if (m) setMethod(m);
    })();
  }, []);

  const canContinue = useMemo(() => {
    if (!draft) return false;
    if (method === "card") return cardNumber.replace(/\D/g, "").length >= 12; // mock mínimo
    return true;
  }, [draft, method, cardNumber]);

  async function handleContinue() {
    if (!draft) return;

    const payment = createPayment(method);

    // payload mock (útil para log/integração futura)
    const last4 = cardNumber.replace(/\D/g, "").slice(-4);
    const payload =
      method === "card"
        ? createPaymentPayload("card", { last4, brand: cardBrand })
        : createPaymentPayload(method);

    const next = patchOrderDraft(draft, {
      payment,
      // opcional: você pode guardar payload em outro lugar depois (Orders/Back-end)
    });

    await saveOrderDraft(next);

    // segue para revisão
    router.push("/checkout/review");
  }

  if (!draft) {
    return (
      <View style={{ flex: 1, padding: 16 }}>
        <Text style={{ fontSize: 16 }}>Carregando pagamento...</Text>
      </View>
    );
  }

  return (
    <View style={{ flex: 1, padding: 16 }}>
      <Text style={{ fontSize: 24, fontWeight: "bold" }}>Pagamento</Text>

      <Label>Escolha um método</Label>

      <CardOption
        title="Pix"
        subtitle="Aprovação rápida"
        active={method === "pix"}
        onPress={() => setMethod("pix")}
      />

      <CardOption
        title="Cartão"
        subtitle="Crédito / Débito (mock)"
        active={method === "card"}
        onPress={() => setMethod("card")}
      />

      <CardOption
        title="Boleto"
        subtitle="Vencimento em 2 dias (mock)"
        active={method === "boleto"}
        onPress={() => setMethod("boleto")}
      />

      {method === "card" ? (
        <View style={{ marginTop: 10 }}>
          <Label>Número do cartão (mock)</Label>
          <TextInput
            value={cardNumber}
            onChangeText={setCardNumber}
            keyboardType="number-pad"
            placeholder="0000 0000 0000 0000"
            style={{
              marginTop: 8,
              paddingVertical: 12,
              paddingHorizontal: 12,
              borderRadius: 12,
              borderWidth: 1,
              borderColor: theme.colors.divider,
              backgroundColor: theme.colors.surface,
            }}
          />

          <Label>Bandeira (mock)</Label>
          <View style={{ flexDirection: "row", gap: 8, marginTop: 8 }}>
            {(["visa", "mastercard", "elo", "amex", "other"] as const).map((b) => {
              const active = cardBrand === b;
              return (
                <Pressable
                  key={b}
                  onPress={() => setCardBrand(b)}
                  style={{
                    paddingVertical: 8,
                    paddingHorizontal: 10,
                    borderRadius: 999,
                    borderWidth: 1,
                    borderColor: active ? theme.colors.primary : theme.colors.divider,
                    backgroundColor: theme.colors.surface,
                  }}
                >
                  <Text style={{ fontSize: 12, fontWeight: active ? "bold" : "normal" }}>
                    {b.toUpperCase()}
                  </Text>
                </Pressable>
              );
            })}
          </View>
        </View>
      ) : null}

      <Pressable
        onPress={handleContinue}
        disabled={!canContinue}
        style={{
          marginTop: 18,
          backgroundColor: theme.colors.success,
          padding: 14,
          borderRadius: 12,
          opacity: canContinue ? 1 : 0.5,
        }}
      >
        <Text style={{ color: "#000", fontWeight: "bold", textAlign: "center" }}>
          Continuar
        </Text>
      </Pressable>
    </View>
  );
}



===== PATH: app\checkout\pix.tsx =====
import { useEffect, useMemo, useState } from "react";
import { Pressable, Text, View } from "react-native";
import QRCode from "react-native-qrcode-svg";
import * as Clipboard from "expo-clipboard";
import { router } from "expo-router";

import theme from "../../constants/theme";
import { loadOrderDraft, saveOrderDraft } from "../../utils/orderStorage";
import type { OrderDraft } from "../../types/order";
import { makePixCode, pixExpiresAt, msLeft } from "../../utils/pix";
import { patchOrderDraft } from "../../utils/orderDraftPatch";

function formatMMSS(ms: number) {
  const total = Math.floor(ms / 1000);
  const mm = String(Math.floor(total / 60)).padStart(2, "0");
  const ss = String(total % 60).padStart(2, "0");
  return `${mm}:${ss}`;
}

export default function PixScreen() {
  const [draft, setDraft] = useState<OrderDraft | null>(null);
  const [expiresAt, setExpiresAt] = useState<string>("");
  const [left, setLeft] = useState<number>(0);
  const [copied, setCopied] = useState(false);

  useEffect(() => {
    (async () => {
      const d = await loadOrderDraft();
      if (!d) return;

      // garante payment pix no draft
      const next = patchOrderDraft(d, { payment: { method: "pix", status: "pending" } });
      await saveOrderDraft(next);

      const exp = pixExpiresAt(2);
      setExpiresAt(exp);
      setDraft(next);
      setLeft(msLeft(exp));
    })();
  }, []);

  useEffect(() => {
    if (!expiresAt) return;
    const id = setInterval(() => setLeft(msLeft(expiresAt)), 1000);
    return () => clearInterval(id);
  }, [expiresAt]);

  const code = useMemo(() => (draft ? makePixCode(draft.id) : ""), [draft]);

  async function handleCopy() {
    if (!code) return;
    await Clipboard.setStringAsync(code);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  }

  async function handleMarkPaid() {
    if (!draft) return;
    await saveOrderDraft(patchOrderDraft(draft, { payment: { method: "pix", status: "paid" } }));
    router.push("/checkout/review");
  }

  if (!draft) {
    return (
      <View style={{ flex: 1, padding: 16 }}>
        <Text style={{ fontSize: 16 }}>Carregando Pix...</Text>
      </View>
    );
  }

  const expired = left <= 0;

  return (
    <View style={{ flex: 1, padding: 16 }}>
      <Text style={{ fontSize: 24, fontWeight: "bold" }}>Pix</Text>

      <Text style={{ marginTop: 8, fontSize: 12, opacity: 0.75 }}>
        Escaneie o QR Code ou copie o código Pix.
      </Text>

      <View
        style={{
          marginTop: 16,
          alignItems: "center",
          justifyContent: "center",
          padding: 16,
          borderRadius: 16,
          backgroundColor: theme.colors.surface,
          borderWidth: 1,
          borderColor: theme.colors.divider,
        }}
      >
        <QRCode value={code} size={220} />
        <Text style={{ marginTop: 10, fontSize: 12, opacity: 0.75 }}>
          Expira em: {expired ? "00:00" : formatMMSS(left)}
        </Text>
      </View>

      <Pressable
        onPress={handleCopy}
        style={{
          marginTop: 16,
          backgroundColor: "#EEF1F5",
          padding: 14,
          borderRadius: 12,
          borderWidth: 1,
          borderColor: theme.colors.divider,
        }}
      >
        <Text style={{ textAlign: "center", fontWeight: "bold" }}>
          {copied ? "Código copiado" : "Copiar código Pix"}
        </Text>
      </Pressable>

      <Pressable
        onPress={handleMarkPaid}
        disabled={expired}
        style={{
          marginTop: 10,
          backgroundColor: theme.colors.success,
          padding: 14,
          borderRadius: 12,
          opacity: expired ? 0.5 : 1,
        }}
      >
        <Text style={{ textAlign: "center", fontWeight: "bold", color: "#000" }}>
          Simular pagamento aprovado
        </Text>
      </Pressable>
    </View>
  );
}



===== PATH: app\checkout\review.tsx =====
import { router } from "expo-router";
import { useEffect, useMemo, useState } from "react";
import { Pressable, Text, View } from "react-native";

import theme from "../../constants/theme";
import type { OrderDraft } from "../../types/order";
import { loadOrderDraft, saveOrderDraft } from "../../utils/orderStorage";

export default function Review() {
  const [order, setOrder] = useState<OrderDraft | null>(null);

  useEffect(() => {
    loadOrderDraft().then(setOrder);
  }, []);

  const discount = useMemo(() => Number(order?.discount ?? 0), [order]);

  async function handleConfirm() {
    if (!order) return;

    await saveOrderDraft({
      ...order,
      discount,
      payment: { method: "pix", status: "pending" },
    } as any);

    router.push("/checkout/success" as any);
  }

  if (!order) {
    return (
      <View style={{ flex: 1, padding: 16 }}>
        <Text style={{ fontSize: 18 }}>Carregando revisão...</Text>
      </View>
    );
  }

  return (
    <View style={{ flex: 1, padding: 16 }}>
      <Text style={{ fontSize: 24, fontWeight: "bold" }}>Revisão do Pedido</Text>

      <Text style={{ marginTop: 12 }}>Itens: {order.items.length}</Text>

      <Text style={{ marginTop: 6 }}>
        Subtotal: R$ {order.subtotal.toFixed(2)}
      </Text>

      <Text style={{ marginTop: 6 }}>
        Desconto: R$ {(order.discount ?? 0).toFixed(2)}
      </Text>

      <Text style={{ marginTop: 6, fontWeight: "bold" }}>
        Total: R$ {order.total.toFixed(2)}
      </Text>

      <Pressable
        onPress={handleConfirm}
        style={{
          marginTop: 24,
          backgroundColor: theme.colors.success,
          padding: 14,
          borderRadius: 8,
        }}
      >
        <Text style={{ color: "#000", fontWeight: "bold", textAlign: "center" }}>
          Confirmar pedido
        </Text>
      </Pressable>
    </View>
  );
}



===== PATH: app\checkout\shipping.tsx =====
import { useEffect, useMemo, useState } from "react";
import { Pressable, Text, TextInput, View } from "react-native";
import { router } from "expo-router";

import theme from "../../constants/theme";
import type { OrderDraft } from "../../types/order";
import { loadOrderDraft, saveOrderDraft } from "../../utils/orderStorage";
import { formatCEP, normalizeCEP, isValidCEP } from "../../utils/cep";
import { getShippingOptions } from "../../utils/shippingService";
import { patchOrderDraft } from "../../utils/orderDraftPatch";

function formatBRL(value: number) {
  return `R$ ${value.toFixed(2)}`.replace(".", ",");
}

export default function ShippingScreen() {
  const [draft, setDraft] = useState<OrderDraft | null>(null);
  const [cep, setCep] = useState("");
  const [selectedId, setSelectedId] = useState<"pac" | "sedex" | "express">("pac");

  useEffect(() => {
    (async () => {
      const d = await loadOrderDraft();
      setDraft(d);

      const initialCep = d?.address?.zip ?? "";
      setCep(formatCEP(initialCep));
      if (d?.shipping?.method?.toLowerCase().includes("sedex")) setSelectedId("sedex");
      if (d?.shipping?.method?.toLowerCase().includes("express")) setSelectedId("express");
    })();
  }, []);

  const options = useMemo(() => getShippingOptions(cep), [cep]);
  const selected = useMemo(
    () => options.find((o) => o.id === selectedId) ?? options[0],
    [options, selectedId]
  );

  async function handleContinue() {
    if (!draft) return;

    const zip8 = normalizeCEP(cep);
    if (!isValidCEP(zip8)) return;

    const next = patchOrderDraft(draft, {
      address: { ...(draft.address ?? { id: "addr-1" }), zip: zip8 },
      shipping: { method: selected.method, price: selected.price, deadline: selected.deadline },
    });

    await saveOrderDraft(next);
    router.push("/checkout/review");
  }

  if (!draft) {
    return (
      <View style={{ flex: 1, padding: 16 }}>
        <Text style={{ fontSize: 16 }}>Carregando frete...</Text>
      </View>
    );
  }

  const zip8 = normalizeCEP(cep);
  const valid = isValidCEP(zip8);

  return (
    <View style={{ flex: 1, padding: 16 }}>
      <Text style={{ fontSize: 24, fontWeight: "bold" }}>Frete</Text>

      <Text style={{ marginTop: 12, fontSize: 12, opacity: 0.7 }}>Digite seu CEP</Text>

      <TextInput
        value={cep}
        onChangeText={(t) => setCep(formatCEP(t))}
        keyboardType="number-pad"
        placeholder="00000-000"
        style={{
          marginTop: 8,
          paddingVertical: 12,
          paddingHorizontal: 12,
          borderRadius: 12,
          borderWidth: 1,
          borderColor: theme.colors.divider,
          backgroundColor: theme.colors.surface,
        }}
      />

      <View style={{ marginTop: 14 }}>
        {options.map((o) => {
          const active = o.id === selectedId;
          return (
            <Pressable
              key={o.id}
              onPress={() => setSelectedId(o.id)}
              style={{
                padding: 12,
                borderRadius: 14,
                borderWidth: 1,
                borderColor: active ? theme.colors.primary : theme.colors.divider,
                backgroundColor: theme.colors.surface,
                marginBottom: 10,
              }}
            >
              <Text style={{ fontSize: 12, fontWeight: "bold" }}>{o.method}</Text>
              <Text style={{ fontSize: 12, opacity: 0.7, marginTop: 4 }}>
                {o.deadline} • {o.price > 0 ? formatBRL(o.price) : "—"}
              </Text>
            </Pressable>
          );
        })}
      </View>

      <Pressable
        onPress={handleContinue}
        disabled={!valid}
        style={{
          marginTop: 10,
          backgroundColor: theme.colors.success,
          padding: 14,
          borderRadius: 12,
          opacity: valid ? 1 : 0.5,
        }}
      >
        <Text style={{ color: "#000", fontWeight: "bold", textAlign: "center" }}>
          Continuar
        </Text>
      </Pressable>
    </View>
  );
}



===== PATH: app\checkout\success.tsx =====
import { router } from "expo-router";
import { useCallback } from "react";
import { Alert, Pressable, StyleSheet, View } from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";

import { ThemedText } from "../../components/themed-text";
import { ThemedView } from "../../components/themed-view";
import theme, { Radius, Spacing } from "../../constants/theme";
import { useCart } from "../../context/CartContext";
import { addOrder, createOrderFromCart } from "../../utils/ordersStore";

function normalizeCartItems(cartAny: any) {
  const raw =
    cartAny?.items ??
    cartAny?.cartItems ??
    cartAny?.cart ??
    cartAny?.products ??
    [];

  if (!Array.isArray(raw)) return [];

  return raw
    .map((it) => {
      const product = it?.product ?? it?.item ?? it;
      const productId = product?.id ?? it?.productId ?? it?.id;
      const title = product?.title ?? it?.title ?? "Produto";
      const price = product?.price ?? it?.price ?? 0;
      const qty = it?.qty ?? it?.quantity ?? 1;

      if (productId == null) return null;

      return {
        productId: String(productId),
        title: String(title),
        price: Number(price ?? 0),
        qty: Math.max(1, Number(qty ?? 1)),
      };
    })
    .filter(Boolean) as Array<{ productId: string; qty: number; price: number; title: string }>;
}

export default function CheckoutSuccessScreen() {
  const cartAny = useCart() as any;

  const clearCart = useCallback(() => {
    if (typeof cartAny?.clearCart === "function") cartAny.clearCart();
    else if (typeof cartAny?.clear === "function") cartAny.clear();
    else if (typeof cartAny?.reset === "function") cartAny.reset();
  }, [cartAny]);

  const generateOrder = useCallback(async () => {
    const items = normalizeCartItems(cartAny);

    if (!items.length) {
      return null;
    }

    const order = createOrderFromCart({
      items,
      discount: 0,
      shipping: 0,
      status: "Confirmado",
    });

    await addOrder(order);
    return order;
  }, [cartAny]);

  const goOrders = () => router.push("/orders" as any);
  const goHome = () => router.push("/(tabs)" as any);

  const goToLatestOrder = async () => {
    const order = await generateOrder();
    clearCart();

    if (order?.id) {
      router.push(`/orders/${order.id}` as any);
      return;
    }

    Alert.alert("Pedido", "Seu pedido foi confirmado.");
    goOrders();
  };

  const justGoOrders = async () => {
    await generateOrder();
    clearCart();
    goOrders();
  };

  return (
    <SafeAreaView edges={["top", "left", "right"]} style={styles.safe}>
      <ThemedView style={styles.container}>
        <View style={styles.topbar}>
          <Pressable onPress={() => router.back()} hitSlop={12} style={styles.backBtn}>
            <ThemedText style={styles.backArrow}>←</ThemedText>
          </Pressable>

          <ThemedText style={styles.title}>Compra concluída</ThemedText>

          <View style={{ width: 44 }} />
        </View>

        <ThemedView style={styles.card}>
          <ThemedText style={styles.h1}>Pedido confirmado</ThemedText>
          <ThemedText style={styles.p}>
            Seu pedido foi registrado com sucesso. Você pode acompanhar em “Pedidos”.
          </ThemedText>

          <View style={{ height: 6 }} />

          <Pressable onPress={goToLatestOrder} style={styles.primaryBtn}>
            <ThemedText style={styles.primaryBtnText}>Ver pedido agora</ThemedText>
          </Pressable>

          <Pressable onPress={justGoOrders} style={styles.secondaryBtn}>
            <ThemedText style={styles.secondaryBtnText}>Ir para Pedidos</ThemedText>
          </Pressable>

          <Pressable
            onPress={() => {
              clearCart();
              goHome();
            }}
            style={styles.ghostBtn}
          >
            <ThemedText style={styles.ghostBtnText}>Voltar ao início</ThemedText>
          </Pressable>
        </ThemedView>
      </ThemedView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safe: { flex: 1, backgroundColor: theme.colors.background },
  container: { flex: 1, paddingHorizontal: Spacing.lg, paddingBottom: Spacing.lg },

  topbar: {
    height: 54,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: Spacing.md,
  },
  backBtn: {
    width: 44,
    height: 44,
    borderRadius: 999,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.divider,
  },
  backArrow: { fontFamily: "Arimo", fontSize: 22, fontWeight: "700", color: theme.colors.text },
  title: { fontFamily: "Arimo", fontSize: 20, fontWeight: "700", color: theme.colors.text },

  card: {
    backgroundColor: theme.colors.surface,
    borderRadius: Radius.xl,
    borderWidth: 1,
    borderColor: theme.colors.divider,
    padding: Spacing.lg,
    gap: Spacing.md,
  },
  h1: { fontFamily: "Arimo", fontSize: 20, fontWeight: "700", color: theme.colors.text },
  p: { fontFamily: "OpenSans", fontSize: 12, color: "rgba(0,0,0,0.65)", lineHeight: 16 },

  primaryBtn: {
    paddingVertical: 12,
    borderRadius: Radius.lg,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.primary,
  },
  primaryBtnText: { fontFamily: "OpenSans", fontSize: 16, fontWeight: "700", color: "#FFFFFF" },

  secondaryBtn: {
    paddingVertical: 12,
    borderRadius: Radius.lg,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.primary,
  },
  secondaryBtnText: { fontFamily: "OpenSans", fontSize: 16, fontWeight: "700", color: theme.colors.primary },

  ghostBtn: {
    paddingVertical: 12,
    borderRadius: Radius.lg,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.divider,
  },
  ghostBtnText: { fontFamily: "OpenSans", fontSize: 16, fontWeight: "700", color: theme.colors.text },
});



===== PATH: app\debug\_layout.tsx =====
import React from "react";
import { Stack } from "expo-router";

export default function DebugLayout() {
  return (
    <Stack
      screenOptions={{
        headerShown: false,
        animation: "fade_from_bottom",
      }}
    >
      {/* Telas de debug */}
      <Stack.Screen name="outbox" />
    </Stack>
  );
}



===== PATH: app\debug\outbox.tsx =====
import { useEffect, useState } from "react";
import { Pressable, ScrollView, Text, View } from "react-native";

import { getOutbox } from "../../utils/outboxStorage";
import { processOutboxOnce } from "../../utils/outboxProcessor";

export default function OutboxDebug() {
  const [json, setJson] = useState("Carregando...");

  async function refresh() {
    const out = await getOutbox();
    setJson(JSON.stringify(out, null, 2));
  }

  useEffect(() => {
    refresh();
  }, []);

  async function flush() {
    await processOutboxOnce();
    await refresh();
  }

  return (
    <View style={{ flex: 1, padding: 16 }}>
      <Text style={{ fontSize: 20, fontWeight: "bold" }}>Outbox Debug</Text>

      <Pressable
        onPress={flush}
        style={{
          marginTop: 12,
          padding: 12,
          borderRadius: 12,
          backgroundColor: "#EEF1F5",
          borderWidth: 1,
          borderColor: "#E6E8EC",
        }}
      >
        <Text style={{ textAlign: "center", fontWeight: "bold" }}>Forçar envio agora</Text>
      </Pressable>

      <ScrollView style={{ marginTop: 12 }}>
        <Text style={{ fontSize: 11 }}>{json}</Text>
      </ScrollView>
    </View>
  );
}



===== PATH: app\modal.tsx =====
import { Link } from 'expo-router';
import { StyleSheet } from 'react-native';

import { ThemedText } from '@/components/themed-text';
import { ThemedView } from '@/components/themed-view';

export default function ModalScreen() {
  return (
    <ThemedView style={styles.container}>
      <ThemedText type="title">This is a modal</ThemedText>
      <Link href="/" dismissTo style={styles.link}>
        <ThemedText type="link">Go to home screen</ThemedText>
      </Link>
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  link: {
    marginTop: 15,
    paddingVertical: 15,
  },
});



===== PATH: app\orders\_layout.tsx =====
// app/orders/_layout.tsx
import React from "react";
import { Stack } from "expo-router";

export default function OrdersStackLayout() {
  return (
    <Stack
      screenOptions={{
        headerShown: false,
        animation: "slide_from_right",
      }}
    >
      {/* Dentro de /orders as rotas são relativas */}
      <Stack.Screen name="index" />
      <Stack.Screen name="[id]" />
      <Stack.Screen name="[id]/support" />
      <Stack.Screen name="[id]/invoice" />
      <Stack.Screen name="[id]/review" />
      <Stack.Screen name="[id]/return" />
      <Stack.Screen name="[id]/tracking" />
      <Stack.Screen name="notifications" />
    </Stack>
  );
}



===== PATH: app\orders\[id].tsx =====
// app/orders/[id].tsx
import React, { useCallback, useMemo, useState } from "react";
import {
  Alert,
  Pressable,
  ScrollView,
  StyleSheet,
  View,
  Linking,
  Share,
} from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { router, useLocalSearchParams, useFocusEffect } from "expo-router";

import { ThemedText } from "../../components/themed-text";
import { ThemedView } from "../../components/themed-view";
import theme, { Radius, Spacing } from "../../constants/theme";
import OrderTimeline, { TimelineStep } from "../../components/OrderTimeline";

import { products } from "../../data/catalog";
import { useCart } from "../../context/CartContext";
import { formatCurrency } from "../../utils/formatCurrency";
import type { Order, OrderStatus } from "../../utils/ordersStore";
import { getOrderById, advanceOrderStatus } from "../../utils/ordersStore";

function safeString(v: unknown) {
  if (typeof v === "string") return v;
  if (typeof v === "number") return String(v);
  return "";
}

function dateLabel(isoOrAny: string) {
  if (!isoOrAny) return "";
  const d = isoOrAny.includes("T") ? isoOrAny.split("T")[0] : isoOrAny;
  if (d.includes("-")) return d.split("-").reverse().join("/");
  return d;
}

async function copyToClipboard(text: string) {
  try {
    const mod = await import("expo-clipboard");
    if (mod?.setStringAsync) {
      await mod.setStringAsync(text);
      return true;
    }
    return false;
  } catch {
    return false;
  }
}

export default function OrderDetailScreen() {
  const params = useLocalSearchParams();
  const orderId = safeString(params?.id);

  const cartAny = useCart() as any;
  const [order, setOrder] = useState<Order | null>(null);

  const load = useCallback(async () => {
    if (!orderId) {
      setOrder(null);
      return;
    }
    const found = await getOrderById(orderId);
    setOrder(found);
  }, [orderId]);

  useFocusEffect(
    useCallback(() => {
      load();
    }, [load])
  );

  const historyMap = useMemo(() => {
    const map = new Map<OrderStatus, string>();
    const hist = Array.isArray(order?.statusHistory) ? order!.statusHistory! : [];
    for (const h of hist) {
      if (h?.status && h?.at) map.set(h.status, h.at);
    }
    if (!map.has("Confirmado") && order?.createdAt) map.set("Confirmado", order.createdAt);
    return map;
  }, [order]);

  const timelineSteps: TimelineStep[] = useMemo(() => {
    const status = (order?.status ?? "").toString().toLowerCase();

    const donePago = ["pago", "enviado", "entregue"].includes(status);
    const doneEnviado = ["enviado", "entregue"].includes(status);
    const doneEntregue = status === "entregue";

    const dConfirmado = historyMap.get("Confirmado");
    const dPago = historyMap.get("Pago");
    const dEnviado = historyMap.get("Enviado");
    const dEntregue = historyMap.get("Entregue");

    return [
      {
        title: "Pedido confirmado",
        subtitle: dConfirmado ? `Recebido em ${dateLabel(dConfirmado)}` : "Recebemos seu pedido com sucesso.",
        done: true,
        active: status === "confirmado" || !status,
      },
      {
        title: "Pagamento aprovado",
        subtitle: dPago ? `Aprovado em ${dateLabel(dPago)}` : "Pagamento validado.",
        done: donePago,
        active: status === "pago",
      },
      {
        title: "Pedido enviado",
        subtitle: dEnviado ? `Enviado em ${dateLabel(dEnviado)}` : "Seu pedido saiu para entrega.",
        done: doneEnviado,
        active: status === "enviado",
      },
      {
        title: "Pedido entregue",
        subtitle: dEntregue ? `Entregue em ${dateLabel(dEntregue)}` : "Entrega concluída.",
        done: doneEntregue,
        active: status === "entregue",
      },
    ];
  }, [order, historyMap]);

  const totals = useMemo(() => {
    const items = order?.items ?? [];
    const subtotal = items.reduce((acc, it) => acc + Number(it.price ?? 0) * Number(it.qty ?? 0), 0);
    const discount = Number(order?.discount ?? 0);
    const shipping = Number(order?.shipping ?? 0);
    const total = Math.max(0, subtotal - discount + shipping);
    const count = items.reduce((a, b) => a + Number(b.qty ?? 0), 0);
    return { subtotal, discount, shipping, total, count };
  }, [order]);

  const onCopyId = async () => {
    if (!orderId) return;
    const ok = await copyToClipboard(orderId);
    if (ok) Alert.alert("Copiado", "ID do pedido copiado para a área de transferência.");
    else Alert.alert("Copiar ID", `Copie manualmente: ${orderId}`);
  };

  const onTrackExternal = async () => {
    const url = `https://example.com/rastreio?pedido=${encodeURIComponent(orderId || "0")}`;
    const supported = await Linking.canOpenURL(url);
    if (!supported) {
      Alert.alert("Indisponível", "Não foi possível abrir o link de rastreio neste dispositivo.");
      return;
    }
    Linking.openURL(url);
  };

  const onRepeatPurchase = () => {
    const items = order?.items ?? [];
    if (!items.length) {
      Alert.alert("Atenção", "Este pedido não possui itens para repetir.");
      return;
    }

    const addOne = (product: any, qty: number) => {
      if (typeof cartAny?.addItem === "function") return cartAny.addItem(product, qty);
      if (typeof cartAny?.addToCart === "function") return cartAny.addToCart(product, qty);
      if (typeof cartAny?.add === "function") return cartAny.add(product, qty);
      return null;
    };

    let added = 0;
    for (const it of items) {
      const prod = (products as any[])?.find((p) => String(p.id) === String(it.productId));
      if (!prod) continue;
      const qty = Math.max(1, Number(it.qty ?? 1));
      addOne(prod, qty);
      added += qty;
    }

    if (!added) {
      Alert.alert("Não foi possível repetir", "Não encontramos os produtos deste pedido no catálogo atual.");
      return;
    }

    Alert.alert("Repetir compra", "Itens adicionados ao carrinho.", [
      { text: "Continuar", style: "default" },
      { text: "Ir para o carrinho", style: "default", onPress: () => router.push("/(tabs)/cart" as any) },
    ]);
  };

  const onAdvanceStatus = async () => {
    if (!orderId) return;
    const updated = await advanceOrderStatus(orderId);
    if (!updated) {
      Alert.alert("Status", "Não foi possível atualizar o status deste pedido.");
      return;
    }
    setOrder(updated);
    Alert.alert("Status atualizado", `Novo status: ${updated.status}`);
  };

  const onShare = async () => {
    if (!orderId) return;
    try {
      await Share.share({
        message: `Pedido Plugaí Shop #${orderId} — status: ${order?.status ?? "Confirmado"}`,
      });
    } catch {
      Alert.alert("Compartilhar", "Não foi possível compartilhar no momento.");
    }
  };

  const goSupport = () => router.push(`/orders/${orderId}/support` as any);
  const goInvoice = () => router.push(`/orders/${orderId}/invoice` as any);
  const goReview = () => router.push(`/orders/${orderId}/review` as any);
  const goReturn = () => router.push(`/orders/${orderId}/return` as any);
  const goNotifications = () => router.push(`/orders/notifications` as any);
  const goTracking = () => router.push(`/orders/${orderId}/tracking` as any);

  if (!order) {
    return (
      <SafeAreaView edges={["top", "left", "right"]} style={styles.safe}>
        <ThemedView style={styles.container}>
          <View style={styles.topbar}>
            <Pressable onPress={() => router.back()} hitSlop={12} style={styles.backBtn}>
              <ThemedText style={styles.backArrow}>←</ThemedText>
            </Pressable>
            <ThemedText style={styles.title}>Pedido detalhe</ThemedText>
            <View style={{ width: 44 }} />
          </View>

          <ThemedView style={styles.card}>
            <ThemedText style={styles.cardTitle}>Pedido não encontrado</ThemedText>
            <ThemedText style={styles.secondary}>
              Não localizamos o pedido informado. Volte e selecione um pedido válido.
            </ThemedText>
          </ThemedView>
        </ThemedView>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView edges={["top", "left", "right"]} style={styles.safe}>
      <ThemedView style={styles.container}>
        <View style={styles.topbar}>
          <Pressable onPress={() => router.back()} hitSlop={12} style={styles.backBtn}>
            <ThemedText style={styles.backArrow}>←</ThemedText>
          </Pressable>
          <ThemedText style={styles.title}>Pedido detalhe</ThemedText>
          <View style={{ width: 44 }} />
        </View>

        <ScrollView contentContainerStyle={styles.scroll} showsVerticalScrollIndicator={false}>
          <ThemedView style={styles.card}>
            <View style={styles.rowBetween}>
              <View style={{ flex: 1 }}>
                <ThemedText style={styles.cardTitle}>Pedido #{orderId}</ThemedText>
                <ThemedText style={styles.secondary}>
                  Status: <ThemedText style={styles.bold}>{String(order.status ?? "Confirmado")}</ThemedText>
                </ThemedText>

                {order.trackingCode ? (
                  <ThemedText style={styles.secondary}>
                    Rastreio: <ThemedText style={styles.bold}>{order.trackingCode}</ThemedText>
                  </ThemedText>
                ) : null}
              </View>

              <Pressable onPress={onCopyId} style={styles.smallBtn}>
                <ThemedText style={styles.smallBtnText}>Copiar ID</ThemedText>
              </Pressable>
            </View>

            <View style={styles.divider} />

            <View style={styles.actionRow}>
              <Pressable onPress={onTrackExternal} style={styles.actionBtn}>
                <ThemedText style={styles.actionBtnText}>Rastrear</ThemedText>
              </Pressable>

              <Pressable onPress={goTracking} style={styles.actionBtnOutline}>
                <ThemedText style={styles.actionBtnOutlineText}>Rastreio (Histórico)</ThemedText>
              </Pressable>
            </View>

            <View style={styles.actionRow}>
              <Pressable onPress={onRepeatPurchase} style={styles.actionBtnOutline}>
                <ThemedText style={styles.actionBtnOutlineText}>Repetir</ThemedText>
              </Pressable>

              <Pressable onPress={onAdvanceStatus} style={styles.actionBtnOutline}>
                <ThemedText style={styles.actionBtnOutlineText}>Avançar status</ThemedText>
              </Pressable>
            </View>

            <View style={styles.actionRow}>
              <Pressable onPress={onShare} style={styles.actionBtnOutline}>
                <ThemedText style={styles.actionBtnOutlineText}>Compartilhar</ThemedText>
              </Pressable>

              <Pressable onPress={goInvoice} style={styles.actionBtnOutline}>
                <ThemedText style={styles.actionBtnOutlineText}>Nota Fiscal</ThemedText>
              </Pressable>
            </View>

            <View style={styles.actionRow}>
              <Pressable onPress={goSupport} style={styles.actionBtnOutline}>
                <ThemedText style={styles.actionBtnOutlineText}>Suporte</ThemedText>
              </Pressable>

              <Pressable onPress={goReturn} style={styles.actionBtnOutline}>
                <ThemedText style={styles.actionBtnOutlineText}>Troca/Reembolso</ThemedText>
              </Pressable>
            </View>

            <View style={styles.actionRow}>
              <Pressable onPress={goReview} style={styles.actionBtnOutline}>
                <ThemedText style={styles.actionBtnOutlineText}>Avaliar</ThemedText>
              </Pressable>

              <Pressable onPress={goNotifications} style={styles.actionBtnOutline}>
                <ThemedText style={styles.actionBtnOutlineText}>Notificações</ThemedText>
              </Pressable>
            </View>
          </ThemedView>

          <ThemedView style={styles.card}>
            <ThemedText style={styles.cardTitle}>Resumo</ThemedText>

            <View style={styles.kv}>
              <ThemedText style={styles.k}>Itens</ThemedText>
              <ThemedText style={styles.v}>{totals.count}</ThemedText>
            </View>

            <View style={styles.kv}>
              <ThemedText style={styles.k}>Subtotal</ThemedText>
              <ThemedText style={styles.v}>{formatCurrency(totals.subtotal)}</ThemedText>
            </View>

            <View style={styles.kv}>
              <ThemedText style={styles.k}>Descontos</ThemedText>
              <ThemedText style={styles.v}>- {formatCurrency(totals.discount)}</ThemedText>
            </View>

            <View style={styles.kv}>
              <ThemedText style={styles.k}>Frete</ThemedText>
              <ThemedText style={styles.v}>{formatCurrency(totals.shipping)}</ThemedText>
            </View>

            <View style={styles.divider} />

            <View style={styles.kv}>
              <ThemedText style={[styles.k, styles.bold]}>Total</ThemedText>
              <ThemedText style={[styles.v, styles.bold]}>{formatCurrency(totals.total)}</ThemedText>
            </View>
          </ThemedView>

          <OrderTimeline steps={timelineSteps} />

          <View style={{ height: 24 }} />
        </ScrollView>
      </ThemedView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safe: { flex: 1, backgroundColor: theme.colors.background },
  container: { flex: 1, paddingHorizontal: Spacing.lg, paddingBottom: Spacing.lg },

  topbar: {
    height: 54,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: Spacing.md,
  },
  backBtn: {
    width: 44,
    height: 44,
    borderRadius: 999,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.divider,
  },
  backArrow: { fontFamily: "Arimo", fontSize: 22, fontWeight: "700", color: theme.colors.text },
  title: { fontFamily: "Arimo", fontSize: 20, fontWeight: "700", color: theme.colors.text },

  scroll: { gap: Spacing.md, paddingBottom: 20 },

  card: {
    backgroundColor: theme.colors.surface,
    borderRadius: Radius.xl,
    borderWidth: 1,
    borderColor: theme.colors.divider,
    padding: Spacing.lg,
    gap: Spacing.md,
  },
  cardTitle: { fontFamily: "Arimo", fontSize: 18, fontWeight: "700", color: theme.colors.text },

  rowBetween: { flexDirection: "row", alignItems: "center", justifyContent: "space-between", gap: Spacing.md },
  divider: { height: 1, backgroundColor: theme.colors.divider, width: "100%", marginVertical: 6 },

  smallBtn: {
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: Radius.lg,
    backgroundColor: theme.colors.surfaceAlt,
    borderWidth: 1,
    borderColor: theme.colors.divider,
  },
  smallBtnText: { fontFamily: "OpenSans", fontSize: 12, fontWeight: "700", color: theme.colors.text },

  actionRow: { flexDirection: "row", gap: Spacing.md },
  actionBtn: {
    flex: 1,
    paddingVertical: 12,
    borderRadius: Radius.lg,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.primary,
  },
  actionBtnText: { fontFamily: "OpenSans", fontSize: 12, fontWeight: "700", color: "#FFFFFF" },
  actionBtnOutline: {
    flex: 1,
    paddingVertical: 12,
    borderRadius: Radius.lg,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.primary,
  },
  actionBtnOutlineText: { fontFamily: "OpenSans", fontSize: 12, fontWeight: "700", color: theme.colors.primary },

  kv: { flexDirection: "row", alignItems: "center", justifyContent: "space-between" },
  k: { fontFamily: "OpenSans", fontSize: 12, color: "rgba(0,0,0,0.65)" },
  v: { fontFamily: "OpenSans", fontSize: 12, color: theme.colors.text },
  bold: { fontWeight: "700", color: theme.colors.text },

  secondary: { fontFamily: "OpenSans", fontSize: 12, color: "rgba(0,0,0,0.65)" },
});



===== PATH: app\orders\[id]\invoice.tsx =====
import React, { useCallback, useMemo, useState } from "react";
import { Alert, Linking, Pressable, ScrollView, StyleSheet, View } from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { router, useFocusEffect, useLocalSearchParams } from "expo-router";

import { ThemedText } from "../../../components/themed-text";
import { ThemedView } from "../../../components/themed-view";
import theme, { Radius, Spacing } from "../../../constants/theme";
import type { Order } from "../../../utils/ordersStore";
import { getOrderById, setInvoiceMock, clearInvoice } from "../../../utils/ordersStore";

function safeString(v: unknown) {
  if (typeof v === "string") return v;
  if (typeof v === "number") return String(v);
  return "";
}

function dateLabel(isoOrAny: string) {
  if (!isoOrAny) return "";
  const d = isoOrAny.includes("T") ? isoOrAny.split("T")[0] : isoOrAny;
  if (d.includes("-")) return d.split("-").reverse().join("/");
  return d;
}

async function copyToClipboard(text: string) {
  try {
    const mod = await import("expo-clipboard");
    if (mod?.setStringAsync) {
      await mod.setStringAsync(text);
      return true;
    }
    return false;
  } catch {
    return false;
  }
}

export default function OrderInvoiceScreen() {
  const params = useLocalSearchParams();
  const orderId = safeString(params?.id);

  const [order, setOrder] = useState<Order | null>(null);

  const load = useCallback(async () => {
    if (!orderId) return;
    const found = await getOrderById(orderId);
    setOrder(found);
  }, [orderId]);

  useFocusEffect(
    useCallback(() => {
      load();
    }, [load])
  );

  const invoice = order?.invoice;
  const isIssued = invoice?.status === "EMITIDA";

  const subtitle = useMemo(() => {
    if (!invoice) return "Aguardando emissão.";
    if (invoice.status === "AGUARDANDO") return "Aguardando emissão.";
    const d = invoice.issuedAt ? dateLabel(invoice.issuedAt) : "";
    return d ? `Emitida em ${d}` : "Nota emitida.";
  }, [invoice]);

  const onEmitMock = async () => {
    if (!orderId) return;
    const updated = await setInvoiceMock(orderId);
    if (!updated) {
      Alert.alert("Nota Fiscal", "Não foi possível gerar a nota (mock).");
      return;
    }
    setOrder(updated);
  };

  const onClear = async () => {
    if (!orderId) return;
    const updated = await clearInvoice(orderId);
    if (!updated) return;
    setOrder(updated);
  };

  const onOpenDanfe = async () => {
    const url = invoice?.danfeUrl;
    if (!url) {
      Alert.alert("DANFE", "DANFE indisponível no momento.");
      return;
    }
    const ok = await Linking.canOpenURL(url);
    if (!ok) {
      Alert.alert("DANFE", "Não foi possível abrir a DANFE neste dispositivo.");
      return;
    }
    Linking.openURL(url);
  };

  const onCopyAccessKey = async () => {
    const key = invoice?.accessKey;
    if (!key) {
      Alert.alert("Chave de acesso", "Chave indisponível no momento.");
      return;
    }
    const ok = await copyToClipboard(key);
    if (ok) Alert.alert("Copiado", "Chave de acesso copiada.");
    else Alert.alert("Copiar", `Copie manualmente: ${key}`);
  };

  return (
    <SafeAreaView edges={["top", "left", "right"]} style={styles.safe}>
      <ThemedView style={styles.container}>
        <View style={styles.topbar}>
          <Pressable onPress={() => router.back()} hitSlop={12} style={styles.backBtn}>
            <ThemedText style={styles.backArrow}>←</ThemedText>
          </Pressable>
          <ThemedText style={styles.title}>Nota Fiscal</ThemedText>
          <Pressable onPress={onClear} hitSlop={10} style={styles.rightBtn}>
            <ThemedText style={styles.rightBtnText}>Limpar</ThemedText>
          </Pressable>
        </View>

        <ScrollView contentContainerStyle={styles.scroll} showsVerticalScrollIndicator={false}>
          <ThemedView style={styles.card}>
            <ThemedText style={styles.cardTitle}>Pedido #{orderId}</ThemedText>
            <ThemedText style={styles.secondary}>{subtitle}</ThemedText>

            <View style={styles.divider} />

            <View style={styles.kv}>
              <ThemedText style={styles.k}>Status</ThemedText>
              <ThemedText style={styles.v}>
                {invoice?.status === "EMITIDA" ? "Emitida" : "Aguardando"}
              </ThemedText>
            </View>

            <View style={styles.kv}>
              <ThemedText style={styles.k}>Número</ThemedText>
              <ThemedText style={styles.v}>{invoice?.number ?? "-"}</ThemedText>
            </View>

            <View style={styles.kv}>
              <ThemedText style={styles.k}>Série</ThemedText>
              <ThemedText style={styles.v}>{invoice?.series ?? "-"}</ThemedText>
            </View>

            <View style={styles.kv}>
              <ThemedText style={styles.k}>Chave</ThemedText>
              <ThemedText style={styles.v}>{invoice?.accessKey ? "Disponível" : "-"}</ThemedText>
            </View>

            <View style={{ height: 10 }} />

            {!isIssued ? (
              <Pressable onPress={onEmitMock} style={styles.primaryBtn}>
                <ThemedText style={styles.primaryBtnText}>Gerar NF (mock)</ThemedText>
              </Pressable>
            ) : (
              <View style={styles.actionRow}>
                <Pressable onPress={onOpenDanfe} style={styles.primaryBtn}>
                  <ThemedText style={styles.primaryBtnText}>Abrir DANFE</ThemedText>
                </Pressable>

                <Pressable onPress={onCopyAccessKey} style={styles.outlineBtn}>
                  <ThemedText style={styles.outlineBtnText}>Copiar chave</ThemedText>
                </Pressable>
              </View>
            )}

            <ThemedText style={styles.note}>
              Integração real: a DANFE será fornecida pelo seu backend consultando a Bling.
              O app não armazena token da Bling.
            </ThemedText>
          </ThemedView>

          <View style={{ height: 24 }} />
        </ScrollView>
      </ThemedView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safe: { flex: 1, backgroundColor: theme.colors.background },
  container: { flex: 1, paddingHorizontal: Spacing.lg, paddingBottom: Spacing.lg },

  topbar: {
    height: 54,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: Spacing.md,
  },
  backBtn: {
    width: 44,
    height: 44,
    borderRadius: 999,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.divider,
  },
  backArrow: { fontFamily: "Arimo", fontSize: 22, fontWeight: "700", color: theme.colors.text },
  title: { fontFamily: "Arimo", fontSize: 20, fontWeight: "700", color: theme.colors.text },
  rightBtn: {
    minWidth: 70,
    height: 44,
    borderRadius: 999,
    paddingHorizontal: 12,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.divider,
  },
  rightBtnText: { fontFamily: "OpenSans", fontSize: 12, fontWeight: "700", color: theme.colors.text },

  scroll: { gap: Spacing.md, paddingBottom: 20 },

  card: {
    backgroundColor: theme.colors.surface,
    borderRadius: Radius.xl,
    borderWidth: 1,
    borderColor: theme.colors.divider,
    padding: Spacing.lg,
    gap: Spacing.md,
  },
  cardTitle: { fontFamily: "Arimo", fontSize: 18, fontWeight: "700", color: theme.colors.text },
  secondary: { fontFamily: "OpenSans", fontSize: 12, color: "rgba(0,0,0,0.65)" },

  divider: { height: 1, backgroundColor: theme.colors.divider, width: "100%", marginVertical: 6 },

  kv: { flexDirection: "row", justifyContent: "space-between", alignItems: "center" },
  k: { fontFamily: "OpenSans", fontSize: 12, color: "rgba(0,0,0,0.65)" },
  v: { fontFamily: "OpenSans", fontSize: 12, fontWeight: "700", color: theme.colors.text },

  actionRow: { flexDirection: "row", gap: 10 },

  primaryBtn: {
    flex: 1,
    paddingVertical: 12,
    borderRadius: Radius.lg,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.primary,
  },
  primaryBtnText: { fontFamily: "OpenSans", fontSize: 16, fontWeight: "700", color: "#FFFFFF" },

  outlineBtn: {
    flex: 1,
    paddingVertical: 12,
    borderRadius: Radius.lg,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.primary,
  },
  outlineBtnText: { fontFamily: "OpenSans", fontSize: 12, fontWeight: "700", color: theme.colors.primary },

  note: { fontFamily: "OpenSans", fontSize: 12, color: "rgba(0,0,0,0.65)", marginTop: 6 },
});



===== PATH: app\orders\[id]\return.tsx =====
import React, { useCallback, useMemo, useState } from "react";
import {
  Alert,
  Pressable,
  ScrollView,
  StyleSheet,
  TextInput,
  View,
} from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { router, useLocalSearchParams, useFocusEffect } from "expo-router";

import { ThemedText } from "../../../components/themed-text";
import { ThemedView } from "../../../components/themed-view";
import theme, { Radius, Spacing } from "../../../constants/theme";
import type { Order, ReturnType } from "../../../utils/ordersStore";
import {
  createReturnRequest,
  getOrderById,
  addReturnAttachment,
} from "../../../utils/ordersStore";

function safeString(v: unknown) {
  if (typeof v === "string") return v;
  if (typeof v === "number") return String(v);
  return "";
}

async function copyToClipboard(text: string) {
  try {
    const mod = await import("expo-clipboard");
    if (mod?.setStringAsync) {
      await mod.setStringAsync(text);
      return true;
    }
    return false;
  } catch {
    return false;
  }
}

const REASONS = [
  "Produto com defeito",
  "Produto diferente do anunciado",
  "Arrependimento",
  "Tamanho incorreto",
  "Outro",
];

export default function OrderReturnScreen() {
  const params = useLocalSearchParams();
  const orderId = safeString(params?.id);

  const [order, setOrder] = useState<Order | null>(null);
  const [type, setType] = useState<ReturnType>("Troca");
  const [reasonQuick, setReasonQuick] = useState<string>(REASONS[0]);
  const [reasonText, setReasonText] = useState<string>("");

  const load = useCallback(async () => {
    if (!orderId) {
      setOrder(null);
      return;
    }
    const found = await getOrderById(orderId);
    setOrder(found);

    if (found?.returnRequest) {
      setType(found.returnRequest.type);
      setReasonQuick("Outro");
      setReasonText(found.returnRequest.reason);
    }
  }, [orderId]);

  useFocusEffect(
    useCallback(() => {
      load();
    }, [load])
  );

  const finalReason = useMemo(() => {
    if (reasonQuick !== "Outro") return reasonQuick;
    return reasonText.trim() || "Outro";
  }, [reasonQuick, reasonText]);

  const submit = async () => {
    if (!orderId) return;

    if (!finalReason.trim()) {
      Alert.alert("Troca / Reembolso", "Informe o motivo.");
      return;
    }

    const updated = await createReturnRequest(orderId, type, finalReason);
    if (!updated) {
      Alert.alert("Erro", "Não foi possível abrir a solicitação.");
      return;
    }

    setOrder(updated);
    Alert.alert(
      "Solicitação criada",
      `Protocolo: ${updated.returnRequest?.protocol}`
    );
  };

  const copyProtocol = async () => {
    const p = order?.returnRequest?.protocol;
    if (!p) return;

    const ok = await copyToClipboard(p);
    if (ok) Alert.alert("Copiado", "Protocolo copiado.");
    else Alert.alert("Copiar", `Copie manualmente: ${p}`);
  };

  /**
   * MOCK DE ANEXO
   * Aqui NÃO usamos image-picker para não quebrar TS/bundler.
   * Apenas simulamos a existência de um anexo.
   * No futuro: trocar por upload real (Bling / S3 / Backend).
   */
  const addMockAttachment = async () => {
    if (!orderId || !order?.returnRequest) {
      Alert.alert("Anexos", "Abra a solicitação antes de anexar.");
      return;
    }

    const fakeUri = `mock://photo-${Date.now()}.jpg`;

    const updated = await addReturnAttachment(orderId, fakeUri);
    if (!updated) {
      Alert.alert("Erro", "Não foi possível anexar.");
      return;
    }

    setOrder(updated);
    Alert.alert("Anexo adicionado", "Foto anexada (mock).");
  };

  const attachmentsCount =
    order?.returnRequest?.attachments?.length ?? 0;

  return (
    <SafeAreaView edges={["top", "left", "right"]} style={styles.safe}>
      <ThemedView style={styles.container}>
        {/* Topbar */}
        <View style={styles.topbar}>
          <Pressable onPress={() => router.back()} hitSlop={12} style={styles.backBtn}>
            <ThemedText style={styles.backArrow}>←</ThemedText>
          </Pressable>
          <ThemedText style={styles.title}>Troca / Reembolso</ThemedText>
          <View style={{ width: 44 }} />
        </View>

        <ScrollView contentContainerStyle={styles.scroll} showsVerticalScrollIndicator={false}>
          <ThemedView style={styles.card}>
            <ThemedText style={styles.cardTitle}>Pedido #{orderId}</ThemedText>

            {order?.returnRequest ? (
              <ThemedView style={styles.infoBox}>
                <ThemedText style={styles.infoTitle}>Solicitação aberta</ThemedText>

                <ThemedText style={styles.secondary}>
                  Tipo: <ThemedText style={styles.bold}>{order.returnRequest.type}</ThemedText>
                </ThemedText>

                <ThemedText style={styles.secondary}>
                  Status: <ThemedText style={styles.bold}>{order.returnRequest.status}</ThemedText>
                </ThemedText>

                <ThemedText style={styles.secondary}>
                  Protocolo: <ThemedText style={styles.bold}>{order.returnRequest.protocol}</ThemedText>
                </ThemedText>

                <ThemedText style={styles.secondary}>
                  Anexos: <ThemedText style={styles.bold}>{attachmentsCount}</ThemedText>
                </ThemedText>

                <View style={styles.actionRow}>
                  <Pressable onPress={copyProtocol} style={styles.outlineBtn}>
                    <ThemedText style={styles.outlineBtnText}>Copiar protocolo</ThemedText>
                  </Pressable>

                  <Pressable onPress={addMockAttachment} style={styles.outlineBtn}>
                    <ThemedText style={styles.outlineBtnText}>Adicionar foto</ThemedText>
                  </Pressable>
                </View>
              </ThemedView>
            ) : (
              <ThemedText style={styles.secondary}>
                Abra a solicitação para habilitar anexos.
              </ThemedText>
            )}

            <View style={styles.divider} />

            <ThemedText style={styles.sectionTitle}>Tipo</ThemedText>

            <View style={styles.row}>
              {(["Troca", "Reembolso"] as ReturnType[]).map((t) => {
                const active = type === t;
                return (
                  <Pressable
                    key={t}
                    onPress={() => setType(t)}
                    style={[styles.pill, active ? styles.pillActive : styles.pillIdle]}
                  >
                    <ThemedText
                      style={[
                        styles.pillText,
                        active ? styles.pillTextActive : styles.pillTextIdle,
                      ]}
                    >
                      {t}
                    </ThemedText>
                  </Pressable>
                );
              })}
            </View>

            <ThemedText style={styles.sectionTitle}>Motivo</ThemedText>

            <View style={styles.rowWrap}>
              {REASONS.map((r) => {
                const active = reasonQuick === r;
                return (
                  <Pressable
                    key={r}
                    onPress={() => setReasonQuick(r)}
                    style={[styles.reasonPill, active ? styles.reasonActive : styles.reasonIdle]}
                  >
                    <ThemedText
                      style={[
                        styles.reasonText,
                        active ? styles.reasonTextActive : styles.reasonTextIdle,
                      ]}
                    >
                      {r}
                    </ThemedText>
                  </Pressable>
                );
              })}
            </View>

            {reasonQuick === "Outro" && (
              <TextInput
                value={reasonText}
                onChangeText={setReasonText}
                placeholder="Descreva o motivo"
                placeholderTextColor="rgba(0,0,0,0.45)"
                style={styles.input}
                multiline
                textAlignVertical="top"
              />
            )}

            <Pressable onPress={submit} style={styles.primaryBtn}>
              <ThemedText style={styles.primaryBtnText}>Abrir solicitação</ThemedText>
            </Pressable>
          </ThemedView>

          <View style={{ height: 24 }} />
        </ScrollView>
      </ThemedView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safe: { flex: 1, backgroundColor: theme.colors.background },
  container: { flex: 1, paddingHorizontal: Spacing.lg, paddingBottom: Spacing.lg },

  topbar: {
    height: 54,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: Spacing.md,
  },

  backBtn: {
    width: 44,
    height: 44,
    borderRadius: 999,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.divider,
  },

  backArrow: { fontFamily: "Arimo", fontSize: 22, fontWeight: "700", color: theme.colors.text },
  title: { fontFamily: "Arimo", fontSize: 20, fontWeight: "700", color: theme.colors.text },

  scroll: { gap: Spacing.md },

  card: {
    backgroundColor: theme.colors.surface,
    borderRadius: Radius.xl,
    borderWidth: 1,
    borderColor: theme.colors.divider,
    padding: Spacing.lg,
    gap: Spacing.md,
  },

  cardTitle: { fontFamily: "Arimo", fontSize: 18, fontWeight: "700", color: theme.colors.text },

  divider: { height: 1, backgroundColor: theme.colors.divider },

  sectionTitle: { fontFamily: "OpenSans", fontSize: 12, fontWeight: "700", color: theme.colors.text },
  secondary: { fontFamily: "OpenSans", fontSize: 12, color: "rgba(0,0,0,0.65)" },
  bold: { fontWeight: "700", color: theme.colors.text },

  row: { flexDirection: "row", gap: 10 },
  rowWrap: { flexDirection: "row", gap: 10, flexWrap: "wrap" },

  pill: { flex: 1, paddingVertical: 12, borderRadius: 999, borderWidth: 1, alignItems: "center" },
  pillIdle: { backgroundColor: theme.colors.surface, borderColor: theme.colors.divider },
  pillActive: { backgroundColor: theme.colors.primary, borderColor: theme.colors.primary },

  pillText: { fontFamily: "OpenSans", fontSize: 12, fontWeight: "700" },
  pillTextIdle: { color: theme.colors.text },
  pillTextActive: { color: "#FFFFFF" },

  reasonPill: { paddingHorizontal: 12, paddingVertical: 10, borderRadius: 999, borderWidth: 1 },
  reasonIdle: { backgroundColor: theme.colors.surface, borderColor: theme.colors.divider },
  reasonActive: { backgroundColor: theme.colors.primary, borderColor: theme.colors.primary },

  reasonText: { fontFamily: "OpenSans", fontSize: 12, fontWeight: "700" },
  reasonTextIdle: { color: theme.colors.text },
  reasonTextActive: { color: "#FFFFFF" },

  input: {
    minHeight: 110,
    borderRadius: Radius.lg,
    borderWidth: 1,
    borderColor: theme.colors.divider,
    backgroundColor: theme.colors.surface,
    paddingHorizontal: 12,
    paddingVertical: 10,
    fontFamily: "OpenSans",
    fontSize: 12,
    color: theme.colors.text,
  },

  primaryBtn: {
    paddingVertical: 12,
    borderRadius: Radius.lg,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.primary,
  },

  primaryBtnText: { fontFamily: "OpenSans", fontSize: 16, fontWeight: "700", color: "#FFFFFF" },

  infoBox: {
    backgroundColor: theme.colors.surfaceAlt,
    borderRadius: Radius.lg,
    borderWidth: 1,
    borderColor: theme.colors.divider,
    padding: 12,
    gap: 6,
  },

  infoTitle: { fontFamily: "OpenSans", fontSize: 12, fontWeight: "700", color: theme.colors.text },

  outlineBtn: {
    flex: 1,
    paddingVertical: 12,
    borderRadius: Radius.lg,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.primary,
  },

  outlineBtnText: { fontFamily: "OpenSans", fontSize: 12, fontWeight: "700", color: theme.colors.primary },

  actionRow: { flexDirection: "row", gap: 10 },
});



===== PATH: app\orders\[id]\review.tsx =====
import React, { useCallback, useMemo, useState } from "react";
import { Alert, Pressable, ScrollView, StyleSheet, TextInput, View } from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { router, useLocalSearchParams, useFocusEffect } from "expo-router";

import { ThemedText } from "../../../components/themed-text";
import { ThemedView } from "../../../components/themed-view";
import theme, { Radius, Spacing } from "../../../constants/theme";
import type { Order } from "../../../utils/ordersStore";
import { getOrderById, setOrderReview } from "../../../utils/ordersStore";

function safeString(v: unknown) {
  if (typeof v === "string") return v;
  if (typeof v === "number") return String(v);
  return "";
}

export default function OrderReviewScreen() {
  const params = useLocalSearchParams();
  const orderId = safeString(params?.id);

  const [order, setOrder] = useState<Order | null>(null);
  const [stars, setStars] = useState<number>(5);
  const [comment, setComment] = useState<string>("");

  const load = useCallback(async () => {
    if (!orderId) {
      setOrder(null);
      return;
    }
    const found = await getOrderById(orderId);
    setOrder(found);

    if (found?.review) {
      setStars(found.review.stars);
      setComment(found.review.comment);
    } else {
      setStars(5);
      setComment("");
    }
  }, [orderId]);

  useFocusEffect(
    useCallback(() => {
      load();
    }, [load])
  );

  const starsLabel = useMemo(() => {
    return `${stars} estrela(s)`;
  }, [stars]);

  const save = async () => {
    if (!orderId) return;

    const updated = await setOrderReview(orderId, stars, comment);
    if (!updated) {
      Alert.alert("Avaliação", "Não foi possível salvar sua avaliação.");
      return;
    }
    Alert.alert("Avaliação", "Avaliação salva com sucesso!");
    router.back();
  };

  return (
    <SafeAreaView edges={["top", "left", "right"]} style={styles.safe}>
      <ThemedView style={styles.container}>
        <View style={styles.topbar}>
          <Pressable onPress={() => router.back()} hitSlop={12} style={styles.backBtn}>
            <ThemedText style={styles.backArrow}>←</ThemedText>
          </Pressable>

          <ThemedText style={styles.title}>Avaliar compra</ThemedText>

          <View style={{ width: 44 }} />
        </View>

        <ScrollView contentContainerStyle={styles.scroll} showsVerticalScrollIndicator={false}>
          <ThemedView style={styles.card}>
            <ThemedText style={styles.cardTitle}>Pedido #{orderId}</ThemedText>
            <ThemedText style={styles.secondary}>
              {order?.review ? "Você já avaliou este pedido. Pode atualizar a qualquer momento." : "Conte como foi sua experiência."}
            </ThemedText>

            <View style={styles.divider} />

            <ThemedText style={styles.sectionTitle}>Sua nota</ThemedText>

            <View style={styles.starsRow}>
              {[1, 2, 3, 4, 5].map((n) => {
                const active = n <= stars;
                return (
                  <Pressable
                    key={n}
                    onPress={() => setStars(n)}
                    style={[styles.starPill, active ? styles.starActive : styles.starIdle]}
                  >
                    <ThemedText style={[styles.starText, active ? styles.starTextActive : styles.starTextIdle]}>
                      ★
                    </ThemedText>
                  </Pressable>
                );
              })}
              <ThemedText style={styles.secondary}>{starsLabel}</ThemedText>
            </View>

            <ThemedText style={styles.sectionTitle}>Comentário</ThemedText>

            <TextInput
              value={comment}
              onChangeText={setComment}
              placeholder="Escreva um comentário (opcional)"
              placeholderTextColor={"rgba(0,0,0,0.45)"}
              style={styles.input}
              multiline
              textAlignVertical="top"
            />

            <Pressable onPress={save} style={styles.primaryBtn}>
              <ThemedText style={styles.primaryBtnText}>Salvar avaliação</ThemedText>
            </Pressable>
          </ThemedView>

          <View style={{ height: 24 }} />
        </ScrollView>
      </ThemedView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safe: { flex: 1, backgroundColor: theme.colors.background },
  container: { flex: 1, paddingHorizontal: Spacing.lg, paddingBottom: Spacing.lg },

  topbar: {
    height: 54,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: Spacing.md,
  },
  backBtn: {
    width: 44,
    height: 44,
    borderRadius: 999,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.divider,
  },
  backArrow: { fontFamily: "Arimo", fontSize: 22, fontWeight: "700", color: theme.colors.text },
  title: { fontFamily: "Arimo", fontSize: 20, fontWeight: "700", color: theme.colors.text },

  scroll: { gap: Spacing.md, paddingBottom: 20 },

  card: {
    backgroundColor: theme.colors.surface,
    borderRadius: Radius.xl,
    borderWidth: 1,
    borderColor: theme.colors.divider,
    padding: Spacing.lg,
    gap: Spacing.md,
  },
  cardTitle: { fontFamily: "Arimo", fontSize: 18, fontWeight: "700", color: theme.colors.text },

  divider: { height: 1, backgroundColor: theme.colors.divider, width: "100%", marginVertical: 6 },

  sectionTitle: { fontFamily: "OpenSans", fontSize: 12, fontWeight: "700", color: theme.colors.text },
  secondary: { fontFamily: "OpenSans", fontSize: 12, color: "rgba(0,0,0,0.65)" },

  starsRow: { flexDirection: "row", alignItems: "center", gap: 10, flexWrap: "wrap" },
  starPill: {
    width: 38,
    height: 38,
    borderRadius: 999,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
  },
  starIdle: { backgroundColor: theme.colors.surface, borderColor: theme.colors.divider },
  starActive: { backgroundColor: theme.colors.primary, borderColor: theme.colors.primary },
  starText: { fontFamily: "OpenSans", fontSize: 16, fontWeight: "700" },
  starTextIdle: { color: theme.colors.text },
  starTextActive: { color: "#FFFFFF" },

  input: {
    minHeight: 110,
    borderRadius: Radius.lg,
    borderWidth: 1,
    borderColor: theme.colors.divider,
    backgroundColor: theme.colors.surface,
    paddingHorizontal: 12,
    paddingVertical: 10,
    fontFamily: "OpenSans",
    fontSize: 12,
    color: theme.colors.text,
  },

  primaryBtn: {
    paddingVertical: 12,
    borderRadius: Radius.lg,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.primary,
    marginTop: 6,
  },
  primaryBtnText: { fontFamily: "OpenSans", fontSize: 16, fontWeight: "700", color: "#FFFFFF" },
});



===== PATH: app\orders\[id]\support.tsx =====
import React, { useCallback, useMemo, useState } from "react";
import { Alert, Pressable, ScrollView, StyleSheet, View, Linking } from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { router, useLocalSearchParams, useFocusEffect } from "expo-router";

import { ThemedText } from "../../../components/themed-text";
import { ThemedView } from "../../../components/themed-view";
import theme, { Radius, Spacing } from "../../../constants/theme";
import type { Order } from "../../../utils/ordersStore";
import { getOrderById } from "../../../utils/ordersStore";

function safeString(v: unknown) {
  if (typeof v === "string") return v;
  if (typeof v === "number") return String(v);
  return "";
}

async function copyToClipboard(text: string) {
  try {
    const mod = await import("expo-clipboard");
    if (mod?.setStringAsync) {
      await mod.setStringAsync(text);
      return true;
    }
    return false;
  } catch {
    return false;
  }
}

function faqByStatus(status?: string) {
  const s = (status ?? "Confirmado").toString();
  if (s === "Confirmado") {
    return [
      { q: "Posso alterar o endereço?", a: "Sim. Enquanto não enviarmos o pedido, você pode solicitar alteração pelo suporte." },
      { q: "Quando meu pedido será pago?", a: "Pagamentos podem levar alguns minutos. Em Pix, costuma ser imediato." },
      { q: "Posso cancelar?", a: "Em fase confirmada, normalmente é possível. Fale com o suporte para validar." },
    ];
  }
  if (s === "Pago") {
    return [
      { q: "Quando será enviado?", a: "Após separação e embalagem, o pedido é despachado. Você verá o status ‘Enviado’." },
      { q: "Posso trocar itens?", a: "Após pagamento, trocas dependem do item e do estágio logístico. Fale com o suporte." },
    ];
  }
  if (s === "Enviado") {
    return [
      { q: "Como rastreio?", a: "Use o botão de rastreio. Quando disponível, o código aparece no rastreamento." },
      { q: "Meu pedido atrasou", a: "Atrasos podem ocorrer por rota/transportadora. Informe o ID ao suporte para prioridade." },
    ];
  }
  return [
    { q: "Meu pedido chegou com problema", a: "Nos chame no suporte com fotos e ID do pedido. Vamos resolver rápido." },
    { q: "Troca ou devolução", a: "Você pode solicitar conforme política. O suporte orienta todo o passo a passo." },
  ];
}

export default function OrderSupportScreen() {
  const params = useLocalSearchParams();
  const orderId = safeString(params?.id);

  const [order, setOrder] = useState<Order | null>(null);

  const load = useCallback(async () => {
    if (!orderId) {
      setOrder(null);
      return;
    }
    const found = await getOrderById(orderId);
    setOrder(found);
  }, [orderId]);

  useFocusEffect(
    useCallback(() => {
      load();
    }, [load])
  );

  const faq = useMemo(() => faqByStatus(order?.status), [order?.status]);

  const onCopyId = async () => {
    if (!orderId) return;
    const ok = await copyToClipboard(orderId);
    if (ok) Alert.alert("Copiado", "ID do pedido copiado para a área de transferência.");
    else Alert.alert("Copiar ID", `Copie manualmente: ${orderId}`);
  };

  const onWhatsApp = async () => {
    // Mock: substitua futuramente pelo número real + mensagem padrão
    const message = `Olá! Preciso de suporte para o pedido #${orderId}.`;
    const url = `https://wa.me/5500000000000?text=${encodeURIComponent(message)}`;
    const supported = await Linking.canOpenURL(url);
    if (!supported) {
      Alert.alert("WhatsApp", "Não foi possível abrir o WhatsApp neste dispositivo.");
      return;
    }
    Linking.openURL(url);
  };

  const onEmail = async () => {
    const subject = `Suporte - Pedido #${orderId}`;
    const body = `Olá, preciso de ajuda com o pedido #${orderId}.\n\nStatus atual: ${order?.status ?? "Confirmado"}\n`;
    const url = `mailto:contato@plugaishop.com.br?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
    const supported = await Linking.canOpenURL(url);
    if (!supported) {
      Alert.alert("E-mail", "Não foi possível abrir o app de e-mail neste dispositivo.");
      return;
    }
    Linking.openURL(url);
  };

  return (
    <SafeAreaView edges={["top", "left", "right"]} style={styles.safe}>
      <ThemedView style={styles.container}>
        <View style={styles.topbar}>
          <Pressable onPress={() => router.back()} hitSlop={12} style={styles.backBtn}>
            <ThemedText style={styles.backArrow}>←</ThemedText>
          </Pressable>

          <ThemedText style={styles.title}>Suporte</ThemedText>

          <View style={{ width: 44 }} />
        </View>

        <ScrollView contentContainerStyle={styles.scroll} showsVerticalScrollIndicator={false}>
          <ThemedView style={styles.card}>
            <View style={styles.rowBetween}>
              <View style={{ flex: 1 }}>
                <ThemedText style={styles.cardTitle}>Pedido #{orderId}</ThemedText>
                <ThemedText style={styles.secondary}>
                  Status: <ThemedText style={styles.bold}>{String(order?.status ?? "Confirmado")}</ThemedText>
                </ThemedText>
              </View>

              <Pressable onPress={onCopyId} style={styles.smallBtn}>
                <ThemedText style={styles.smallBtnText}>Copiar ID</ThemedText>
              </Pressable>
            </View>

            <View style={styles.divider} />

            <View style={styles.actionRow}>
              <Pressable onPress={onWhatsApp} style={styles.actionBtn}>
                <ThemedText style={styles.actionBtnText}>WhatsApp</ThemedText>
              </Pressable>

              <Pressable onPress={onEmail} style={styles.actionBtnOutline}>
                <ThemedText style={styles.actionBtnOutlineText}>E-mail</ThemedText>
              </Pressable>
            </View>
          </ThemedView>

          <ThemedView style={styles.card}>
            <ThemedText style={styles.cardTitle}>Perguntas rápidas</ThemedText>

            <View style={{ gap: 10 }}>
              {faq.map((item, idx) => (
                <ThemedView key={idx} style={styles.faqBox}>
                  <ThemedText style={styles.faqQ}>{item.q}</ThemedText>
                  <ThemedText style={styles.faqA}>{item.a}</ThemedText>
                </ThemedView>
              ))}
            </View>
          </ThemedView>

          <View style={{ height: 24 }} />
        </ScrollView>
      </ThemedView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safe: { flex: 1, backgroundColor: theme.colors.background },
  container: { flex: 1, paddingHorizontal: Spacing.lg, paddingBottom: Spacing.lg },

  topbar: {
    height: 54,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: Spacing.md,
  },
  backBtn: {
    width: 44,
    height: 44,
    borderRadius: 999,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.divider,
  },
  backArrow: { fontFamily: "Arimo", fontSize: 22, fontWeight: "700", color: theme.colors.text },
  title: { fontFamily: "Arimo", fontSize: 20, fontWeight: "700", color: theme.colors.text },

  scroll: { gap: Spacing.md, paddingBottom: 20 },

  card: {
    backgroundColor: theme.colors.surface,
    borderRadius: Radius.xl,
    borderWidth: 1,
    borderColor: theme.colors.divider,
    padding: Spacing.lg,
    gap: Spacing.md,
  },
  cardTitle: { fontFamily: "Arimo", fontSize: 18, fontWeight: "700", color: theme.colors.text },

  rowBetween: { flexDirection: "row", alignItems: "center", justifyContent: "space-between", gap: Spacing.md },
  divider: { height: 1, backgroundColor: theme.colors.divider, width: "100%", marginVertical: 6 },

  smallBtn: {
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: Radius.lg,
    backgroundColor: theme.colors.surfaceAlt,
    borderWidth: 1,
    borderColor: theme.colors.divider,
  },
  smallBtnText: { fontFamily: "OpenSans", fontSize: 12, fontWeight: "700", color: theme.colors.text },

  actionRow: { flexDirection: "row", gap: Spacing.md },
  actionBtn: {
    flex: 1,
    paddingVertical: 12,
    borderRadius: Radius.lg,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.primary,
  },
  actionBtnText: { fontFamily: "OpenSans", fontSize: 12, fontWeight: "700", color: "#FFFFFF" },
  actionBtnOutline: {
    flex: 1,
    paddingVertical: 12,
    borderRadius: Radius.lg,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.primary,
  },
  actionBtnOutlineText: { fontFamily: "OpenSans", fontSize: 12, fontWeight: "700", color: theme.colors.primary },

  secondary: { fontFamily: "OpenSans", fontSize: 12, color: "rgba(0,0,0,0.65)" },
  bold: { fontWeight: "700", color: theme.colors.text },

  faqBox: {
    backgroundColor: theme.colors.surfaceAlt,
    borderRadius: Radius.lg,
    borderWidth: 1,
    borderColor: theme.colors.divider,
    padding: 12,
    gap: 6,
  },
  faqQ: { fontFamily: "OpenSans", fontSize: 12, fontWeight: "700", color: theme.colors.text },
  faqA: { fontFamily: "OpenSans", fontSize: 12, color: "rgba(0,0,0,0.70)", lineHeight: 16 },
});



===== PATH: app\orders\[id]\tracking.tsx =====
import React, { useCallback, useMemo, useState } from "react";
import { Alert, Pressable, ScrollView, StyleSheet, TextInput, View } from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { router, useFocusEffect, useLocalSearchParams } from "expo-router";

import { ThemedText } from "../../../components/themed-text";
import { ThemedView } from "../../../components/themed-view";
import theme, { Radius, Spacing } from "../../../constants/theme";
import type { LogisticsEvent, LogisticsEventType, Order } from "../../../utils/ordersStore";
import { addLogisticsEvent, clearLogisticsEvents, getOrderById, setTrackingCode } from "../../../utils/ordersStore";

function safeString(v: unknown) {
  if (typeof v === "string") return v;
  if (typeof v === "number") return String(v);
  return "";
}

function dateLabel(iso: string) {
  if (!iso) return "";
  const d = iso.includes("T") ? iso.split("T")[0] : iso;
  if (d.includes("-")) return d.split("-").reverse().join("/");
  return d;
}

function timeLabel(iso: string) {
  if (!iso || !iso.includes("T")) return "";
  const t = iso.split("T")[1]?.slice(0, 5);
  return t ? ` ${t}` : "";
}

function typeLabel(t: LogisticsEventType) {
  if (t === "POSTED") return "Postado";
  if (t === "IN_TRANSIT") return "Em trânsito";
  if (t === "OUT_FOR_DELIVERY") return "Saiu para entrega";
  if (t === "DELIVERED") return "Entregue";
  return "Ocorrência";
}

export default function OrderTrackingScreen() {
  const params = useLocalSearchParams();
  const orderId = safeString(params?.id);

  const [order, setOrder] = useState<Order | null>(null);
  const [code, setCode] = useState("");

  const load = useCallback(async () => {
    if (!orderId) return;
    const found = await getOrderById(orderId);
    setOrder(found);
    setCode(String(found?.trackingCode ?? ""));
  }, [orderId]);

  useFocusEffect(
    useCallback(() => {
      load();
    }, [load])
  );

  const events: LogisticsEvent[] = useMemo(() => {
    const list = Array.isArray(order?.logisticsEvents) ? order!.logisticsEvents! : [];
    // já vem ordenado desc por inserção; garante fallback
    return list;
  }, [order]);

  const saveCode = async () => {
    if (!orderId) return;
    const updated = await setTrackingCode(orderId, code);
    if (!updated) {
      Alert.alert("Rastreio", "Não foi possível salvar o código de rastreio.");
      return;
    }
    setOrder(updated);
    Alert.alert("Rastreio", "Código salvo.");
  };

  const addMock = async (type: LogisticsEventType) => {
    if (!orderId) return;

    const titleMap: Record<LogisticsEventType, string> = {
      POSTED: "Objeto postado",
      IN_TRANSIT: "Objeto em trânsito",
      OUT_FOR_DELIVERY: "Saiu para entrega",
      DELIVERED: "Entrega realizada",
      EXCEPTION: "Ocorrência no transporte",
    };

    const updated = await addLogisticsEvent(orderId, {
      type,
      title: titleMap[type],
      location: "Goiânia - GO",
      description: "Evento mock para validação visual no app.",
    });

    if (!updated) {
      Alert.alert("Logística", "Não foi possível adicionar evento.");
      return;
    }
    setOrder(updated);
  };

  const clearAll = async () => {
    if (!orderId) return;
    const updated = await clearLogisticsEvents(orderId);
    if (!updated) return;
    setOrder(updated);
  };

  return (
    <SafeAreaView edges={["top", "left", "right"]} style={styles.safe}>
      <ThemedView style={styles.container}>
        <View style={styles.topbar}>
          <Pressable onPress={() => router.back()} hitSlop={12} style={styles.backBtn}>
            <ThemedText style={styles.backArrow}>←</ThemedText>
          </Pressable>
          <ThemedText style={styles.title}>Rastreio</ThemedText>
          <Pressable onPress={clearAll} hitSlop={10} style={styles.rightBtn}>
            <ThemedText style={styles.rightBtnText}>Limpar</ThemedText>
          </Pressable>
        </View>

        <ScrollView contentContainerStyle={styles.scroll} showsVerticalScrollIndicator={false}>
          <ThemedView style={styles.card}>
            <ThemedText style={styles.cardTitle}>Pedido #{orderId}</ThemedText>

            <ThemedText style={styles.sectionTitle}>Código de rastreio</ThemedText>
            <TextInput
              value={code}
              onChangeText={setCode}
              placeholder="Ex.: BR1234567890"
              placeholderTextColor="rgba(0,0,0,0.45)"
              style={styles.input}
              autoCapitalize="characters"
              autoCorrect={false}
            />

            <Pressable onPress={saveCode} style={styles.primaryBtn}>
              <ThemedText style={styles.primaryBtnText}>Salvar código</ThemedText>
            </Pressable>

            <View style={styles.divider} />

            <ThemedText style={styles.sectionTitle}>Eventos (mock)</ThemedText>
            <View style={styles.rowWrap}>
              <Pressable onPress={() => addMock("POSTED")} style={styles.pill}><ThemedText style={styles.pillText}>Postado</ThemedText></Pressable>
              <Pressable onPress={() => addMock("IN_TRANSIT")} style={styles.pill}><ThemedText style={styles.pillText}>Trânsito</ThemedText></Pressable>
              <Pressable onPress={() => addMock("OUT_FOR_DELIVERY")} style={styles.pill}><ThemedText style={styles.pillText}>Saiu</ThemedText></Pressable>
              <Pressable onPress={() => addMock("DELIVERED")} style={styles.pill}><ThemedText style={styles.pillText}>Entregue</ThemedText></Pressable>
              <Pressable onPress={() => addMock("EXCEPTION")} style={styles.pill}><ThemedText style={styles.pillText}>Ocorrência</ThemedText></Pressable>
            </View>
          </ThemedView>

          <ThemedView style={styles.card}>
            <ThemedText style={styles.cardTitle}>Linha do tempo</ThemedText>

            {events.length === 0 ? (
              <ThemedText style={styles.secondary}>Nenhum evento ainda. Use os botões mock acima para testar.</ThemedText>
            ) : (
              <View style={{ gap: 12 }}>
                {events.map((e) => (
                  <View key={e.id} style={styles.eventRow}>
                    <View style={styles.dot} />
                    <View style={{ flex: 1 }}>
                      <ThemedText style={styles.eventTitle}>
                        {typeLabel(e.type)} — {e.title}
                      </ThemedText>
                      <ThemedText style={styles.secondary}>
                        {dateLabel(e.at)}
                        {timeLabel(e.at)}
                        {e.location ? ` • ${e.location}` : ""}
                      </ThemedText>
                      {e.description ? <ThemedText style={styles.secondary}>{e.description}</ThemedText> : null}
                    </View>
                  </View>
                ))}
              </View>
            )}
          </ThemedView>

          <View style={{ height: 24 }} />
        </ScrollView>
      </ThemedView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safe: { flex: 1, backgroundColor: theme.colors.background },
  container: { flex: 1, paddingHorizontal: Spacing.lg, paddingBottom: Spacing.lg },

  topbar: {
    height: 54,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: Spacing.md,
  },
  backBtn: {
    width: 44,
    height: 44,
    borderRadius: 999,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.divider,
  },
  backArrow: { fontFamily: "Arimo", fontSize: 22, fontWeight: "700", color: theme.colors.text },
  title: { fontFamily: "Arimo", fontSize: 20, fontWeight: "700", color: theme.colors.text },
  rightBtn: {
    minWidth: 70,
    height: 44,
    borderRadius: 999,
    paddingHorizontal: 12,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.divider,
  },
  rightBtnText: { fontFamily: "OpenSans", fontSize: 12, fontWeight: "700", color: theme.colors.text },

  scroll: { gap: Spacing.md, paddingBottom: 20 },

  card: {
    backgroundColor: theme.colors.surface,
    borderRadius: Radius.xl,
    borderWidth: 1,
    borderColor: theme.colors.divider,
    padding: Spacing.lg,
    gap: Spacing.md,
  },
  cardTitle: { fontFamily: "Arimo", fontSize: 18, fontWeight: "700", color: theme.colors.text },
  sectionTitle: { fontFamily: "OpenSans", fontSize: 12, fontWeight: "700", color: theme.colors.text },
  secondary: { fontFamily: "OpenSans", fontSize: 12, color: "rgba(0,0,0,0.65)" },

  input: {
    height: 46,
    borderRadius: Radius.xl,
    borderWidth: 1,
    borderColor: theme.colors.divider,
    backgroundColor: theme.colors.surface,
    paddingHorizontal: 14,
    fontFamily: "OpenSans",
    fontSize: 12,
    color: theme.colors.text,
  },
  primaryBtn: {
    paddingVertical: 12,
    borderRadius: Radius.lg,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.primary,
  },
  primaryBtnText: { fontFamily: "OpenSans", fontSize: 16, fontWeight: "700", color: "#FFFFFF" },

  divider: { height: 1, backgroundColor: theme.colors.divider, width: "100%", marginVertical: 4 },

  rowWrap: { flexDirection: "row", flexWrap: "wrap", gap: 10 },
  pill: {
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: theme.colors.divider,
    backgroundColor: theme.colors.surface,
  },
  pillText: { fontFamily: "OpenSans", fontSize: 12, fontWeight: "700", color: theme.colors.text },

  eventRow: { flexDirection: "row", gap: 12, alignItems: "flex-start" },
  dot: { width: 10, height: 10, borderRadius: 99, marginTop: 5, backgroundColor: theme.colors.primary },
  eventTitle: { fontFamily: "OpenSans", fontSize: 12, fontWeight: "700", color: theme.colors.text },
});



===== PATH: app\orders\index.tsx =====
import React, { useCallback, useMemo, useState } from "react";
import {
  Pressable,
  RefreshControl,
  ScrollView,
  StyleSheet,
  TextInput,
  View,
} from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { router, useFocusEffect } from "expo-router";

import { ThemedText } from "../../components/themed-text";
import { ThemedView } from "../../components/themed-view";
import theme, { Radius, Spacing } from "../../constants/theme";
import { formatCurrency } from "../../utils/formatCurrency";
import type { Order, OrderStatus } from "../../utils/ordersStore";
import { listOrders, getUnreadNotificationsCount } from "../../utils/ordersStore";

function dateLabel(isoOrAny: string) {
  if (!isoOrAny) return "";
  const d = isoOrAny.includes("T") ? isoOrAny.split("T")[0] : isoOrAny;
  if (d.includes("-")) return d.split("-").reverse().join("/");
  return d;
}

const FILTERS: Array<{ label: string; value: "ALL" | OrderStatus }> = [
  { label: "Todos", value: "ALL" },
  { label: "Confirmado", value: "Confirmado" },
  { label: "Pago", value: "Pago" },
  { label: "Enviado", value: "Enviado" },
  { label: "Entregue", value: "Entregue" },
];

export default function OrdersIndexScreen() {
  const [orders, setOrders] = useState<Order[]>([]);
  const [refreshing, setRefreshing] = useState(false);
  const [query, setQuery] = useState("");
  const [filter, setFilter] = useState<"ALL" | OrderStatus>("ALL");
  const [unread, setUnread] = useState(0);

  const load = useCallback(async () => {
    const data = await listOrders();
    setOrders(data ?? []);

    const c = await getUnreadNotificationsCount();
    setUnread(c);
  }, []);

  useFocusEffect(
    useCallback(() => {
      load();
    }, [load])
  );

  const onRefresh = useCallback(async () => {
    setRefreshing(true);
    await load();
    setRefreshing(false);
  }, [load]);

  const filtered = useMemo(() => {
    const q = query.trim().toLowerCase();

    return (orders ?? [])
      .filter((o) => (filter === "ALL" ? true : o.status === filter))
      .filter((o) => {
        if (!q) return true;
        return String(o.id).toLowerCase().includes(q);
      });
  }, [orders, query, filter]);

  return (
    <SafeAreaView edges={["top", "left", "right"]} style={styles.safe}>
      <ThemedView style={styles.container}>
        <View style={styles.topbar}>
          <Pressable onPress={() => router.back()} hitSlop={12} style={styles.backBtn}>
            <ThemedText style={styles.backArrow}>←</ThemedText>
          </Pressable>

          <ThemedText style={styles.title}>Pedidos</ThemedText>

          <Pressable
            onPress={() => router.push("/orders/notifications" as any)}
            hitSlop={10}
            style={styles.notifBtn}
          >
            <ThemedText style={styles.notifBtnText}>Notifs</ThemedText>
            {unread > 0 ? (
              <View style={styles.badge}>
                <ThemedText style={styles.badgeText}>
                  {unread > 99 ? "99+" : String(unread)}
                </ThemedText>
              </View>
            ) : null}
          </Pressable>
        </View>

        {/* Busca */}
        <View style={styles.searchWrap}>
          <TextInput
            value={query}
            onChangeText={setQuery}
            placeholder="Buscar por ID do pedido"
            placeholderTextColor={"rgba(0,0,0,0.45)"}
            style={styles.searchInput}
            autoCapitalize="none"
            autoCorrect={false}
          />
        </View>

        {/* Filtros */}
        <ScrollView
          horizontal
          showsHorizontalScrollIndicator={false}
          contentContainerStyle={styles.filters}
        >
          {FILTERS.map((f) => {
            const active = filter === f.value;
            return (
              <Pressable
                key={String(f.value)}
                onPress={() => setFilter(f.value)}
                style={[styles.pill, active ? styles.pillActive : styles.pillIdle]}
              >
                <ThemedText
                  style={[
                    styles.pillText,
                    active ? styles.pillTextActive : styles.pillTextIdle,
                  ]}
                >
                  {f.label}
                </ThemedText>
              </Pressable>
            );
          })}
        </ScrollView>

        <ScrollView
          contentContainerStyle={styles.scroll}
          showsVerticalScrollIndicator={false}
          refreshControl={<RefreshControl refreshing={refreshing} onRefresh={onRefresh} />}
        >
          {filtered.length === 0 ? (
            <ThemedView style={styles.card}>
              <ThemedText style={styles.cardTitle}>Nada por aqui</ThemedText>
              <ThemedText style={styles.secondary}>
                Tente outro filtro ou busque pelo ID do pedido.
              </ThemedText>
            </ThemedView>
          ) : null}

          {filtered.map((o) => {
            const subtotal = (o.items ?? []).reduce(
              (acc, it) => acc + Number(it.price ?? 0) * Number(it.qty ?? 0),
              0
            );
            const total = Math.max(
              0,
              subtotal - Number(o.discount ?? 0) + Number(o.shipping ?? 0)
            );
            const itemCount = (o.items ?? []).reduce((a, b) => a + Number(b.qty ?? 0), 0);

            return (
              <Pressable
                key={String(o.id)}
                onPress={() => router.push(`/orders/${o.id}` as any)}
                style={({ pressed }) => [styles.card, pressed ? { opacity: 0.92 } : null]}
              >
                <View style={styles.rowBetween}>
                  <ThemedText style={styles.cardTitle}>Pedido #{String(o.id)}</ThemedText>
                  <ThemedText style={styles.status}>{String(o.status ?? "Confirmado")}</ThemedText>
                </View>

                <ThemedText style={styles.secondary}>Data: {dateLabel(String(o.createdAt ?? ""))}</ThemedText>

                <View style={styles.divider} />

                <View style={styles.rowBetween}>
                  <ThemedText style={styles.secondary}>
                    Itens: <ThemedText style={styles.bold}>{itemCount}</ThemedText>
                  </ThemedText>

                  <ThemedText style={styles.total}>{formatCurrency(total)}</ThemedText>
                </View>
              </Pressable>
            );
          })}

          <View style={{ height: 18 }} />
        </ScrollView>
      </ThemedView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safe: { flex: 1, backgroundColor: theme.colors.background },
  container: { flex: 1, paddingHorizontal: Spacing.lg, paddingBottom: Spacing.lg },

  topbar: {
    height: 54,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: Spacing.md,
  },
  backBtn: {
    width: 44,
    height: 44,
    borderRadius: 999,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.divider,
  },
  backArrow: { fontFamily: "Arimo", fontSize: 22, fontWeight: "700", color: theme.colors.text },
  title: { fontFamily: "Arimo", fontSize: 20, fontWeight: "700", color: theme.colors.text },

  notifBtn: {
    width: 70,
    height: 44,
    borderRadius: 999,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.divider,
  },
  notifBtnText: { fontFamily: "OpenSans", fontSize: 12, fontWeight: "700", color: theme.colors.text },
  badge: {
    position: "absolute",
    top: -6,
    right: -6,
    minWidth: 22,
    height: 22,
    borderRadius: 999,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.primary,
    paddingHorizontal: 6,
  },
  badgeText: { fontFamily: "OpenSans", fontSize: 10, fontWeight: "700", color: "#FFFFFF" },

  searchWrap: { marginBottom: Spacing.md },
  searchInput: {
    height: 46,
    borderRadius: Radius.xl,
    borderWidth: 1,
    borderColor: theme.colors.divider,
    backgroundColor: theme.colors.surface,
    paddingHorizontal: 14,
    fontFamily: "OpenSans",
    fontSize: 12,
    color: theme.colors.text,
  },

  filters: { gap: 10, paddingBottom: Spacing.md },
  pill: { paddingHorizontal: 12, paddingVertical: 10, borderRadius: 999, borderWidth: 1 },
  pillIdle: { backgroundColor: theme.colors.surface, borderColor: theme.colors.divider },
  pillActive: { backgroundColor: theme.colors.primary, borderColor: theme.colors.primary },
  pillText: { fontFamily: "OpenSans", fontSize: 12, fontWeight: "700" },
  pillTextIdle: { color: theme.colors.text },
  pillTextActive: { color: "#FFFFFF" },

  scroll: { gap: Spacing.md, paddingBottom: 20 },

  card: {
    backgroundColor: theme.colors.surface,
    borderRadius: Radius.xl,
    borderWidth: 1,
    borderColor: theme.colors.divider,
    padding: Spacing.lg,
    gap: Spacing.sm,
  },
  cardTitle: { fontFamily: "Arimo", fontSize: 18, fontWeight: "700", color: theme.colors.text },

  rowBetween: { flexDirection: "row", alignItems: "center", justifyContent: "space-between", gap: Spacing.md },
  divider: { height: 1, backgroundColor: theme.colors.divider, width: "100%", marginVertical: 8 },

  status: { fontFamily: "OpenSans", fontSize: 12, fontWeight: "700", color: theme.colors.primary },
  secondary: { fontFamily: "OpenSans", fontSize: 12, color: "rgba(0,0,0,0.65)" },
  bold: { fontWeight: "700", color: theme.colors.text },
  total: { fontFamily: "OpenSans", fontSize: 12, fontWeight: "700", color: theme.colors.text },
});



===== PATH: app\orders\notifications.tsx =====
import React, { useCallback, useState } from "react";
import { Pressable, RefreshControl, ScrollView, StyleSheet, View } from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { router, useFocusEffect } from "expo-router";

import { ThemedText } from "../../components/themed-text";
import { ThemedView } from "../../components/themed-view";
import theme, { Radius, Spacing } from "../../constants/theme";
import type { InAppNotification } from "../../utils/ordersStore";
import { listNotifications, markAllNotificationsRead, markNotificationRead } from "../../utils/ordersStore";

function dateLabel(isoOrAny: string) {
  if (!isoOrAny) return "";
  const d = isoOrAny.includes("T") ? isoOrAny.split("T")[0] : isoOrAny;
  if (d.includes("-")) return d.split("-").reverse().join("/");
  return d;
}

export default function OrdersNotificationsScreen() {
  const [items, setItems] = useState<InAppNotification[]>([]);
  const [refreshing, setRefreshing] = useState(false);

  const load = useCallback(async () => {
    const data = await listNotifications();
    setItems(data ?? []);
  }, []);

  useFocusEffect(
    useCallback(() => {
      load();
    }, [load])
  );

  const onRefresh = useCallback(async () => {
    setRefreshing(true);
    await load();
    setRefreshing(false);
  }, [load]);

  const markAll = async () => {
    await markAllNotificationsRead();
    await load();
  };

  const open = async (n: InAppNotification) => {
    await markNotificationRead(n.id);
    if (n.orderId) {
      router.push(`/orders/${n.orderId}` as any);
      return;
    }
    await load();
  };

  const unreadCount = items.filter((x) => !x.read).length;

  return (
    <SafeAreaView edges={["top", "left", "right"]} style={styles.safe}>
      <ThemedView style={styles.container}>
        <View style={styles.topbar}>
          <Pressable onPress={() => router.back()} hitSlop={12} style={styles.backBtn}>
            <ThemedText style={styles.backArrow}>←</ThemedText>
          </Pressable>

          <ThemedText style={styles.title}>Notificações</ThemedText>

          <Pressable onPress={markAll} hitSlop={10} style={styles.rightBtn}>
            <ThemedText style={styles.rightBtnText}>Ler tudo</ThemedText>
          </Pressable>
        </View>

        <ThemedText style={styles.secondary}>
          Não lidas: <ThemedText style={styles.bold}>{unreadCount}</ThemedText>
        </ThemedText>

        <ScrollView
          contentContainerStyle={styles.scroll}
          showsVerticalScrollIndicator={false}
          refreshControl={<RefreshControl refreshing={refreshing} onRefresh={onRefresh} />}
        >
          {items.length === 0 ? (
            <ThemedView style={styles.card}>
              <ThemedText style={styles.cardTitle}>Sem notificações</ThemedText>
              <ThemedText style={styles.secondary}>
                Atualizações do pedido aparecem aqui (ex.: Enviado / Entregue).
              </ThemedText>
            </ThemedView>
          ) : null}

          {items.map((n) => (
            <Pressable
              key={n.id}
              onPress={() => open(n)}
              style={({ pressed }) => [styles.card, pressed ? { opacity: 0.92 } : null]}
            >
              <View style={styles.rowBetween}>
                <ThemedText style={styles.cardTitle}>{n.title}</ThemedText>
                {!n.read ? <View style={styles.dot} /> : null}
              </View>

              <ThemedText style={styles.secondary}>{n.body}</ThemedText>

              <View style={styles.divider} />

              <ThemedText style={styles.meta}>
                {dateLabel(n.createdAt)} {n.orderId ? `• Pedido #${n.orderId}` : ""}
              </ThemedText>
            </Pressable>
          ))}

          <View style={{ height: 18 }} />
        </ScrollView>
      </ThemedView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safe: { flex: 1, backgroundColor: theme.colors.background },
  container: { flex: 1, paddingHorizontal: Spacing.lg, paddingBottom: Spacing.lg },

  topbar: {
    height: 54,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: Spacing.sm,
  },
  backBtn: {
    width: 44,
    height: 44,
    borderRadius: 999,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.divider,
  },
  backArrow: { fontFamily: "Arimo", fontSize: 22, fontWeight: "700", color: theme.colors.text },

  title: { fontFamily: "Arimo", fontSize: 20, fontWeight: "700", color: theme.colors.text },

  rightBtn: {
    minWidth: 70,
    height: 44,
    borderRadius: 999,
    paddingHorizontal: 12,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.divider,
  },
  rightBtnText: { fontFamily: "OpenSans", fontSize: 12, fontWeight: "700", color: theme.colors.text },

  scroll: { gap: Spacing.md, paddingTop: Spacing.md, paddingBottom: 20 },

  card: {
    backgroundColor: theme.colors.surface,
    borderRadius: Radius.xl,
    borderWidth: 1,
    borderColor: theme.colors.divider,
    padding: Spacing.lg,
    gap: Spacing.sm,
  },
  cardTitle: { fontFamily: "Arimo", fontSize: 16, fontWeight: "700", color: theme.colors.text },

  secondary: { fontFamily: "OpenSans", fontSize: 12, color: "rgba(0,0,0,0.65)" },
  meta: { fontFamily: "OpenSans", fontSize: 12, color: "rgba(0,0,0,0.55)" },
  bold: { fontWeight: "700", color: theme.colors.text },

  divider: { height: 1, backgroundColor: theme.colors.divider, width: "100%", marginVertical: 6 },

  rowBetween: { flexDirection: "row", alignItems: "center", justifyContent: "space-between", gap: 10 },
  dot: { width: 10, height: 10, borderRadius: 99, backgroundColor: theme.colors.primary },
});



===== PATH: components\ButtonPrimary.tsx =====
import theme from "@/constants/theme";
import React from "react";
import { ActivityIndicator, Pressable, PressableProps, StyleSheet, Text, ViewStyle } from "react-native";

type Props = PressableProps & {
  title: string;
  loading?: boolean;
  style?: ViewStyle | ViewStyle[];
};

export default function ButtonPrimary({ title, loading, disabled, style, ...rest }: Props) {
  const isDisabled = Boolean(disabled || loading);

  return (
    <Pressable
      accessibilityRole="button"
      disabled={isDisabled}
      style={({ pressed }) => [
        styles.base,
        isDisabled && styles.disabled,
        pressed && !isDisabled && styles.pressed,
        style,
      ]}
      {...rest}
    >
      {loading ? (
        <ActivityIndicator />
      ) : (
        <Text style={styles.label}>{title}</Text>
      )}
    </Pressable>
  );
}

const styles = StyleSheet.create({
  base: {
    height: 48,
    borderRadius: 14,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.primary,
  },
  pressed: {
    opacity: 0.9,
  },
  disabled: {
    opacity: 0.55,
  },
  label: {
    color: "#FFFFFF",
    fontWeight: "700",
    letterSpacing: 0.2,
  },
});



===== PATH: components\external-link.tsx =====
import { Href, Link } from 'expo-router';
import { openBrowserAsync, WebBrowserPresentationStyle } from 'expo-web-browser';
import { type ComponentProps } from 'react';

type Props = Omit<ComponentProps<typeof Link>, 'href'> & { href: Href & string };

export function ExternalLink({ href, ...rest }: Props) {
  return (
    <Link
      target="_blank"
      {...rest}
      href={href}
      onPress={async (event) => {
        if (process.env.EXPO_OS !== 'web') {
          // Prevent the default behavior of linking to the default browser on native.
          event.preventDefault();
          // Open the link in an in-app browser.
          await openBrowserAsync(href, {
            presentationStyle: WebBrowserPresentationStyle.AUTOMATIC,
          });
        }
      }}
    />
  );
}



===== PATH: components\global-chrome.tsx =====
// components/global-chrome.tsx
import type { PropsWithChildren } from "react";
import { View } from "react-native";

type GlobalChromeProps = PropsWithChildren<{
  /** Se você quiser, no futuro podemos adicionar opções aqui sem quebrar imports */
}>;

export function GlobalChrome({ children }: GlobalChromeProps) {
  // Wrapper neutro e seguro: não altera navegação, só garante "children" válido.
  return <View style={{ flex: 1 }}>{children}</View>;
}

// Para compatibilidade total (quem importar default não quebra)
export default GlobalChrome;



===== PATH: components\haptic-tab.tsx =====
import { BottomTabBarButtonProps } from '@react-navigation/bottom-tabs';
import { PlatformPressable } from '@react-navigation/elements';
import * as Haptics from 'expo-haptics';

export function HapticTab(props: BottomTabBarButtonProps) {
  return (
    <PlatformPressable
      {...props}
      onPressIn={(ev) => {
        if (process.env.EXPO_OS === 'ios') {
          // Add a soft haptic feedback when pressing down on the tabs.
          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
        }
        props.onPressIn?.(ev);
      }}
    />
  );
}



===== PATH: components\hello-wave.tsx =====
import Animated from 'react-native-reanimated';

export function HelloWave() {
  return (
    <Animated.Text
      style={{
        fontSize: 28,
        lineHeight: 32,
        marginTop: -6,
        animationName: {
          '50%': { transform: [{ rotate: '25deg' }] },
        },
        animationIterationCount: 4,
        animationDuration: '300ms',
      }}>
      👋
    </Animated.Text>
  );
}



===== PATH: components\OrderTimeline.tsx =====
import { StyleSheet, View } from "react-native";
import theme, { Radius, Spacing } from "../constants/theme";
import { ThemedText } from "./themed-text";
import { ThemedView } from "./themed-view";

export type TimelineStep = {
  title: string;
  subtitle?: string;
  dateLabel?: string;
  done?: boolean;
  active?: boolean;
};

type Props = {
  steps: TimelineStep[];
};

export default function OrderTimeline({ steps }: Props) {
  return (
    <ThemedView style={styles.card}>
      <ThemedText style={styles.cardTitle}>Andamento do pedido</ThemedText>

      <View style={styles.list}>
        {steps.map((s, idx) => {
          const isLast = idx === steps.length - 1;
          const dotStyle = [
            styles.dot,
            s.done ? styles.dotDone : null,
            s.active ? styles.dotActive : null,
          ];

          return (
            <View key={`${s.title}-${idx}`} style={styles.row}>
              <View style={styles.rail}>
                <View style={dotStyle} />
                {!isLast ? <View style={styles.line} /> : null}
              </View>

              <View style={styles.content}>
                <View style={styles.headerLine}>
                  <ThemedText style={styles.title}>{s.title}</ThemedText>
                  {s.dateLabel ? (
                    <ThemedText style={styles.date}>{s.dateLabel}</ThemedText>
                  ) : null}
                </View>

                {s.subtitle ? (
                  <ThemedText style={styles.subtitle}>{s.subtitle}</ThemedText>
                ) : null}
              </View>
            </View>
          );
        })}
      </View>
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: theme.colors.surface,
    borderRadius: Radius.xl,
    borderWidth: 1,
    borderColor: theme.colors.divider,
    padding: Spacing.lg,
    gap: Spacing.md,
  },
  cardTitle: {
    fontFamily: "Arimo",
    fontSize: 18,
    fontWeight: "700",
    color: theme.colors.text,
  },
  list: { gap: Spacing.lg },

  row: { flexDirection: "row", gap: Spacing.md, alignItems: "flex-start" },

  rail: { width: 22, alignItems: "center" },
  dot: {
    width: 12,
    height: 12,
    borderRadius: 999,
    borderWidth: 2,
    borderColor: theme.colors.border,
    backgroundColor: theme.colors.surface,
  },
  dotDone: {
    backgroundColor: theme.colors.success,
    borderColor: theme.colors.success,
  },
  dotActive: {
    borderColor: theme.colors.primary,
    backgroundColor: theme.colors.surface,
  },
  line: {
    marginTop: 8,
    width: 2,
    flex: 1,
    backgroundColor: theme.colors.divider,
    borderRadius: 2,
  },

  content: { flex: 1, gap: 6 },
  headerLine: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: Spacing.md,
  },
  title: {
    fontFamily: "OpenSans",
    fontSize: 12,
    fontWeight: "700",
    color: theme.colors.text,
    flex: 1,
  },
  date: {
    fontFamily: "OpenSans",
    fontSize: 12,
    color: theme.colors.tabIconInactive,
  },
  subtitle: {
    fontFamily: "OpenSans",
    fontSize: 12,
    color: theme.colors.tabIconInactive,
    lineHeight: 16,
  },
});



===== PATH: components\parallax-scroll-view.tsx =====
import type { PropsWithChildren, ReactElement } from 'react';
import { StyleSheet } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import Animated, {
  interpolate,
  useAnimatedRef,
  useAnimatedStyle,
  useScrollOffset,
} from 'react-native-reanimated';

import { ThemedView } from '@/components/themed-view';
import { getFooterOffset } from '@/constants/layout';
import { useColorScheme } from '@/hooks/use-color-scheme';
import { useThemeColor } from '@/hooks/use-theme-color';

const HEADER_HEIGHT = 250;

type Props = PropsWithChildren<{
  headerImage: ReactElement;
  headerBackgroundColor: { dark: string; light: string };
}>;

export default function ParallaxScrollView({
  children,
  headerImage,
  headerBackgroundColor,
}: Props) {
  const backgroundColor = useThemeColor({}, 'background');
  const colorScheme = useColorScheme() ?? 'light';
  const insets = useSafeAreaInsets();
  const scrollRef = useAnimatedRef<Animated.ScrollView>();
  const scrollOffset = useScrollOffset(scrollRef);
  const footerOffset = getFooterOffset(insets.bottom);
  const headerAnimatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        {
          translateY: interpolate(
            scrollOffset.value,
            [-HEADER_HEIGHT, 0, HEADER_HEIGHT],
            [-HEADER_HEIGHT / 2, 0, HEADER_HEIGHT * 0.75]
          ),
        },
        {
          scale: interpolate(scrollOffset.value, [-HEADER_HEIGHT, 0, HEADER_HEIGHT], [2, 1, 1]),
        },
      ],
    };
  });

  return (
    <ThemedView style={[styles.screen, { backgroundColor }]}>
      <Animated.ScrollView
        ref={scrollRef}
        style={{ flex: 1 }}
        contentContainerStyle={{ paddingBottom: footerOffset }}
        scrollEventThrottle={16}>
        <Animated.View
          style={[
            styles.header,
            { backgroundColor: headerBackgroundColor[colorScheme] },
            headerAnimatedStyle,
          ]}>
          {headerImage}
        </Animated.View>
        <ThemedView style={styles.content}>{children}</ThemedView>
      </Animated.ScrollView>
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  screen: {
    flex: 1,
  },
  header: {
    height: HEADER_HEIGHT,
    overflow: 'hidden',
  },
  content: {
    flex: 1,
    padding: 32,
    gap: 16,
    overflow: 'hidden',
  },
});



===== PATH: components\product-card.tsx =====
import { Image } from 'expo-image';
import { StyleSheet, View } from 'react-native';

import { ThemedText } from '@/components/themed-text';
import { ThemedView } from '@/components/themed-view';
import { Product } from '@/constants/products';
import { useThemeColor } from '@/hooks/use-theme-color';

type ProductCardProps = {
  product: Product;
};

export function ProductCard({ product }: ProductCardProps) {
  const background = useThemeColor({ light: '#F7FBFF', dark: '#0F1115' }, 'background');
  const accent = useThemeColor({ light: '#0a7ea4', dark: '#7AC4FF' }, 'tint');

  return (
    <ThemedView style={[styles.card, { backgroundColor: background }]}>
      <View style={styles.header}>
        <ThemedText type="defaultSemiBold">{product.category}</ThemedText>
        {product.badge ? (
          <ThemedText style={[styles.badge, { color: accent }]}>{product.badge}</ThemedText>
        ) : null}
      </View>

      <Image
        source={product.image}
        contentFit="cover"
        transition={150}
        style={styles.image}
        accessibilityLabel={product.name}
      />

      <View style={styles.info}>
        <ThemedText type="subtitle" numberOfLines={2}>
          {product.name}
        </ThemedText>
        <ThemedText numberOfLines={3}>{product.description}</ThemedText>
      </View>

      <View style={styles.footer}>
        <ThemedText type="defaultSemiBold">R$ {product.price.toFixed(2)}</ThemedText>
        <ThemedText type="link">Ver detalhes</ThemedText>
      </View>
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  card: {
    borderRadius: 16,
    overflow: 'hidden',
    borderWidth: StyleSheet.hairlineWidth,
    borderColor: '#D5DDE5',
    gap: 12,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingTop: 12,
  },
  badge: {
    fontSize: 12,
  },
  image: {
    width: '100%',
    height: 160,
  },
  info: {
    gap: 6,
    paddingHorizontal: 16,
  },
  footer: {
    paddingHorizontal: 16,
    paddingBottom: 12,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
});



===== PATH: components\themed-text.tsx =====
import { StyleSheet, Text, type TextProps } from 'react-native';

import { useThemeColor } from '@/hooks/use-theme-color';

export type ThemedTextProps = TextProps & {
  lightColor?: string;
  darkColor?: string;
  type?: 'default' | 'title' | 'defaultSemiBold' | 'subtitle' | 'link';
};

export function ThemedText({
  style,
  lightColor,
  darkColor,
  type = 'default',
  ...rest
}: ThemedTextProps) {
  const color = useThemeColor({ light: lightColor, dark: darkColor }, 'text');

  return (
    <Text
      style={[
        { color },
        type === 'default' ? styles.default : undefined,
        type === 'title' ? styles.title : undefined,
        type === 'defaultSemiBold' ? styles.defaultSemiBold : undefined,
        type === 'subtitle' ? styles.subtitle : undefined,
        type === 'link' ? styles.link : undefined,
        style,
      ]}
      {...rest}
    />
  );
}

const styles = StyleSheet.create({
  default: {
    fontSize: 16,
    lineHeight: 24,
  },
  defaultSemiBold: {
    fontSize: 16,
    lineHeight: 24,
    fontWeight: '600',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    lineHeight: 32,
  },
  subtitle: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  link: {
    lineHeight: 30,
    fontSize: 16,
    color: '#0a7ea4',
  },
});



===== PATH: components\themed-view.tsx =====
import { View, type ViewProps } from 'react-native';

import { useThemeColor } from '@/hooks/use-theme-color';

export type ThemedViewProps = ViewProps & {
  lightColor?: string;
  darkColor?: string;
};

export function ThemedView({ style, lightColor, darkColor, ...otherProps }: ThemedViewProps) {
  const backgroundColor = useThemeColor({ light: lightColor, dark: darkColor }, 'background');

  return <View style={[{ backgroundColor }, style]} {...otherProps} />;
}



===== PATH: components\ui\collapsible.tsx =====
import { PropsWithChildren, useState } from "react";
import { StyleSheet, TouchableOpacity } from "react-native";

import { ThemedText } from "@/components/themed-text";
import { ThemedView } from "@/components/themed-view";
import IconSymbol from "@/components/ui/icon-symbol";
import { Colors } from "@/constants/theme";
import { useColorScheme } from "@/hooks/use-color-scheme";

export function Collapsible({ children, title }: PropsWithChildren & { title: string }) {
  const [isOpen, setIsOpen] = useState(false);
  const scheme = useColorScheme() ?? "light";

  const iconColor = scheme === "light" ? Colors.light.icon : Colors.dark.icon;

  return (
    <ThemedView>
      <TouchableOpacity
        style={styles.heading}
        onPress={() => setIsOpen((v) => !v)}
        activeOpacity={0.8}
      >
        <IconSymbol
          name="chevron.right"
          size={18}
          color={iconColor}
          style={{ transform: [{ rotate: isOpen ? "90deg" : "0deg" }] }}
        />
        <ThemedText type="defaultSemiBold">{title}</ThemedText>
      </TouchableOpacity>

      {isOpen ? <ThemedView style={styles.content}>{children}</ThemedView> : null}
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  heading: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
  },
  content: {
    marginTop: 6,
    marginLeft: 24,
  },
});



===== PATH: components\ui\icon-symbol.ios.tsx =====
import Ionicons from "@expo/vector-icons/Ionicons";
import type { StyleProp, TextStyle } from "react-native";

export type IconSymbolName = keyof typeof Ionicons.glyphMap;

type Props = {
  name: string;
  color: string;
  size?: number;
  style?: StyleProp<TextStyle>;
};

function normalizeIoniconName(name: string): IconSymbolName {
  const n = (name ?? "").trim();

  // Compat: padrões tipo SF Symbols / wrappers
  if (n === "chevron.right" || n === "chevron-right" || n === "chevronRight") {
    return "chevron-forward";
  }
  if (n === "chevron.left" || n === "chevron-left" || n === "chevronLeft") {
    return "chevron-back";
  }
  if (n === "chevron.up" || n === "chevron-up" || n === "chevronUp") {
    return "chevron-up";
  }
  if (n === "chevron.down" || n === "chevron-down" || n === "chevronDown") {
    return "chevron-down";
  }

  const key = n as IconSymbolName;
  if ((Ionicons as any).glyphMap?.[key]) return key;

  return "help-circle-outline";
}

function IconSymbol({ name, color, size = 22, style }: Props) {
  const iconName = normalizeIoniconName(name);
  return <Ionicons name={iconName} size={size} color={color} style={style} />;
}

export { IconSymbol };
export default IconSymbol;



===== PATH: components\ui\icon-symbol.tsx =====
import Ionicons from "@expo/vector-icons/Ionicons";
import type { StyleProp, TextStyle } from "react-native";

export type IconSymbolName = keyof typeof Ionicons.glyphMap;

export type IconSymbolProps = {
  /**
   * Aceita nomes do Ionicons e também aliases tipo:
   * - "house.fill"
   * - "person.fill"
   * - "chevron.right"
   */
  name: string;
  size?: number;
  color?: string;
  style?: StyleProp<TextStyle>;
};

function normalizeIoniconName(name: string): IconSymbolName {
  const n = (name ?? "").trim();

  // Aliases (SF-like / wrappers antigos)
  if (n === "house.fill" || n === "house") return "home-outline";
  if (n === "compass.fill" || n === "compass") return "compass-outline";
  if (n === "cart.fill" || n === "cart") return "cart-outline";
  if (n === "person.fill" || n === "person") return "person-outline";
  if (n === "bag.fill" || n === "bag") return "bag-outline";

  // Chevrons
  if (n === "chevron.right" || n === "chevron-right" || n === "chevronRight")
    return "chevron-forward";
  if (n === "chevron.left" || n === "chevron-left" || n === "chevronLeft")
    return "chevron-back";
  if (n === "chevron.up" || n === "chevron-up" || n === "chevronUp")
    return "chevron-up";
  if (n === "chevron.down" || n === "chevron-down" || n === "chevronDown")
    return "chevron-down";

  // Arrows
  if (n === "arrow.left" || n === "arrow-back" || n === "arrowBack")
    return "arrow-back";
  if (n === "arrow.right" || n === "arrow-forward" || n === "arrowForward")
    return "arrow-forward";

  // Se já for um nome válido do Ionicons, mantém
  const key = n as IconSymbolName;
  if ((Ionicons as any).glyphMap?.[key]) return key;

  // Fallback seguro
  return "help-circle-outline";
}

export function IconSymbol({
  name,
  color = "#111",
  size = 22,
  style,
}: IconSymbolProps) {
  const iconName = normalizeIoniconName(name);
  return <Ionicons name={iconName} size={size} color={color} style={style} />;
}

export default IconSymbol;



===== PATH: constants\layout.ts =====
export const BACK_BUTTON_MARGIN = 12;
export const FOOTER_HEIGHT = 72;
export const FOOTER_PADDING = 12;

export const getFooterOffset = (bottomInset: number) => FOOTER_HEIGHT + FOOTER_PADDING + bottomInset;



===== PATH: constants\orders.ts =====
// constants/orders.ts

/**
 * Labels (PT-BR) para EXIBIÇÃO.
 * NÃO confundir com o status técnico (types/orderStatus.ts).
 */
export type OrderStatusLabel = "Confirmado" | "Pago" | "Enviado" | "Entregue";

export const ORDER_STATUS_LABELS: OrderStatusLabel[] = [
  "Confirmado",
  "Pago",
  "Enviado",
  "Entregue",
];



===== PATH: constants\products.ts =====
export type Product = {
  id: string;
  name: string;
  description: string;
  category: string;
  price: number;
  image: string;
  badge?: string;
};

export const products: Product[] = [
  {
    id: 'organizer-cables',
    name: 'Organizador magnético de cabos',
    description: 'Mantém o balcão da loja livre de fios e facilita a rotina de reposição.',
    category: 'Operação',
    price: 79.9,
    image:
      'https://images.unsplash.com/photo-1582719478248-54e9f2af4e04?auto=format&fit=crop&w=900&q=80',
    badge: 'Favorito da equipe',
  },
  {
    id: 'display-acrilico',
    name: 'Display acrílico para destaque',
    description: 'Expõe promoções de forma elegante e aumenta o ticket médio na saída.',
    category: 'Merchandising',
    price: 56.0,
    image:
      'https://images.unsplash.com/photo-1523275335684-37898b6baf30?auto=format&fit=crop&w=900&q=80',
  },
  {
    id: 'kit-embalagem',
    name: 'Kit de embalagens personalizadas',
    description: 'Envelopes e etiquetas com a marca PlugaiShop para reforçar o pós-venda.',
    category: 'Branding',
    price: 119.5,
    image:
      'https://images.unsplash.com/photo-1521572163474-6864f9cf17ab?auto=format&fit=crop&w=900&q=80',
    badge: 'Reposição rápida',
  },
  {
    id: 'totem-autoatendimento',
    name: 'Totem de autoatendimento',
    description: 'Reduz filas no caixa e ajuda clientes a consultar estoque em minutos.',
    category: 'Experiência',
    price: 1499.0,
    image:
      'https://images.unsplash.com/photo-1441986300917-64674bd600d8?auto=format&fit=crop&w=900&q=80',
  },
  {
    id: 'sensor-estoque',
    name: 'Sensor inteligente de estoque',
    description: 'Notifica a equipe sobre variações de demanda e evita ruptura de gôndola.',
    category: 'Operação',
    price: 329.0,
    image:
      'https://images.unsplash.com/photo-1433838552652-f9a46b332c40?auto=format&fit=crop&w=900&q=80',
  },
  {
    id: 'iluminacao-led',
    name: 'Kit de iluminação LED para vitrines',
    description: 'Valoriza produtos premium com temperatura de cor regulável.',
    category: 'Merchandising',
    price: 249.9,
    image:
      'https://images.unsplash.com/photo-1460925895917-afdab827c52f?auto=format&fit=crop&w=900&q=80',
  },
];

export const categories = ['Todos', ...Array.from(new Set(products.map((product) => product.category)))] as const;



===== PATH: constants\theme.ts =====
// constants/theme.ts

export const Spacing = {
  xs: 6,
  sm: 10,
  md: 14,
  lg: 18,
  xl: 24,
} as const;

export const Radius = {
  sm: 10,
  md: 14,
  lg: 18,
  xl: 24,
  pill: 999,
} as const;

/**
 * Mantemos o shape “Colors.light/dark.*” para compatibilidade com arquivos antigos.
 */
export const Colors = {
  light: {
    text: "#0F172A",
    background: "#F7F8FA",
    tint: "#16A34A",
    icon: "#94A3B8",
    tabIconDefault: "#94A3B8",
    tabIconSelected: "#16A34A",
  },
  dark: {
    text: "#E5E7EB",
    background: "#0B1220",
    tint: "#22C55E",
    icon: "#94A3B8",
    tabIconDefault: "#94A3B8",
    tabIconSelected: "#22C55E",
  },
} as const;

const theme = {
  colors: {
    background: "#F7F8FA",
    backgroundSoft: "#EEF1F5",
    surface: "#FFFFFF",
    surfaceAlt: "#F1F3F6",
    divider: "#E6E8EC",
    border: "#E6E8EC",

    // textos (inclui aliases)
    text: "#0F172A",
    textMuted: "#64748B",
    textPrimary: "#0F172A",
    textSecondary: "#64748B",

    // Alias exigido por alguns componentes (ex.: OrderTimeline)
    muted: "#94A3B8",

    // Alias extra (opcional, mas ajuda compatibilidade sem quebrar nada)
    mutedText: "#64748B",

    primary: "#16A34A",
    primarySoft: "#DCFCE7",

    success: "#16A34A",
    successSoft: "#DCFCE7",

    warning: "#F59E0B",
    warningSoft: "#FEF3C7",

    danger: "#EF4444",
    dangerSoft: "#FEE2E2",

    tabIconActive: "#16A34A",
    tabIconInactive: "#94A3B8",
  },

  spacing: Spacing,
  radius: Radius,

  typography: {
    h1: { fontSize: 28, lineHeight: 34, fontWeight: "800" as const },
    h2: { fontSize: 22, lineHeight: 28, fontWeight: "800" as const },
    h3: { fontSize: 18, lineHeight: 24, fontWeight: "700" as const },

    // Alias que o Profile está pedindo:
    sectionTitle: { fontSize: 14, lineHeight: 18, fontWeight: "800" as const },

    title: { fontSize: 18, lineHeight: 24, fontWeight: "700" as const },
    subtitle: { fontSize: 16, lineHeight: 22, fontWeight: "600" as const },
    body: { fontSize: 16, lineHeight: 22, fontWeight: "400" as const },
    bodySmall: { fontSize: 14, lineHeight: 20, fontWeight: "400" as const },
    caption: { fontSize: 12, lineHeight: 16, fontWeight: "400" as const },
    button: { fontSize: 14, lineHeight: 18, fontWeight: "700" as const },
  },
} as const;

export default theme;



===== PATH: context\CartContext.tsx =====
// context/CartContext.tsx
import type { ReactNode } from "react";
import { createContext, useCallback, useContext, useEffect, useMemo, useState } from "react";
import type { Product } from "../data/catalog";

/**
 * CartItem (COMPATÍVEL COM O cart.tsx + checkout)
 * - cart.tsx usa campos "flat": id, title, price, image, etc.
 * - checkout/review usa it.product.*
 */
export type CartItem = {
  // checkout
  product: Product;

  // carrinho (compat)
  id: string;
  title: string;
  price: number;
  category?: string;
  image?: string;
  description?: string;
  unitLabel?: string;
  discountPercent?: number;

  // comum
  qty: number;
};

/**
 * ESTADO INTERNO
 */
type CartState = {
  items: CartItem[];
};

const state: CartState = { items: [] };
const listeners = new Set<() => void>();

function emit() {
  listeners.forEach((l) => l());
}

function subscribe(listener: () => void) {
  listeners.add(listener);
  return () => {
    listeners.delete(listener);
  };
}

function getSnapshot(): CartState {
  return { items: state.items };
}

function setItems(next: CartItem[]) {
  state.items = next;
  emit();
}

/** Helper: transforma Product -> CartItem flat */
function toCartItem(product: Product, qty: number): CartItem {
  const price = Number((product as any).price) || 0;

  return {
    product,
    id: (product as any).id,
    title: (product as any).title ?? "",
    price,
    category: (product as any).category,
    image: (product as any).image,
    description: (product as any).description,
    unitLabel: (product as any).unitLabel,
    discountPercent: (product as any).discountPercent,
    qty,
  };
}

/**
 * REGRAS DE NEGÓCIO
 */
function upsert(product: Product, qtyDelta: number) {
  const current = state.items;
  const pid = (product as any).id;
  const index = current.findIndex((i) => i.id === pid);

  if (index === -1) {
    setItems([...current, toCartItem(product, Math.max(1, qtyDelta))]);
    return;
  }

  const nextQty = current[index].qty + qtyDelta;

  if (nextQty <= 0) {
    setItems(current.filter((_, i) => i !== index));
    return;
  }

  setItems(
    current.map((it, i) => (i === index ? { ...toCartItem(it.product, nextQty), qty: nextQty } : it))
  );
}

function setQty(productId: string, qty: number) {
  const q = Math.max(1, Math.floor(qty));
  setItems(
    state.items.map((it) =>
      it.id === productId ? { ...toCartItem(it.product, q), qty: q } : it
    )
  );
}

function remove(productId: string) {
  setItems(state.items.filter((it) => it.id !== productId));
}

function clear() {
  setItems([]);
}

/**
 * HOOK PÚBLICO
 * (com aliases para compatibilidade com o cart.tsx)
 */
export function useCart() {
  const [snap, setSnap] = useState<CartState>(() => getSnapshot());

  useEffect(() => {
    const unsub = subscribe(() => setSnap(getSnapshot()));
    return unsub;
  }, []);

  const totalQty = useMemo(() => snap.items.reduce((acc, it) => acc + it.qty, 0), [snap.items]);

  const subtotal = useMemo(() => {
    return snap.items.reduce((acc, it) => {
      const price = Number(it.price);
      return acc + (Number.isFinite(price) ? price * it.qty : 0);
    }, 0);
  }, [snap.items]);

  const total = subtotal;

  const addItem = useCallback((product: Product, qtyDelta: number = 1) => upsert(product, qtyDelta), []);
  const decItem = useCallback((product: Product, qtyDelta: number = 1) => upsert(product, -Math.abs(qtyDelta)), []);

  const removeItem = useCallback((productId: string, _ignored?: any) => remove(productId), []);
  const setItemQty = useCallback((productId: string, qty: number) => setQty(productId, qty), []);
  const clearCart = useCallback(() => clear(), []);

  return {
    items: snap.items,

    totalQty,
    subtotal,
    total,

    addItem,
    decItem,
    removeItem,
    setItemQty,
    clearCart,

    setQty: setItemQty,
  };
}

const DummyCartContext = createContext(true);

export function CartProvider({ children }: { children: ReactNode }) {
  return <DummyCartContext.Provider value={true}>{children}</DummyCartContext.Provider>;
}

export function useCartProviderGuard() {
  return useContext(DummyCartContext);
}



===== PATH: eslint.config.js =====
// https://docs.expo.dev/guides/using-eslint/
const { defineConfig } = require('eslint/config');
const expoConfig = require('eslint-config-expo/flat');

module.exports = defineConfig([
  expoConfig,
  {
    ignores: ['dist/*'],
  },
]);



===== PATH: hooks\use-color-scheme.ts =====
export { useColorScheme } from 'react-native';



===== PATH: hooks\use-color-scheme.web.ts =====
import { useEffect, useState } from 'react';
import { useColorScheme as useRNColorScheme } from 'react-native';

/**
 * To support static rendering, this value needs to be re-calculated on the client side for web
 */
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() => {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return 'light';
}



===== PATH: hooks\use-theme-color.ts =====
/**
 * Learn more about light and dark modes:
 * https://docs.expo.dev/guides/color-schemes/
 */

import { Colors } from '@/constants/theme';
import { useColorScheme } from '@/hooks/use-color-scheme';

export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}



===== PATH: hooks\useCheckoutFailSafe.ts =====
// hooks/useCheckoutFailSafe.ts
import { router } from "expo-router";
import { useEffect } from "react";

import type { OrderDraft } from "../types/order";
import { loadOrderDraft } from "../utils/orderStorage";

type ReplaceArg = Parameters<typeof router.replace>[0];

type CheckoutStep = "address" | "shipping" | "payment" | "review";

function getNextCheckoutStep(draft: OrderDraft): CheckoutStep {
  if (!draft.address) return "address";
  if (!draft.shipping) return "shipping";
  if (!draft.payment?.method) return "payment";
  return "review";
}

function stepToRoute(step: CheckoutStep) {
  switch (step) {
    case "address":
      return "/checkout/address";
    case "shipping":
      return "/checkout/shipping";
    case "payment":
      return "/checkout/payment";
    default:
      return "/checkout/review";
  }
}

export function useCheckoutFailSafe() {
  useEffect(() => {
    let alive = true;

    (async () => {
      try {
        const draft = (await loadOrderDraft()) as OrderDraft | null;
        if (!alive) return;
        if (!draft) return;

        if (!Array.isArray(draft.items) || draft.items.length === 0) return;

        const step = getNextCheckoutStep(draft);
        const href = stepToRoute(step) as ReplaceArg;

        router.replace(href);
      } catch {
        // fail-safe não pode travar o app
      }
    })();

    return () => {
      alive = false;
    };
  }, []);
}



===== PATH: hooks\useOrderFailSafe.ts =====
import { useEffect } from "react";
import { resumeCheckoutIfNeeded } from "../utils/orderResume";

export function useOrderFailSafe() {
  useEffect(() => {
    resumeCheckoutIfNeeded();
  }, []);
}



===== PATH: hooks\useOrdersAutoProgress.ts =====
// hooks/useOrdersAutoProgress.ts
import { useEffect } from "react";

import type { Order } from "../types/order";
import { advanceMockStatus } from "../utils/orderTimelineAuto";
import { listOrders, saveOrders } from "../utils/ordersStore";

export function useOrdersAutoProgress() {
  useEffect(() => {
    let alive = true;

    const tick = async () => {
      try {
        const raw = await listOrders();

        // Normaliza tipagem para usar SEMPRE os tipos do /types
        const orders = raw as unknown as Order[];

        let changed = false;

        const nextOrders = orders.map((o) => {
          const next = advanceMockStatus(o);
          if (next.status !== o.status) changed = true;
          return next;
        });

        if (alive && changed) {
          // ordersStore pode estar tipado com "Order" próprio; mantemos compatível
          await saveOrders(nextOrders as unknown as any);
        }
      } catch {
        // silencioso: hook não pode derrubar a tela
      }
    };

    // roda uma vez ao montar
    tick();

    // e repete periodicamente (leve)
    const id = setInterval(tick, 12_000);

    return () => {
      alive = false;
      clearInterval(id);
    };
  }, []);
}

export default useOrdersAutoProgress;



===== PATH: hooks\useOutboxAutoFlush.ts =====
import { useEffect } from "react";
import { processOutboxOnce } from "../utils/outboxProcessor";

export function useOutboxAutoFlush() {
  useEffect(() => {
    let alive = true;

    (async () => {
      // tentativa inicial
      try {
        await processOutboxOnce();
      } catch {}
    })();

    // loop leve
    const id = setInterval(async () => {
      if (!alive) return;
      try {
        await processOutboxOnce();
      } catch {}
    }, 8000);

    return () => {
      alive = false;
      clearInterval(id);
    };
  }, []);
}



===== PATH: package.json =====
{
  "name": "plugaishop-app",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "reset-project": "node ./scripts/reset-project.js",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "lint": "expo lint"
  },
  "dependencies": {
    "@expo-google-fonts/arimo": "^0.4.2",
    "@expo-google-fonts/lexend": "^0.4.1",
    "@expo/vector-icons": "^15.0.3",
    "@react-native-async-storage/async-storage": "2.2.0",
    "@react-native-community/netinfo": "11.4.1",
    "@react-navigation/bottom-tabs": "^7.4.0",
    "@react-navigation/elements": "^2.6.3",
    "@react-navigation/native": "^7.1.8",
    "expo": "~54.0.30",
    "expo-clipboard": "~8.0.8",
    "expo-constants": "~18.0.12",
    "expo-font": "~14.0.10",
    "expo-haptics": "~15.0.8",
    "expo-image": "~3.0.11",
    "expo-linking": "~8.0.11",
    "expo-notifications": "~0.32.15",
    "expo-router": "~6.0.21",
    "expo-splash-screen": "~31.0.13",
    "expo-status-bar": "~3.0.9",
    "expo-symbols": "~1.0.8",
    "expo-system-ui": "~6.0.9",
    "expo-web-browser": "~15.0.10",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-native": "0.81.5",
    "react-native-gesture-handler": "~2.28.0",
    "react-native-qrcode-svg": "^6.3.21",
    "react-native-reanimated": "~4.1.1",
    "react-native-safe-area-context": "~5.6.0",
    "react-native-screens": "~4.16.0",
    "react-native-svg": "15.12.1",
    "react-native-web": "~0.21.0",
    "react-native-worklets": "0.5.1"
  },
  "devDependencies": {
    "@types/react": "~19.1.0",
    "eslint": "^9.25.0",
    "eslint-config-expo": "~10.0.0",
    "typescript": "~5.9.2"
  },
  "private": true
}



===== PATH: README.md =====
# Welcome to your Expo app 👋

This is an [Expo](https://expo.dev) project created with [`create-expo-app`](https://www.npmjs.com/package/create-expo-app).

## Get started

1. Install dependencies

   ```bash
   npm install
   ```

2. Start the app

   ```bash
   npx expo start
   ```

In the output, you'll find options to open the app in a

- [development build](https://docs.expo.dev/develop/development-builds/introduction/)
- [Android emulator](https://docs.expo.dev/workflow/android-studio-emulator/)
- [iOS simulator](https://docs.expo.dev/workflow/ios-simulator/)
- [Expo Go](https://expo.dev/go), a limited sandbox for trying out app development with Expo

You can start developing by editing the files inside the **app** directory. This project uses [file-based routing](https://docs.expo.dev/router/introduction).

## Get a fresh project

When you're ready, run:

```bash
npm run reset-project
```

This command will move the starter code to the **app-example** directory and create a blank **app** directory where you can start developing.

## Learn more

To learn more about developing your project with Expo, look at the following resources:

- [Expo documentation](https://docs.expo.dev/): Learn fundamentals, or go into advanced topics with our [guides](https://docs.expo.dev/guides).
- [Learn Expo tutorial](https://docs.expo.dev/tutorial/introduction/): Follow a step-by-step tutorial where you'll create a project that runs on Android, iOS, and the web.

## Join the community

Join our community of developers creating universal apps.

- [Expo on GitHub](https://github.com/expo/expo): View our open source platform and contribute.
- [Discord community](https://chat.expo.dev): Chat with Expo users and ask questions.



===== PATH: scripts\ai\_out\context-bundle.txt =====
## plugaishop context bundle
repo: C:\plugaishop-app
generatedAt: 2026-02-02T21:46:28.0513798-03:00

### FILE: context/CartContext.tsx
### STATUS: OK
-----BEGIN TS-----
// context/CartContext.tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import NetInfo from "@react-native-community/netinfo";
import React, { createContext, useCallback, useContext, useEffect, useMemo, useReducer, useRef, useState } from "react";

import type { Product } from "../data/catalog";
import { enqueueCartJob, processCartOutboxOnce } from "../src/cart/cartOutbox";

// ===== Types
export type CartItem = {
  /** Chave estÃ¡vel do item no carrinho (suporta variaÃ§Ã£o quando existir) */
  id: string;
  product: Product;
  qty: number;

  /** Metadados de auditoria (Ãºtil para debug e merges) */
  addedAt: string;   // ISO
  updatedAt: string; // ISO
};

export type CartState = {
  version: 1;
  itemsById: Record<string, CartItem>;
};

export type CartApi = {
  /** Lista para UI */
  items: CartItem[];

  /** Estado de boot */
  hydrated: boolean;

  /** OperaÃ§Ãµes */
  addItem: (product: Product, qty?: number, opts?: { idKey?: string }) => void;
  removeItem: (id: string) => void;
  setQty: (id: string, qty: number) => void;
  clearCart: () => void;

  // Aliases/compat (evita quebrar telas antigas)
  add?: (product: Product) => void;
  remove?: (product: Product, qty?: number) => void;
  decItem?: (product: Product, qty?: number) => void;
  clear?: () => void;
  reset?: () => void;

  /** Observabilidade / debug */
  flushSyncOnce: () => Promise<void>;
};

const STORAGE_KEY = "@plugaishop:cart:v1";

const initialState: CartState = { version: 1, itemsById: {} };

type Action =
  | { type: "HYDRATE"; state: CartState }
  | { type: "ADD"; item: CartItem }
  | { type: "REMOVE"; id: string }
  | { type: "SET_QTY"; id: string; qty: number }
  | { type: "CLEAR" };

function clampQty(qty: number) {
  const n = Number(qty);
  if (!Number.isFinite(n)) return 1;
  return Math.max(1, Math.floor(n));
}

function reducer(state: CartState, action: Action): CartState {
  switch (action.type) {
    case "HYDRATE": {
      // Merge defensivo (anti-race): ao iniciar o app, HYDRATE pode chegar depois de um ADD feito "rÃ¡pido".
      // Se fizermos replace puro, pisoteamos o item recÃ©m-adicionado. Aqui fazemos merge por updatedAt.
      const safe = action.state && action.state.version === 1 ? action.state : initialState;

      const loaded = safe.itemsById ?? {};
      const current = state.itemsById ?? {};

      const toTime = (iso?: string) => {
        const t = iso ? Date.parse(iso) : NaN;
        return Number.isFinite(t) ? t : 0;
      };

      const merged: Record<string, CartItem> = { ...loaded };

      for (const [id, cur] of Object.entries(current)) {
        const fromStorage = loaded[id];
        if (!fromStorage) {
          merged[id] = cur;
          continue;
        }

        const curT = toTime(cur.updatedAt) || toTime(cur.addedAt);
        const stT = toTime(fromStorage.updatedAt) || toTime(fromStorage.addedAt);

        // Preferir o mais recente; em empate, preserva o atual (evita regressÃ£o de qty)
        merged[id] = curT >= stT ? cur : fromStorage;
      }

      return { version: 1, itemsById: merged };
    }
    case "ADD": {
      const id = String(action.item.id);
      const prev = state.itemsById[id];
      if (prev) {
        const qty = clampQty(prev.qty + action.item.qty);
        return {
          ...state,
          itemsById: {
            ...state.itemsById,
            [id]: { ...prev, qty, updatedAt: action.item.updatedAt, product: action.item.product },
          },
        };
      }
      return { ...state, itemsById: { ...state.itemsById, [id]: action.item } };
    }
    case "REMOVE": {
      if (!state.itemsById[action.id]) return state;
      const next = { ...state.itemsById };
      delete next[action.id];
      return { ...state, itemsById: next };
    }
    case "SET_QTY": {
      const it = state.itemsById[action.id];
      if (!it) return state;
      const qty = clampQty(action.qty);
      if (qty === it.qty) return state;
      const updatedAt = new Date().toISOString();
      return { ...state, itemsById: { ...state.itemsById, [action.id]: { ...it, qty, updatedAt } } };
    }
    case "CLEAR":
      return initialState;
    default:
      return state;
  }
}

async function safeLoad(): Promise<CartState | null> {
  const raw = await AsyncStorage.getItem(STORAGE_KEY);
  if (!raw) return null;
  try {
    const parsed = JSON.parse(raw) as CartState;
    if (!parsed || parsed.version !== 1) return null;
    if (!parsed.itemsById || typeof parsed.itemsById !== "object") return null;
    return parsed;
  } catch {
    return null;
  }
}

async function safeSave(state: CartState) {
  try {
    await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  } catch {
    // storage falhou: nÃ£o derruba a UI
  }
}

const CartCtx = createContext<CartApi | null>(null);

export function CartProvider({ children }: { children: React.ReactNode }) {
  const [state, dispatch] = useReducer(reducer, initialState);
  const [hydrated, setHydrated] = useState(false);

  // PersistÃªncia com debounce
  const saveTimer = useRef<ReturnType<typeof setTimeout> | null>(null);
  const lastSavedJson = useRef<string>("");

  const scheduleSave = useCallback((next: CartState) => {
    if (saveTimer.current) clearTimeout(saveTimer.current);

    saveTimer.current = setTimeout(() => {
      const json = JSON.stringify(next);
      if (json === lastSavedJson.current) return;
      lastSavedJson.current = json;
      safeSave(next);
    }, 350);
  }, []);

  // Hydrate no boot
  useEffect(() => {
    let alive = true;
    (async () => {
      const loaded = await safeLoad();
      if (!alive) return;
      if (loaded) {
        dispatch({ type: "HYDRATE", state: loaded });
        lastSavedJson.current = JSON.stringify(loaded);
      }
      setHydrated(true);
    })();
    return () => {
      alive = false;
    };
  }, []);

  // Salva toda vez que o estado muda (debounced)
  useEffect(() => {
    if (!hydrated) return;
    scheduleSave(state);
  }, [hydrated, scheduleSave, state]);

  const items = useMemo(() => Object.values(state.itemsById), [state.itemsById]);

  // ===== Sync resiliente (outbox)
  const enqueue = useCallback(async (job: any) => {
    // NÃ£o trava UI. Enfileira e tenta flush quando online.
    await enqueueCartJob(job);
    const net = await NetInfo.fetch();
    if (net.isConnected) {
      // best-effort
      processCartOutboxOnce().catch(() => {});
    }
  }, []);

  const addItem = useCallback(
    (product: Product, qty: number = 1, opts?: { idKey?: string }) => {
      const id = String(opts?.idKey ?? product?.id ?? "");
      if (!id) return;
      const now = new Date().toISOString();
      const item: CartItem = { id, product, qty: clampQty(qty), addedAt: now, updatedAt: now };
      dispatch({ type: "ADD", item });

      // Sync (otimista)
      enqueue({ op: "ADD", id, qty: clampQty(qty), productId: product.id, at: now }).catch(() => {});
    },
    [enqueue]
  );

  const removeItem = useCallback(
    (id: string) => {
      const key = String(id ?? "");
      if (!key) return;
      dispatch({ type: "REMOVE", id: key });
      const at = new Date().toISOString();
      enqueue({ op: "REMOVE", id: key, at }).catch(() => {});
    },
    [enqueue]
  );

  const setQty = useCallback(
    (id: string, qty: number) => {
      const key = String(id ?? "");
      if (!key) return;
      const q = clampQty(qty);
      dispatch({ type: "SET_QTY", id: key, qty: q });
      const at = new Date().toISOString();
      // CoalescÃªncia simples: SET_QTY substitui a intenÃ§Ã£o anterior
      enqueue({ op: "SET_QTY", id: key, qty: q, at }).catch(() => {});
    },
    [enqueue]
  );


  // Compat: alguns pontos do app chamam mÃ©todos antigos.
  const add = useCallback(
    (product: Product) => {
      addItem(product, 1);
    },
    [addItem]
  );

  const remove = useCallback(
    (product: Product, qty: number = 1) => {
      const id = String((product as any)?.id ?? "");
      if (!id) return;
      // remove "qty" vezes: aqui optamos por remover item inteiro (padrÃ£o marketplace).
      // Se desejar comportamento incremental, use decItem.
      removeItem(id);
    },
    [removeItem]
  );

  const decItem = useCallback(
    (product: Product, qty: number = 1) => {
      const id = String((product as any)?.id ?? "");
      if (!id) return;
      const current = state.itemsById[id];
      if (!current) return;
      const nextQty = clampQty(current.qty - Math.max(1, Math.floor(Number(qty) || 1)));
      if (nextQty <= 1) {
        // MantÃ©m mÃ­nimo 1; para remover, usa removeItem
        setQty(id, 1);
      } else {
        setQty(id, nextQty);
      }
    },
    [setQty, state.itemsById]
  );


  const clearCart = useCallback(() => {
    dispatch({ type: "CLEAR" });
    const at = new Date().toISOString();
    enqueue({ op: "CLEAR", at }).catch(() => {});
  }, [enqueue]);

  const clear = useCallback(() => clearCart(), [clearCart]);
  const reset = useCallback(() => clearCart(), [clearCart]);

  const flushSyncOnce = useCallback(async () => {
    await processCartOutboxOnce();
  }, []);

  const api = useMemo<CartApi>(
    () => ({ items, hydrated, addItem, removeItem, setQty, clearCart, flushSyncOnce, add, remove, decItem, clear, reset }),
    [items, hydrated, addItem, removeItem, setQty, clearCart, flushSyncOnce]
  );

  return <CartCtx.Provider value={api}>{children}</CartCtx.Provider>;
}

export function useCart(): CartApi {
  const ctx = useContext(CartCtx);

  if (!ctx) {
    // Em DEV, falha alto para nÃ£o mascarar UI "inerte".
    if (__DEV__) {
      throw new Error("CartProvider ausente: monte <CartProvider> em app/_layout.tsx.");
    }

    // Em PROD, fail-safe para evitar crash por configuraÃ§Ã£o incorreta.
    return {
      items: [],
      hydrated: false,
      addItem: () => {},
      removeItem: () => {},
      setQty: () => {},
      clearCart: () => {},
      flushSyncOnce: async () => {},
      add: () => {},
      remove: () => {},
      decItem: () => {},
      clear: () => {},
      reset: () => {},
    };
  }

  return ctx;
}

-----END TS-----

### FILE: utils/cartPricing.ts
### STATUS: OK
-----BEGIN TS-----
// utils/cartPricing.ts
import { clampCents, fromCents, moneyMinCents, roundPercentOfCents, toCents } from "./money";

export type CouponLike =
  | { code?: string; type: "percent"; value: number }
  | { code?: string; type: "fixed"; value: number }
  | { code?: string; type: "free_shipping"; value?: 0 };

export type CartPricingRow = {
  id: string;
  price: number;
  qty: number;
  discountPercent?: number;
};

export type ShippingMethod = "delivery" | "pickup";

export type CartPricingInput = {
  rows: CartPricingRow[];
  selectedById: Record<string, boolean> | null | undefined;

  coupon: CouponLike | null | undefined;

  shippingMethod: ShippingMethod;
  cep8: string;
  freeShippingThreshold: number;

  /**
   * Deve retornar valor (R$) do frete para o CEP (jÃ¡ normalizado com 8 dÃ­gitos).
   * MantÃ©m o comportamento atual do carrinho (mock/estimativa).
   */
  estimateShipping: (cep8: string) => number;

  /**
   * Garantia/ProteÃ§Ã£o estendida:
   * - `protectionById[id] = months` (ex.: 12/24)
   * - `buildProtectionPlans(unitFinal)` deve devolver os planos com preÃ§o (R$)
   * - `calcUnitWithProductDiscount(unit, pct)` deve retornar unitÃ¡rio apÃ³s desconto do produto (R$)
   */
  protectionById?: Record<string, number | undefined>;
  buildProtectionPlans?: (unitFinal: number) => { months: number; price: number }[];
  calcUnitWithProductDiscount?: (unit: number, discountPercent?: number) => number;
};

export type FreeShippingProgress = { ratio: number; missing: number; reached: boolean };

export type CartPricingOutput = {
  subtotalRaw: number;

  productDiscountTotal: number;
  subtotalAfterProductDiscount: number;

  couponDiscount: number;
  discountTotal: number;

  protectionTotal: number;

  shippingEstimated: number;
  total: number;

  freeShippingProgress: FreeShippingProgress;

  // mÃ©tricas Ãºteis para debug/telemetria
  selectedCount: number;
  selectedQty: number;
};

function safeId(v: unknown): string {
  return String(v ?? "");
}

function safeMoney(n: unknown): number {
  const v = typeof n === "number" ? n : Number(n);
  return Number.isFinite(v) ? v : 0;
}

function safePct(n: unknown): number {
  const v = typeof n === "number" ? n : Number(n);
  if (!Number.isFinite(v) || v <= 0) return 0;
  return v;
}

/**
 * Engine determinÃ­stico de pricing (Etapa 20)
 * - centavos (inteiro) -> evita divergÃªncia em subtotal/desconto/total
 * - nÃ£o depende de UI
 */
export function computeCartPricing(input: CartPricingInput): CartPricingOutput {
  const rows = Array.isArray(input.rows) ? input.rows : [];
  const selected = input.selectedById ?? {};
  const coupon = input.coupon ?? null;

  const freeThresholdCents = toCents(input.freeShippingThreshold);

  let subtotalCents = 0;
  let productDiscountCents = 0;
  let selectedCount = 0;
  let selectedQty = 0;

  for (const r of rows) {
    const id = safeId(r?.id);
    if (!id) continue;
    if (!selected[id]) continue;

    selectedCount += 1;

    const qty = Math.max(1, Math.floor(safeMoney(r?.qty ?? 1)));
    selectedQty += qty;

    const unitCents = toCents(safeMoney(r?.price));
    subtotalCents += unitCents * qty;

    const pct = safePct((r as any)?.discountPercent);
    if (pct > 0) {
      const unitDiscountCents = roundPercentOfCents(unitCents, pct);
      productDiscountCents += unitDiscountCents * qty;
    }
  }

  subtotalCents = clampCents(subtotalCents);
  productDiscountCents = moneyMinCents(productDiscountCents, subtotalCents);

  const subtotalAfterProductDiscountCents = clampCents(subtotalCents - productDiscountCents);

  // Cupom
  let couponDiscountCents = 0;

  if (coupon && coupon.type !== "free_shipping") {
    if (coupon.type === "percent") {
      const pct = safePct(coupon.value);
      couponDiscountCents = roundPercentOfCents(subtotalAfterProductDiscountCents, pct);
    } else if (coupon.type === "fixed") {
      const fixedCents = toCents(safeMoney(coupon.value));
      couponDiscountCents = fixedCents;
    }
  }

  // Regra marketplace: desconto nÃ£o pode ultrapassar subtotal do produto
  couponDiscountCents = moneyMinCents(couponDiscountCents, subtotalAfterProductDiscountCents);

  const discountTotalCents = clampCents(productDiscountCents + couponDiscountCents);

  // ProteÃ§Ã£o estendida
  let protectionCents = 0;

  if (input.protectionById && input.buildProtectionPlans && input.calcUnitWithProductDiscount) {
    const protectionById = input.protectionById;

    for (const r of rows) {
      const id = safeId(r?.id);
      if (!id) continue;
      if (!selected[id]) continue;

      const months = protectionById[id];
      if (!months) continue;

      const unit = safeMoney(r?.price);
      const pct = safePct((r as any)?.discountPercent);
      const unitFinal = input.calcUnitWithProductDiscount(unit, pct);

      const plans = input.buildProtectionPlans(unitFinal);
      const plan = plans.find((p) => p.months === months) ?? null;
      if (!plan) continue;

      protectionCents += toCents(safeMoney(plan.price));
    }
  }

  protectionCents = clampCents(protectionCents);

  // Frete
  let shippingCents = 0;
  const hasSelection = selectedCount > 0;

  if (hasSelection && input.shippingMethod !== "pickup") {
    const freeByCoupon = coupon?.type === "free_shipping";
    const freeByThreshold = freeThresholdCents > 0 && subtotalAfterProductDiscountCents >= freeThresholdCents;

    if (!freeByCoupon && !freeByThreshold) {
      const v = safeMoney(input.estimateShipping(input.cep8));
      shippingCents = toCents(v);
    }
  }

  shippingCents = clampCents(shippingCents);

  // Total final
  const totalCents = clampCents(subtotalAfterProductDiscountCents - couponDiscountCents + shippingCents + protectionCents);

  // Progresso de frete grÃ¡tis (base: subtotal apÃ³s desconto do produto)
  const baseForProgressCents = subtotalAfterProductDiscountCents;
  const ratio =
    freeThresholdCents <= 0 ? 0 : Math.min(1, baseForProgressCents / Math.max(1, freeThresholdCents));
  const missingCents = clampCents(freeThresholdCents - baseForProgressCents);

  return {
    subtotalRaw: fromCents(subtotalCents),

    productDiscountTotal: fromCents(productDiscountCents),
    subtotalAfterProductDiscount: fromCents(subtotalAfterProductDiscountCents),

    couponDiscount: fromCents(couponDiscountCents),
    discountTotal: fromCents(discountTotalCents),

    protectionTotal: fromCents(protectionCents),

    shippingEstimated: fromCents(shippingCents),
    total: fromCents(totalCents),

    freeShippingProgress: {
      ratio,
      missing: fromCents(missingCents),
      reached: freeThresholdCents > 0 ? baseForProgressCents >= freeThresholdCents : false,
    },

    selectedCount,
    selectedQty,
  };
}

-----END TS-----

### FILE: utils/orderDraftBuilder.ts
### STATUS: OK
-----BEGIN TS-----
// utils/orderDraftBuilder.ts
import type { Address, OrderDraft, Payment, Shipping } from "../types/order";

type BuildDraftParams = {
  id: string; // mantido por compat, mas OrderDraft nÃ£o possui id
  items: OrderDraft["items"];
  subtotal: number;
  discount?: number;
  shipping?: Shipping;
  address?: Address;
  payment?: Payment;
  note?: string;
};

export function buildOrderDraft(params: BuildDraftParams): OrderDraft {
  const shippingPrice = params.shipping?.price ?? 0;
  const discount = params.discount ?? 0;

  return {
    v: 2,
    createdAt: new Date().toISOString(),
    items: params.items,
    selectedItemIds: (params.items ?? []).map((it) => String(it.id)),

    subtotal: params.subtotal,
    discount,
    shipping: params.shipping,
    address: params.address,
    payment: params.payment,
    note: params.note,

    total: params.subtotal - discount + shippingPrice,
  };
}

-----END TS-----

### FILE: app/(tabs)/cart.tsx
### STATUS: OK
-----BEGIN TS-----
// app/(tabs)/cart.tsx
import { useFocusEffect, useIsFocused } from "@react-navigation/native";
import { router } from "expo-router";
import { memo, useCallback, useEffect, useMemo, useRef, useState } from "react";
import {
  Alert,
  Image,
  Modal,
  Pressable,
  SectionList,
  StyleSheet,
  TextInput,
  Vibration,
  View,
  type ImageSourcePropType,
} from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";

import { ThemedText } from "../../components/themed-text";
import { ThemedView } from "../../components/themed-view";
import Icon from "../../components/ui/icon-symbol";
import theme from "../../constants/theme";
import { useCart } from "../../context/CartContext";
import type { Product } from "../../data/catalog";
import { products } from "../../data/catalog";
import { computeCartPricing } from "../../utils/cartPricing";
import { formatCurrency } from "../../utils/formatCurrency";
import flags from "../../constants/flags";
import { track } from "../../utils/telemetry";

const FONT_TITLE = "Arimo_400Regular";
const FONT_BODY = "OpenSans_400Regular";
const FONT_BODY_BOLD = "OpenSans_700Bold";

// ==== Regras congeladas do Carrinho (teste/UX) ====
// - Total em box laranja com letra preta
// - CTA verde musgo ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œContinuar a compraÃƒÂ¢Ã¢â€šÂ¬Ã‚Â (mais fino), texto 16 bold
const CTA_GREEN = "#2F5D3A";

// Frete grÃƒÆ’Ã‚Â¡tis (mock/UX nudge)
const FREE_SHIPPING_THRESHOLD = 199.9;

// Cupom mock
type Coupon =
  | { code: string; type: "percent"; value: number; label: string }
  | { code: string; type: "fixed"; value: number; label: string }
  | { code: string; type: "free_shipping"; value: 0; label: string };

const COUPONS: Coupon[] = [
  { code: "PLUGA10", type: "percent", value: 10, label: "10% OFF" },
  { code: "PLUGA20", type: "percent", value: 20, label: "20% OFF" },
  { code: "MENOS15", type: "fixed", value: 15, label: "R$ 15 OFF" },
  { code: "FRETE", type: "free_shipping", value: 0, label: "FRETE GRÃƒÆ’Ã‚ÂTIS" },
];

type ShippingMethod = "delivery" | "pickup";

type CartRow = {
  type: "cart";
  id: string;
  title: string;
  price: number;
  qty: number;
  category?: string;
  image?: string;
  description?: string;
  unitLabel?: string;
  discountPercent?: number;
};

type RecommendationRow = {
  type: "reco";
  id: string;
  title: string;
  price: number;
  image?: string;
};

type Row = CartRow | RecommendationRow;

type Section = {
  title: string;
  data: Row[];
};

type ProtectionPlan = { months: number; price: number; installments: number; recommended?: boolean };

function clampMoney(n: number) {
  if (!Number.isFinite(n)) return 0;
  return Math.max(0, n);
}

function normalizeCep(raw: string) {
  return String(raw ?? "").replace(/\D+/g, "").slice(0, 8);
}

function estimateShipping(cep8: string): number {
  if (!cep8 || cep8.length !== 8) return 0;

  const prefix = Number(cep8.slice(0, 2)) || 0;

  if (prefix <= 20) return 19.9;
  if (prefix <= 40) return 24.9;
  if (prefix <= 60) return 29.9;
  return 34.9;
}

function roundToCents(v: number) {
  if (!Number.isFinite(v)) return 0;
  return Math.round(v * 100) / 100;
}

// PreÃƒÆ’Ã‚Â§o final unitÃƒÆ’Ã‚Â¡rio considerando desconto do produto (nÃƒÆ’Ã‚Â£o do cupom)
function calcUnitWithProductDiscount(unit: number, discountPercent?: number) {
  const u = clampMoney(unit);
  const pct = Number(discountPercent ?? 0);
  if (!Number.isFinite(pct) || pct <= 0) return u;
  const d = (u * pct) / 100;
  return clampMoney(roundToCents(u - d));
}

function buildProtectionPlans(unitFinal: number): ProtectionPlan[] {
  const u = clampMoney(unitFinal);

  const p12 = roundToCents(Math.min(Math.max(u * 0.13, 9.9), 399));
  const p24 = roundToCents(Math.min(Math.max(u * 0.18, 14.9), 549));

  return [
    { months: 12, price: p12, installments: 10, recommended: true },
    { months: 24, price: p24, installments: 12 },
  ];
}

function softHaptic() {
  Vibration.vibrate(10);
}

function n(value: unknown) {
  const v = Number(value);
  return Number.isFinite(v) ? v : 0;
}

type RecoRowViewProps = {
  id: string;
  title: string;
  price: number;
  image?: string;
};

const RecoRowView = memo(function RecoRowView(props: RecoRowViewProps) {
  const { id, title, price, image } = props;

  const onPress = useCallback(() => {
    softHaptic();
    router.push(`/product/${id}`);
  }, [id]);

  return (
    <Pressable onPress={onPress} style={styles.recoRow}>
      <View style={styles.recoLeft}>
        <View style={styles.recoImageWrap}>
          {!!image ? <Image source={{ uri: image } as ImageSourcePropType} style={styles.recoImage} /> : null}
        </View>

        <View style={{ flex: 1 }}>
          <ThemedText style={styles.recoTitle}>{title}</ThemedText>
          <ThemedText style={styles.recoPrice}>{formatCurrency(price)}</ThemedText>
        </View>
      </View>

      <View style={styles.recoRight}>
        <Icon name="chevron.right" size={18} color={theme.colors.muted} />
      </View>
    </Pressable>
  );
});

type CartRowViewProps = {
  id: string;
  title: string;
  category?: string;
  unitLabel?: string;
  image?: string;
  qty: number;
  selected: boolean;
  unitFinal: number;
  totalRow: number;
  protectionMonths?: number;

  onToggleSelect: (id: string) => void;
  onRemoveItem: (id: string) => void;
  onDecQty: (id: string) => void;
  onIncQty: (id: string) => void;

  onRemoveProtection: (id: string) => void;
  onOpenProtection: (payload: { id: string; unitFinal: number }) => void;
};

const CartRowView = memo(function CartRowView(props: CartRowViewProps) {
  const {
    id,
    title,
    category,
    unitLabel,
    image,
    qty,
    selected,
    unitFinal,
    totalRow,
    protectionMonths,
    onToggleSelect,
    onRemoveItem,
    onDecQty,
    onIncQty,
    onRemoveProtection,
    onOpenProtection,
  } = props;

  const onPressSelect = useCallback(() => onToggleSelect(id), [id, onToggleSelect]);
  const onPressRemove = useCallback(() => onRemoveItem(id), [id, onRemoveItem]);
  const onPressDec = useCallback(() => onDecQty(id), [id, onDecQty]);
  const onPressInc = useCallback(() => onIncQty(id), [id, onIncQty]);
  const onPressRemoveProtection = useCallback(() => onRemoveProtection(id), [id, onRemoveProtection]);
  const onPressOpenProtection = useCallback(() => onOpenProtection({ id, unitFinal }), [id, onOpenProtection, unitFinal]);

  return (
    <ThemedView style={styles.itemCard}>
      <View style={styles.itemTop}>
        <Pressable onPress={onPressSelect} style={styles.checkWrap}>
          <View style={[styles.checkbox, selected && styles.checkboxOn]}>
            {selected ? <Icon name="check" size={14} color="#fff" /> : null}
          </View>
        </Pressable>

        <View style={styles.itemImageWrap}>{!!image ? <Image source={{ uri: image } as ImageSourcePropType} style={styles.itemImage} /> : null}</View>

        <View style={{ flex: 1 }}>
          <ThemedText style={styles.itemTitle}>{title}</ThemedText>
          {!!category ? <ThemedText style={styles.itemMeta}>{category}</ThemedText> : null}
          {!!unitLabel ? <ThemedText style={styles.itemMeta}>{unitLabel}</ThemedText> : null}
        </View>

        <Pressable onPress={onPressRemove} style={styles.trashBtn}>
          <Icon name="trash" size={18} color={theme.colors.muted} />
        </Pressable>
      </View>

      <View style={styles.itemBottom}>
        <View style={styles.qtyRow}>
          <Pressable onPress={onPressDec} style={styles.qtyBtn}>
            <ThemedText style={styles.qtyBtnText}>-</ThemedText>
          </Pressable>

          <View style={styles.qtyVal}>
            <ThemedText style={styles.qtyValText}>{qty}</ThemedText>
          </View>

          <Pressable onPress={onPressInc} style={styles.qtyBtn}>
            <ThemedText style={styles.qtyBtnText}>+</ThemedText>
          </Pressable>
        </View>

        <View style={styles.priceCol}>
          <ThemedText style={styles.unitPrice}>{formatCurrency(unitFinal)}</ThemedText>
          <ThemedText style={styles.rowTotal}>{formatCurrency(totalRow)}</ThemedText>
        </View>
      </View>

      <View style={styles.protectionRow}>
        <View style={{ flex: 1 }}>
          <ThemedText style={styles.protectionTitle}>ProteÃƒÆ’Ã‚Â§ÃƒÆ’Ã‚Â£o estendida</ThemedText>
          <ThemedText style={styles.protectionMeta}>{protectionMonths ? `${protectionMonths} meses selecionado` : "Opcional"}</ThemedText>
        </View>

        {protectionMonths ? (
          <Pressable onPress={onPressRemoveProtection} style={styles.protectionBtn}>
            <ThemedText style={styles.protectionBtnText}>Remover</ThemedText>
          </Pressable>
        ) : (
          <Pressable onPress={onPressOpenProtection} style={styles.protectionBtn}>
            <ThemedText style={styles.protectionBtnText}>Escolher</ThemedText>
          </Pressable>
        )}
      </View>
    </ThemedView>
  );
});

export default function CartScreen() {
  const cart = useCart();
  const isFocused = useIsFocused();

  const ffCartPerfV21 = !!flags.ff_cart_perf_v21;
  const ffCartTrackingV21 = !!flags.ff_cart_tracking_v21;

  const cartRef = useRef<any>(cart);
  useEffect(() => {
    cartRef.current = cart;
  }, [cart]);

  const prevFocusedRef = useRef<boolean>(false);

  const cartItemsSource = (cart as any)?.items;
const cartItems = useMemo(() => {
  const items = cartItemsSource ?? [];
  return Array.isArray(items) ? items : [];
}, [cartItemsSource]);

  const cartRows = useMemo<CartRow[]>(() => {
    return cartItems.map((it: any) => {
      const product = it?.product ?? it;

      const id = String(it?.id ?? product?.id ?? "");
      const title = String(it?.title ?? product?.title ?? "Produto");
      const price = n(it?.price ?? product?.price ?? 0);
      const qty = Math.max(1, Math.floor(n(it?.qty ?? 1)));
      const category = String(it?.category ?? product?.category ?? "");
      const image = (it?.image ?? product?.image ?? "") as string;
      const description = String(it?.description ?? product?.description ?? "");
      const unitLabel = String(it?.unitLabel ?? product?.unitLabel ?? "");
      const discountPercent = n(it?.discountPercent ?? product?.discountPercent ?? 0) || undefined;

      return {
        type: "cart",
        id,
        title,
        price,
        qty,
        category,
        image,
        description,
        unitLabel,
        discountPercent,
      };
    });
  }, [cartItems]);

  const hasCart = cartRows.length > 0;

  useEffect(() => {
    // view_cart: apenas na transiÃƒÆ’Ã‚Â§ÃƒÆ’Ã‚Â£o de foco (evita duplicar por re-render)
    if (ffCartTrackingV21 && isFocused && !prevFocusedRef.current) {
      track("view_cart", {
        items_count: cartRows.length,
        has_cart: cartRows.length > 0,
      });
    }
    prevFocusedRef.current = isFocused;
  }, [ffCartTrackingV21, isFocused, cartRows.length]);

  // SeleÃƒÆ’Ã‚Â§ÃƒÆ’Ã‚Â£o (checkbox)
  const [selected, setSelected] = useState<Record<string, boolean>>({});

  useEffect(() => {
    setSelected((prev) => {
      const next = { ...prev };
      for (const r of cartRows) {
        if (next[r.id] == null) next[r.id] = true;
      }
      for (const k of Object.keys(next)) {
        if (!cartRows.some((r) => r.id === k)) delete next[k];
      }
      return next;
    });
  }, [cartRows]);

  const toggleSelect = useCallback((id: string) => {
    softHaptic();
    setSelected((prev) => ({ ...prev, [id]: !prev[id] }));
  }, []);

  const allSelected = useMemo(() => {
    if (!cartRows.length) return false;
    return cartRows.every((r) => selected[r.id]);
  }, [cartRows, selected]);

  const toggleSelectAll = useCallback(() => {
    softHaptic();
    setSelected(() => {
      const next: Record<string, boolean> = {};
      const to = !allSelected;
      for (const r of cartRows) next[r.id] = to;
      return next;
    });
  }, [allSelected, cartRows]);

  // Frete / CEP
  const [shippingMethod, setShippingMethod] = useState<ShippingMethod>("delivery");
  const [cep, setCep] = useState<string>("");
  const cep8 = useMemo(() => normalizeCep(cep), [cep]);

  // Cupom
  const [couponInput, setCouponInput] = useState<string>("");
  const [appliedCoupon, setAppliedCoupon] = useState<Coupon | null>(null);
  const [couponMsg, setCouponMsg] = useState<string>("");
  const [footerHeight, setFooterHeight] = useState<number>(0);
  const applyCouponCode = useCallback((codeRaw: string) => {
    softHaptic();
    const code = String(codeRaw ?? "")
      .trim()
      .toUpperCase();

    if (!code) {
      setCouponMsg("Digite um cupom.");
      return;
    }

    const found = COUPONS.find((c) => c.code === code) ?? null;
    if (!found) {
      setAppliedCoupon(null);
      setCouponMsg("Cupom invÃƒÆ’Ã‚Â¡lido.");
      return;
    }

    setAppliedCoupon(found);
    setCouponMsg(`Cupom aplicado: ${found.code} (${found.label})`);
  }, []);

  const applyCoupon = useCallback(() => applyCouponCode(couponInput), [applyCouponCode, couponInput]);

  const clearCoupon = useCallback(() => {
    softHaptic();
    setAppliedCoupon(null);
    setCouponMsg("");
    setCouponInput("");
  }, []);

  // ProteÃƒÆ’Ã‚Â§ÃƒÆ’Ã‚Â£o (por item)
  const [protectionById, setProtectionById] = useState<Record<string, number | undefined>>({});
  const [modalFor, setModalFor] = useState<{ id: string; unitFinal: number } | null>(null);

  const openProtectionModalFor = useCallback((payload: { id: string; unitFinal: number }) => {
    softHaptic();
    setModalFor(payload);
  }, []);

  const closeProtectionModal = useCallback(() => {
    setModalFor(null);
  }, []);

  // ÃƒÂ¢Ã…â€œÃ¢â‚¬Â¦ FIX HARD: se perdeu foco (troca de aba / navegaÃƒÆ’Ã‚Â§ÃƒÆ’Ã‚Â£o), fecha Modal SEMPRE
  useEffect(() => {
    if (!isFocused) closeProtectionModal();
  }, [isFocused, closeProtectionModal]);

  // MantÃƒÆ’Ã‚Â©m tambÃƒÆ’Ã‚Â©m o cleanup por seguranÃƒÆ’Ã‚Â§a
  useFocusEffect(
    useCallback(() => {
      return () => {
        closeProtectionModal();
      };
    }, [closeProtectionModal])
  );

  const removeProtection = useCallback((id: string) => {
    softHaptic();
    setProtectionById((prev) => ({ ...prev, [id]: undefined }));
  }, []);

  const chooseProtection = useCallback(
    (id: string, months: number) => {
      softHaptic();
      setProtectionById((prev) => ({ ...prev, [id]: months }));
      closeProtectionModal();
    },
    [closeProtectionModal]
  );

  // RecomendaÃƒÆ’Ã‚Â§ÃƒÆ’Ã‚Âµes
  const recommendations = useMemo<RecommendationRow[]>(() => {
    const idsInCart = new Set(cartRows.map((r) => r.id));
    const recos = (products ?? []).filter((p: Product) => !idsInCart.has(String(p.id))).slice(0, 6);

    return recos.map((p: any) => ({
      type: "reco",
      id: String(p.id),
      title: String(p.title ?? "Produto"),
      price: n(p.price ?? 0),
      image: String(p.image ?? ""),
    }));
  }, [cartRows]);

  const unitFinalById = useMemo(() => {
    const map: Record<string, number> = {};
    for (const r of cartRows) {
      map[r.id] = calcUnitWithProductDiscount(r.price, r.discountPercent);
    }
    return map;
  }, [cartRows]);

  // ÃƒÂ¢Ã…â€œÃ¢â‚¬Â¦ MantÃƒÆ’Ã‚Â©m contrato real de CartPricingInput/Output do projeto
  const pricing = useMemo(() => {
    return computeCartPricing({
      rows: cartRows.map((r) => ({
        id: r.id,
        price: r.price,
        qty: r.qty,
        discountPercent: r.discountPercent,
      })),
      selectedById: selected,
      coupon: appliedCoupon as any,
      shippingMethod,
      cep8,
      freeShippingThreshold: FREE_SHIPPING_THRESHOLD,
      estimateShipping,
      protectionById,
      buildProtectionPlans,
      calcUnitWithProductDiscount,
    });
  }, [appliedCoupon, cartRows, cep8, protectionById, selected, shippingMethod]);

  const removeItem = useCallback((id: string) => {
    softHaptic();
    Alert.alert("Remover item", "Deseja remover este item do carrinho?", [
      { text: "Cancelar", style: "cancel" },
      {
        text: "Remover",
        style: "destructive",
        onPress: () => {
          if (ffCartTrackingV21) track("remove_from_cart", { id });
          cartRef.current?.remove?.(id);
        },
      },
    ]);
  }, [ffCartTrackingV21]);

  const incQty = useCallback((id: string) => {
    softHaptic();
    if (ffCartTrackingV21) track("update_qty", { id, delta: +1 });
    cartRef.current?.increment?.(id);
  }, [ffCartTrackingV21]);

  const decQty = useCallback((id: string) => {
    softHaptic();
    if (ffCartTrackingV21) track("update_qty", { id, delta: -1 });
    cartRef.current?.decrement?.(id);
  }, [ffCartTrackingV21]);

  const onContinue = useCallback(() => {
    if (ffCartTrackingV21) {
      track("click_checkout", { from: "cart" });
      track("checkout_start", { from: "cart" });
    }
    router.push("/checkout");
  }, [ffCartTrackingV21]);

  const sections = useMemo<Section[]>(() => {
    const s: Section[] = [];

    s.push({ title: "Produtos no carrinho", data: cartRows });

    if (recommendations.length) {
      s.push({ title: "Talvez VocÃƒÆ’Ã‚Âª goste", data: recommendations });
    }

    return s;
  }, [cartRows, recommendations]);

  const keyExtractor = useCallback((item: Row) => `${item.type}:${item.id}`, []);

  const renderSectionHeader = useCallback(({ section }: { section: Section }) => {
    return <ThemedText style={styles.sectionTitle}>{section.title}</ThemedText>;
  }, []);

  const renderItemLegacy = useCallback(
    ({ item }: { item: Row }) => {
      if (item.type === "reco") {
        return (
          <Pressable
            onPress={() => {
              softHaptic();
              router.push(`/product/${item.id}`);
            }}
            style={styles.recoRow}
          >
            <View style={styles.recoLeft}>
              <View style={styles.recoImageWrap}>
                {!!item.image ? (
                  <Image source={{ uri: item.image } as ImageSourcePropType} style={styles.recoImage} />
                ) : null}
              </View>

              <View style={{ flex: 1 }}>
                <ThemedText style={styles.recoTitle}>{item.title}</ThemedText>
                <ThemedText style={styles.recoPrice}>{formatCurrency(item.price)}</ThemedText>
              </View>
            </View>

            <View style={styles.recoRight}>
              <Icon name="chevron.right" size={18} color={theme.colors.muted} />
            </View>
          </Pressable>
        );
      }

      const unitFinal = unitFinalById[item.id] ?? item.price;
      const totalRow = roundToCents(unitFinal * item.qty);

      return (
        <ThemedView style={styles.itemCard}>
          <View style={styles.itemTop}>
            <Pressable onPress={() => toggleSelect(item.id)} style={styles.checkWrap}>
              <View style={[styles.checkbox, selected[item.id] && styles.checkboxOn]}>
                {selected[item.id] ? <Icon name="check" size={14} color="#fff" /> : null}
              </View>
            </Pressable>

            <View style={styles.itemImageWrap}>
              {!!item.image ? (
                <Image source={{ uri: item.image } as ImageSourcePropType} style={styles.itemImage} />
              ) : null}
            </View>

            <View style={{ flex: 1 }}>
              <ThemedText style={styles.itemTitle}>{item.title}</ThemedText>
              {!!item.category ? <ThemedText style={styles.itemMeta}>{item.category}</ThemedText> : null}
              {!!item.unitLabel ? <ThemedText style={styles.itemMeta}>{item.unitLabel}</ThemedText> : null}
            </View>

            <Pressable onPress={() => removeItem(item.id)} style={styles.trashBtn}>
              <Icon name="trash" size={18} color={theme.colors.muted} />
            </Pressable>
          </View>

          <View style={styles.itemBottom}>
            <View style={styles.qtyRow}>
              <Pressable onPress={() => decQty(item.id)} style={styles.qtyBtn}>
                <ThemedText style={styles.qtyBtnText}>-</ThemedText>
              </Pressable>

              <View style={styles.qtyVal}>
                <ThemedText style={styles.qtyValText}>{item.qty}</ThemedText>
              </View>

              <Pressable onPress={() => incQty(item.id)} style={styles.qtyBtn}>
                <ThemedText style={styles.qtyBtnText}>+</ThemedText>
              </Pressable>
            </View>

            <View style={styles.priceCol}>
              <ThemedText style={styles.unitPrice}>{formatCurrency(unitFinal)}</ThemedText>
              <ThemedText style={styles.rowTotal}>{formatCurrency(totalRow)}</ThemedText>
            </View>
          </View>

          <View style={styles.protectionRow}>
            <View style={{ flex: 1 }}>
              <ThemedText style={styles.protectionTitle}>ProteÃƒÆ’Ã‚Â§ÃƒÆ’Ã‚Â£o estendida</ThemedText>
              <ThemedText style={styles.protectionMeta}>
                {protectionById[item.id] ? `${protectionById[item.id]} meses selecionado` : "Opcional"}
              </ThemedText>
            </View>

            {protectionById[item.id] ? (
              <Pressable onPress={() => removeProtection(item.id)} style={styles.protectionBtn}>
                <ThemedText style={styles.protectionBtnText}>Remover</ThemedText>
              </Pressable>
            ) : (
              <Pressable onPress={() => openProtectionModalFor({ id: item.id, unitFinal })} style={styles.protectionBtn}>
                <ThemedText style={styles.protectionBtnText}>Escolher</ThemedText>
              </Pressable>
            )}
          </View>
        </ThemedView>
      );
    },
    [decQty, incQty, openProtectionModalFor, protectionById, removeItem, selected, toggleSelect, unitFinalById, removeProtection]
  );

  const renderItemOptimized = useCallback(
    ({ item }: { item: Row }) => {
      if (item.type === "reco") {
        return <RecoRowView id={item.id} title={item.title} price={item.price} image={item.image} />;
      }

      const unitFinal = unitFinalById[item.id] ?? item.price;
      const totalRow = roundToCents(unitFinal * item.qty);

      return (
        <CartRowView
          id={item.id}
          title={item.title}
          category={item.category}
          unitLabel={item.unitLabel}
          image={item.image}
          qty={item.qty}
          selected={!!selected[item.id]}
          unitFinal={unitFinal}
          totalRow={totalRow}
          protectionMonths={protectionById[item.id]}
          onToggleSelect={toggleSelect}
          onRemoveItem={removeItem}
          onDecQty={decQty}
          onIncQty={incQty}
          onRemoveProtection={removeProtection}
          onOpenProtection={openProtectionModalFor}
        />
      );
    },
    [decQty, incQty, openProtectionModalFor, protectionById, removeItem, selected, toggleSelect, unitFinalById, removeProtection]
  );

  const renderItem = ffCartPerfV21 ? renderItemOptimized : renderItemLegacy;

  return (
    <SafeAreaView style={styles.safe}>
      <ThemedView style={styles.container}>
        <View style={styles.header}>
          <View style={styles.headerTitleRow}>
            <Icon name="cart" size={20} color={theme.colors.text} style={styles.headerTitleIcon} />
            <ThemedText style={styles.headerTitle}>Carrinho</ThemedText>
          </View>

          <Pressable onPress={toggleSelectAll} style={styles.selectAllBtn}>
            <ThemedText style={styles.selectAllText}>{allSelected ? "Desmarcar" : "Selecionar"}</ThemedText>
          </Pressable>
        </View>

        <SectionList
          sections={sections}
          keyExtractor={keyExtractor}
          renderSectionHeader={renderSectionHeader}
          renderItem={renderItem}
          contentContainerStyle={[styles.listContent, { paddingBottom: footerHeight + 16 }]}
          stickySectionHeadersEnabled={false}
        />

        <ThemedView style={styles.footer} onLayout={(e) => setFooterHeight(e.nativeEvent.layout.height)}>
          {/* Total box laranja */}
          <ThemedView style={styles.totalBox}>
            <View style={styles.totalRow}>
              <ThemedText style={styles.totalLabel}>Subtotal</ThemedText>
              <ThemedText style={styles.totalValue}>{formatCurrency(pricing.subtotalAfterProductDiscount)}</ThemedText>
            </View>

            {!!pricing.discountTotal ? (
              <View style={styles.totalRow}>
                <ThemedText style={styles.totalLabel}>Descontos</ThemedText>
                <ThemedText style={styles.totalValue}>- {formatCurrency(pricing.discountTotal)}</ThemedText>
              </View>
            ) : null}

            {!!pricing.protectionTotal ? (
              <View style={styles.totalRow}>
                <ThemedText style={styles.totalLabel}>ProteÃƒÆ’Ã‚Â§ÃƒÆ’Ã‚Â£o</ThemedText>
                <ThemedText style={styles.totalValue}>{formatCurrency(pricing.protectionTotal)}</ThemedText>
              </View>
            ) : null}

            <View style={styles.totalRow}>
              <ThemedText style={styles.totalLabel}>Frete</ThemedText>
              <ThemedText style={styles.totalValue}>{pricing.shippingEstimated ? formatCurrency(pricing.shippingEstimated) : "ÃƒÂ¢Ã¢â€šÂ¬Ã¢â‚¬Â"}</ThemedText>
            </View>

            <View style={[styles.totalRow, { marginTop: 8 }]}>
              <ThemedText style={styles.totalLabelBig}>Total</ThemedText>
              <ThemedText style={styles.totalValueBig}>{formatCurrency(pricing.total)}</ThemedText>
            </View>

            <View style={styles.freeShipBarWrap}>
              <View style={styles.freeShipBarTrack}>
                <View style={[styles.freeShipBarFill, { width: `${Math.round(pricing.freeShippingProgress.ratio * 100)}%` }]} />
              </View>
              <ThemedText style={styles.freeShipText}>
                {pricing.freeShippingProgress.reached
                  ? "Frete grÃƒÆ’Ã‚Â¡tis desbloqueado!"
                  : `Faltam ${formatCurrency(pricing.freeShippingProgress.missing)} para frete grÃƒÆ’Ã‚Â¡tis`}
              </ThemedText>
            </View>
          </ThemedView>

          {/* Frete / CEP */}
          <ThemedView style={styles.shippingBox}>
            <ThemedText style={styles.shippingTitle}>Entrega</ThemedText>

            <View style={styles.shipMethodRow}>
              <Pressable
                onPress={() => {
                  softHaptic();
                  setShippingMethod("delivery");
                }}
                style={[styles.shipMethodBtn, shippingMethod === "delivery" && styles.shipMethodBtnOn]}
              >
                <ThemedText style={[styles.shipMethodText, shippingMethod === "delivery" && styles.shipMethodTextOn]}>Receber</ThemedText>
              </Pressable>

              <Pressable
                onPress={() => {
                  softHaptic();
                  setShippingMethod("pickup");
                }}
                style={[styles.shipMethodBtn, shippingMethod === "pickup" && styles.shipMethodBtnOn]}
              >
                <ThemedText style={[styles.shipMethodText, shippingMethod === "pickup" && styles.shipMethodTextOn]}>Retirar</ThemedText>
              </Pressable>
            </View>

            {shippingMethod === "delivery" ? (
              <View style={styles.cepRow}>
                <TextInput
                  value={cep}
                  onChangeText={setCep}
                  placeholder="Digite seu CEP"
                  placeholderTextColor={theme.colors.muted}
                  keyboardType="number-pad"
                  style={styles.cepInput}
                  maxLength={9}
                />
                <Pressable
                  onPress={() => {
                    softHaptic();
                    if (cep8.length !== 8) {
                      Alert.alert("CEP invÃƒÆ’Ã‚Â¡lido", "Digite um CEP com 8 dÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â­gitos.");
                      return;
                    }
                    setCep(cep8);
                  }}
                  style={styles.cepBtn}
                >
                  <ThemedText style={styles.cepBtnText}>OK</ThemedText>
                </Pressable>
              </View>
            ) : (
              <ThemedText style={styles.pickupText}>Retire em uma loja parceira prÃƒÆ’Ã‚Â³xima.</ThemedText>
            )}
          </ThemedView>

          {/* Cupom */}
          <ThemedView style={styles.couponBox}>
            <View style={styles.couponTop}>
              <ThemedText style={styles.couponTitle}>Cupom</ThemedText>
              {appliedCoupon ? (
                <Pressable onPress={clearCoupon} style={styles.couponClearBtn}>
                  <ThemedText style={styles.couponClearText}>Limpar</ThemedText>
                </Pressable>
              ) : null}
            </View>

            <View style={styles.couponRow}>
              <TextInput
                value={couponInput}
                onChangeText={setCouponInput}
                placeholder="Ex: PLUGA10"
                placeholderTextColor={theme.colors.muted}
                autoCapitalize="characters"
                style={styles.couponInput}
              />
              <Pressable onPress={applyCoupon} style={styles.couponBtn}>
                <ThemedText style={styles.couponBtnText}>Aplicar</ThemedText>
              </Pressable>
            </View>

            {!!couponMsg ? <ThemedText style={styles.couponMsg}>{couponMsg}</ThemedText> : null}
          </ThemedView>

          {/* CTA */}
          <Pressable onPress={onContinue} style={[styles.cta, !hasCart && styles.ctaDisabled]} disabled={!hasCart}>
            <ThemedText style={styles.ctaText}>Continuar a compra</ThemedText>
          </Pressable>
        </ThemedView>

        {/* Modal ProteÃƒÆ’Ã‚Â§ÃƒÆ’Ã‚Â£o */}
        <Modal visible={!!modalFor} transparent animationType="fade" onRequestClose={closeProtectionModal} onDismiss={closeProtectionModal}>
          <Pressable style={styles.modalOverlay} onPress={closeProtectionModal}>
            <Pressable style={styles.modalCard} onPress={() => null}>
              <View style={styles.modalHeader}>
                <ThemedText style={styles.modalTitle}>ProteÃƒÆ’Ã‚Â§ÃƒÆ’Ã‚Â£o estendida</ThemedText>
                <Pressable onPress={closeProtectionModal} style={styles.modalClose}>
                  <Icon name="x" size={18} color={theme.colors.muted} />
                </Pressable>
              </View>

              <ThemedText style={styles.modalSub}>Escolha um plano para este item.</ThemedText>

              <View style={styles.plansWrap}>
                {(modalFor ? buildProtectionPlans(modalFor.unitFinal) : []).map((p) => {
                  const months = p.months;
                  const isOn = !!modalFor && protectionById[modalFor.id] === months;

                  return (
                    <Pressable
                      key={months}
                      onPress={() => {
                        if (!modalFor) return;
                        chooseProtection(modalFor.id, months);
                      }}
                      style={[styles.planCard, isOn && styles.planCardOn, (p as any)?.recommended && styles.planCardRec]}
                    >
                      <View style={{ flex: 1 }}>
                        <ThemedText style={[styles.planTitle, isOn && styles.planTitleOn]}>{months} meses</ThemedText>
                        <ThemedText style={[styles.planMeta, isOn && styles.planMetaOn]}>
                          {formatCurrency(p.price)} ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¢ em atÃƒÆ’Ã‚Â© {(p as any).installments ?? 10}x
                        </ThemedText>
                      </View>

                      {isOn ? <Icon name="check" size={18} color="#fff" /> : <Icon name="chevron.right" size={18} color={theme.colors.muted} />}
                    </Pressable>
                  );
                })}
              </View>
            </Pressable>
          </Pressable>
        </Modal>
      </ThemedView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safe: { flex: 1, backgroundColor: theme.colors.background },
  container: { flex: 1, backgroundColor: theme.colors.background },

  header: {
    paddingHorizontal: 16,
    paddingTop: 8,
    paddingBottom: 10,
    borderBottomWidth: 1,
    borderBottomColor: theme.colors.border,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  headerTitleRow: { flexDirection: "row", alignItems: "center", gap: 8 },
  headerTitleIcon: { marginTop: 2 },
  headerTitle: { fontFamily: FONT_TITLE, fontSize: 18, color: theme.colors.text },
  selectAllBtn: { paddingVertical: 6, paddingHorizontal: 10, borderRadius: 12, backgroundColor: theme.colors.card },
  selectAllText: { fontFamily: FONT_BODY_BOLD, fontSize: 12, color: theme.colors.text },

  listContent: { paddingHorizontal: 16, paddingVertical: 12, paddingBottom: 260 },

  sectionTitle: {
    fontFamily: FONT_BODY_BOLD,
    fontSize: 13,
    color: theme.colors.text,
    marginTop: 8,
    marginBottom: 8,
  },

  // Reco
  recoRow: {
    backgroundColor: theme.colors.card,
    borderRadius: 16,
    padding: 12,
    marginBottom: 10,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  recoLeft: { flexDirection: "row", alignItems: "center", gap: 10, flex: 1 },
  recoImageWrap: { width: 42, height: 42, borderRadius: 12, backgroundColor: theme.colors.surface, overflow: "hidden" },
  recoImage: { width: 42, height: 42, resizeMode: "cover" },
  recoTitle: { fontFamily: FONT_BODY_BOLD, fontSize: 13, color: theme.colors.text },
  recoPrice: { fontFamily: FONT_BODY, fontSize: 12, color: theme.colors.muted, marginTop: 2 },
  recoRight: { marginLeft: 12 },

  // Item
  itemCard: {
    backgroundColor: theme.colors.card,
    borderRadius: 18,
    padding: 12,
    marginBottom: 10,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  itemTop: { flexDirection: "row", alignItems: "flex-start" },
  checkWrap: { paddingRight: 10, paddingTop: 4 },
  checkbox: {
    width: 20,
    height: 20,
    borderRadius: 6,
    borderWidth: 1.5,
    borderColor: theme.colors.border,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: "transparent",
  },
  checkboxOn: { backgroundColor: theme.colors.primary, borderColor: theme.colors.primary },
  itemImageWrap: { width: 54, height: 54, borderRadius: 16, backgroundColor: theme.colors.surface, overflow: "hidden", marginRight: 10 },
  itemImage: { width: 54, height: 54, resizeMode: "cover" },
  itemTitle: { fontFamily: FONT_BODY_BOLD, fontSize: 14, color: theme.colors.text },
  itemMeta: { fontFamily: FONT_BODY, fontSize: 12, color: theme.colors.muted, marginTop: 2 },
  trashBtn: { paddingLeft: 10, paddingTop: 2 },

  itemBottom: { flexDirection: "row", alignItems: "center", justifyContent: "space-between", marginTop: 10 },
  qtyRow: { flexDirection: "row", alignItems: "center" },
  qtyBtn: {
    width: 32,
    height: 32,
    borderRadius: 12,
    backgroundColor: theme.colors.surface,
    alignItems: "center",
    justifyContent: "center",
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  qtyBtnText: { fontFamily: FONT_BODY_BOLD, fontSize: 16, color: theme.colors.text },
  qtyVal: { width: 36, alignItems: "center", justifyContent: "center" },
  qtyValText: { fontFamily: FONT_BODY_BOLD, fontSize: 14, color: theme.colors.text },

  priceCol: { alignItems: "flex-end" },
  unitPrice: { fontFamily: FONT_BODY, fontSize: 12, color: theme.colors.muted },
  rowTotal: { fontFamily: FONT_BODY_BOLD, fontSize: 14, color: theme.colors.text, marginTop: 2 },

  protectionRow: {
    marginTop: 10,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    paddingTop: 10,
    borderTopWidth: 1,
    borderTopColor: theme.colors.border,
  },
  protectionTitle: { fontFamily: FONT_BODY_BOLD, fontSize: 13, color: theme.colors.text },
  protectionMeta: { fontFamily: FONT_BODY, fontSize: 12, color: theme.colors.muted, marginTop: 2 },
  protectionBtn: { paddingVertical: 8, paddingHorizontal: 12, borderRadius: 14, backgroundColor: theme.colors.surface, borderWidth: 1, borderColor: theme.colors.border },
  protectionBtnText: { fontFamily: FONT_BODY_BOLD, fontSize: 12, color: theme.colors.text },

  // Footer
  footer: {
    position: "absolute",
    left: 0,
    right: 0,
    bottom: 0,
    padding: 16,
    backgroundColor: theme.colors.background,
    borderTopWidth: 1,
    borderTopColor: theme.colors.border,
  },

  totalBox: {
    backgroundColor: "#F6A03A",
    borderRadius: 18,
    padding: 12,
    borderWidth: 1,
    borderColor: "rgba(0,0,0,0.06)",
  },
  totalRow: { flexDirection: "row", alignItems: "center", justifyContent: "space-between" },
  totalLabel: { fontFamily: FONT_BODY, fontSize: 12, color: "#111" },
  totalValue: { fontFamily: FONT_BODY_BOLD, fontSize: 12, color: "#111" },
  totalLabelBig: { fontFamily: FONT_BODY_BOLD, fontSize: 14, color: "#111" },
  totalValueBig: { fontFamily: FONT_BODY_BOLD, fontSize: 16, color: "#111" },

  freeShipBarWrap: { marginTop: 10 },
  freeShipBarTrack: { height: 8, borderRadius: 999, backgroundColor: "rgba(0,0,0,0.14)", overflow: "hidden" },
  freeShipBarFill: { height: 8, borderRadius: 999, backgroundColor: "rgba(0,0,0,0.28)" },
  freeShipText: { fontFamily: FONT_BODY_BOLD, fontSize: 12, color: "#111", marginTop: 6 },

  shippingBox: {
    marginTop: 10,
    backgroundColor: theme.colors.card,
    borderRadius: 18,
    padding: 12,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  shippingTitle: { fontFamily: FONT_BODY_BOLD, fontSize: 13, color: theme.colors.text, marginBottom: 10 },

  shipMethodRow: { flexDirection: "row", gap: 10 },
  shipMethodBtn: {
    flex: 1,
    borderRadius: 14,
    paddingVertical: 10,
    alignItems: "center",
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  shipMethodBtnOn: { backgroundColor: theme.colors.primary, borderColor: theme.colors.primary },
  shipMethodText: { fontFamily: FONT_BODY_BOLD, fontSize: 12, color: theme.colors.text },
  shipMethodTextOn: { color: "#fff" },

  cepRow: { flexDirection: "row", alignItems: "center", gap: 10, marginTop: 12 },
  cepInput: {
    flex: 1,
    height: 44,
    borderRadius: 14,
    paddingHorizontal: 12,
    borderWidth: 1,
    borderColor: theme.colors.border,
    backgroundColor: theme.colors.surface,
    color: theme.colors.text,
    fontFamily: FONT_BODY_BOLD,
  },
  cepBtn: {
    height: 44,
    paddingHorizontal: 14,
    borderRadius: 14,
    backgroundColor: theme.colors.primary,
    alignItems: "center",
    justifyContent: "center",
  },
  cepBtnText: { fontFamily: FONT_BODY_BOLD, fontSize: 12, color: "#fff" },
  pickupText: { fontFamily: FONT_BODY, fontSize: 12, color: theme.colors.muted, marginTop: 10 },

  couponBox: {
    marginTop: 10,
    backgroundColor: theme.colors.card,
    borderRadius: 18,
    padding: 12,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  couponTop: { flexDirection: "row", alignItems: "center", justifyContent: "space-between" },
  couponTitle: { fontFamily: FONT_BODY_BOLD, fontSize: 13, color: theme.colors.text },
  couponClearBtn: { paddingVertical: 6, paddingHorizontal: 10, borderRadius: 12, backgroundColor: theme.colors.surface, borderWidth: 1, borderColor: theme.colors.border },
  couponClearText: { fontFamily: FONT_BODY_BOLD, fontSize: 12, color: theme.colors.text },

  couponRow: { flexDirection: "row", alignItems: "center", gap: 10, marginTop: 10 },
  couponInput: {
    flex: 1,
    height: 44,
    borderRadius: 14,
    paddingHorizontal: 12,
    borderWidth: 1,
    borderColor: theme.colors.border,
    backgroundColor: theme.colors.surface,
    color: theme.colors.text,
    fontFamily: FONT_BODY_BOLD,
  },
  couponBtn: { height: 44, paddingHorizontal: 14, borderRadius: 14, backgroundColor: theme.colors.primary, alignItems: "center", justifyContent: "center" },
  couponBtnText: { fontFamily: FONT_BODY_BOLD, fontSize: 12, color: "#fff" },
  couponMsg: { fontFamily: FONT_BODY, fontSize: 12, color: theme.colors.muted, marginTop: 8 },

  cta: {
    marginTop: 10,
    height: 50,
    borderRadius: 18,
    backgroundColor: CTA_GREEN,
    alignItems: "center",
    justifyContent: "center",
  },
  ctaDisabled: { opacity: 0.5 },
  ctaText: { fontFamily: FONT_BODY_BOLD, fontSize: 16, color: "#fff" },

  // Modal
  modalOverlay: { flex: 1, backgroundColor: "rgba(0,0,0,0.45)", padding: 16, justifyContent: "center" },
  modalCard: { backgroundColor: theme.colors.card, borderRadius: 18, padding: 14, borderWidth: 1, borderColor: theme.colors.border },
  modalHeader: { flexDirection: "row", alignItems: "center", justifyContent: "space-between" },
  modalTitle: { fontFamily: FONT_BODY_BOLD, fontSize: 14, color: theme.colors.text },
  modalClose: { padding: 6 },
  modalSub: { fontFamily: FONT_BODY, fontSize: 12, color: theme.colors.muted, marginTop: 6 },

  plansWrap: { marginTop: 12, gap: 10 },
  planCard: { flexDirection: "row", alignItems: "center", justifyContent: "space-between", padding: 12, borderRadius: 16, backgroundColor: theme.colors.surface, borderWidth: 1, borderColor: theme.colors.border },
  planCardOn: { backgroundColor: theme.colors.primary, borderColor: theme.colors.primary },
  planCardRec: { borderColor: theme.colors.primary },
  planTitle: { fontFamily: FONT_BODY_BOLD, fontSize: 13, color: theme.colors.text },
  planTitleOn: { color: "#fff" },
  planMeta: { fontFamily: FONT_BODY, fontSize: 12, color: theme.colors.muted, marginTop: 2 },
  planMetaOn: { color: "rgba(255,255,255,0.92)" },
});





-----END TS-----

### FILE: app/(tabs)/index.tsx
### STATUS: OK
-----BEGIN TS-----
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useFocusEffect } from "@react-navigation/native";
import { router } from "expo-router";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import {
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
  type NativeScrollEvent,
  type NativeSyntheticEvent,
} from "react-native";

import HomeBannerStrip from "../../components/home/HomeBannerStrip";
import HomeGrid from "../../components/home/HomeGrid";
import HomeHeroCarousel from "../../components/home/HomeHeroCarousel";
import HomeQuickChips from "../../components/home/HomeQuickChips";
import HomeSectionHeader from "../../components/home/HomeSectionHeader";
import HomeSkeleton from "../../components/home/HomeSkeleton";
import HomeTrustRow from "../../components/home/HomeTrustRow";
import ParallaxScrollView from "../../components/ParallaxScrollView";
import { ProductCard } from "../../components/product-card";
import { FeatureFlags, getFeatureFlag } from "../../constants/featureFlags";
import { products } from "../../data/catalog";
import {
  trackHomeBlockImpression,
  trackHomeCategorySelect,
  trackHomeFail,
  trackHomeProductClick,
  trackHomeScrollDepth,
  trackHomeSearch,
  trackHomeStateRestore,
  trackHomeView,
} from "../../utils/homeAnalytics";

const ALL_CATEGORY = "Todas";
const HOME_FILTERS_KEY = "home:filters:v1";

export default function HomeScreen() {
  const [loading, setLoading] = useState(false);

  const [query, setQuery] = useState("");
  const [selectedCategory, setSelectedCategory] = useState<string>(ALL_CATEGORY);
  const [debouncedQuery, setDebouncedQuery] = useState("");
  const [homeFF, setHomeFF] = useState({ debounce: true, persist: true });

  const restoringRef = useRef(false);
  const lastTrackedSearchRef = useRef<string>("");
  const lastTrackedCategoryRef = useRef<string>(ALL_CATEGORY);

  const scrollYRef = useRef(0);
  const lastDepthBucketRef = useRef(0);
  const impressionsRef = useRef(new Set<string>());

  // evita usar "query stale" quando as flags carregam depois do usuÃ¡rio digitar
  const queryRef = useRef(query);
  useEffect(() => {
    queryRef.current = query;
  }, [query]);

  const categories = useMemo(() => {
    const set = new Set<string>();
    for (const p of products) {
      if (p.category) set.add(p.category);
    }
    return [ALL_CATEGORY, ...Array.from(set).sort()];
  }, []);

  useFocusEffect(
    useCallback(() => {
      void trackHomeView().catch(() => {});
      return () => {};
    }, [])
  );

  useEffect(() => {
    let mounted = true;

    Promise.all([
      getFeatureFlag(FeatureFlags.HOME_SEARCH_DEBOUNCE_V1),
      getFeatureFlag(FeatureFlags.HOME_PERSIST_FILTERS_V1),
    ])
      .then(([debounce, persist]) => {
        if (!mounted) return;
        setHomeFF({ debounce, persist });

        // Se debounce estiver OFF, sincroniza com a query atual (nÃ£o do first render)
        if (!debounce) setDebouncedQuery(queryRef.current);
      })
      .catch(() => {
        // MantÃ©m defaults.
      });

    return () => {
      mounted = false;
    };
  }, []);

  useEffect(() => {
    if (!homeFF.debounce) {
      setDebouncedQuery(query);
      return;
    }
    const t = setTimeout(() => setDebouncedQuery(query), 180);
    return () => clearTimeout(t);
  }, [homeFF.debounce, query]);

  useEffect(() => {
    if (!homeFF.persist) return;

    let active = true;
    restoringRef.current = true;

    (async () => {
      try {
        const raw = await AsyncStorage.getItem(HOME_FILTERS_KEY);
        if (!active) return;

        if (raw) {
          const parsed = JSON.parse(raw) as { query?: string; category?: string } | null;
          if (parsed?.query) setQuery(String(parsed.query));
          if (parsed?.category) setSelectedCategory(String(parsed.category));
          await trackHomeStateRestore({ restored: true });
        } else {
          await trackHomeStateRestore({ restored: false });
        }
      } catch {
        // ignore
      } finally {
        restoringRef.current = false;
      }
    })();

    return () => {
      active = false;
      restoringRef.current = false;
    };
  }, [homeFF.persist]);

  useEffect(() => {
    if (!homeFF.persist) return;
    if (restoringRef.current) return;

    const t = setTimeout(() => {
      void AsyncStorage.setItem(HOME_FILTERS_KEY, JSON.stringify({ query, category: selectedCategory })).catch(
        () => {}
      );
    }, 250);

    return () => clearTimeout(t);
  }, [homeFF.persist, query, selectedCategory]);

  useEffect(() => {
    if (restoringRef.current) return;

    const q = debouncedQuery.trim();
    if (q.length > 0 && q !== lastTrackedSearchRef.current) {
      lastTrackedSearchRef.current = q;
      void trackHomeSearch({ queryLen: q.length, hasCategory: selectedCategory !== ALL_CATEGORY }).catch(() => {});
    }
  }, [debouncedQuery, selectedCategory]);

  useEffect(() => {
    if (restoringRef.current) return;

    if (selectedCategory !== lastTrackedCategoryRef.current) {
      lastTrackedCategoryRef.current = selectedCategory;
      void trackHomeCategorySelect({ category: selectedCategory }).catch(() => {});
    }
  }, [selectedCategory]);

  const filteredProducts = useMemo(() => {
    const normalizedQuery = debouncedQuery.trim().toLowerCase();

    return products.filter((p) => {
      if (selectedCategory !== ALL_CATEGORY && p.category !== selectedCategory) return false;
      if (!normalizedQuery) return true;
      const hay = `${p.title} ${p.description ?? ""}`.toLowerCase();
      return hay.includes(normalizedQuery);
    });
  }, [debouncedQuery, selectedCategory]);

  const onOpenProduct = useCallback((productId: string, position?: number) => {
    void trackHomeProductClick({ productId, position }).catch(() => {});
    router.push({ pathname: "/product/[id]", params: { id: productId } });
  }, []);

  const onCategory = useCallback((cat: string) => {
    setSelectedCategory(cat);
  }, []);

  const onScroll = useCallback((y: number, contentH: number, viewportH: number) => {
    scrollYRef.current = y;

    const denom = Math.max(1, contentH - viewportH);
    const pct = Math.max(0, Math.min(100, Math.round((y / denom) * 100)));

    const bucket = pct >= 100 ? 100 : pct >= 75 ? 75 : pct >= 50 ? 50 : pct >= 25 ? 25 : 0;

    if (bucket > lastDepthBucketRef.current) {
      lastDepthBucketRef.current = bucket;
      void trackHomeScrollDepth(bucket).catch(() => {});
    }
  }, []);

  const impressionOnce = useCallback((blockId: string) => {
    if (impressionsRef.current.has(blockId)) return;
    impressionsRef.current.add(blockId);
    void trackHomeBlockImpression(blockId).catch(() => {});
  }, []);

  const retryTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  useEffect(() => {
    return () => {
      if (retryTimerRef.current) clearTimeout(retryTimerRef.current);
    };
  }, []);

  const onRetry = useCallback(() => {
    setLoading(true);
    if (retryTimerRef.current) clearTimeout(retryTimerRef.current);
    retryTimerRef.current = setTimeout(() => setLoading(false), 450);
  }, []);

  const onFailSafe = useCallback((message: string, code?: string) => {
    void trackHomeFail({ scope: "home_action", message, code }).catch(() => {});
  }, []);

  if (loading) return <HomeSkeleton />;

  return (
    <ParallaxScrollView
      headerBackgroundColor={{ light: "#0B0B0B", dark: "#0B0B0B" }}
      headerImage={<View style={{ height: 0 }} />}
      onScroll={(e: NativeSyntheticEvent<NativeScrollEvent>) => {
        const y = e.nativeEvent.contentOffset.y;
        const contentH = e.nativeEvent.contentSize.height;
        const viewportH = e.nativeEvent.layoutMeasurement.height;
        onScroll(y, contentH, viewportH);
      }}
      scrollEventThrottle={16}
    >
      <View style={styles.container}>
        <HomeHeroCarousel onImpression={() => impressionOnce("hero")} />
        <HomeBannerStrip onImpression={() => impressionOnce("banner_strip")} />
        <HomeTrustRow onImpression={() => impressionOnce("trust_row")} />

        <HomeSectionHeader title="Buscar" subtitle="Encontre produtos rapidamente" />
        <View style={styles.searchBox}>
          <TextInput
            placeholder="Buscar produtos..."
            placeholderTextColor="#6B6B6B"
            value={query}
            onChangeText={setQuery}
            style={styles.searchInput}
            autoCorrect={false}
            autoCapitalize="none"
          />
        </View>

        <HomeSectionHeader title="Categorias" subtitle="Explore por categoria" />
        <HomeQuickChips
          items={categories}
          selected={selectedCategory}
          onSelect={onCategory}
          onImpression={() => impressionOnce("categories")}
        />

        <HomeSectionHeader title="Vitrine" subtitle="SeleÃ§Ã£o do dia" />
        <HomeGrid onImpression={() => impressionOnce("grid")} />

        <HomeSectionHeader title="Produtos" subtitle="Baseado na sua busca" />
        <View style={styles.productsWrap}>
          {filteredProducts.map((p, idx) => (
            <ProductCard key={p.id} product={p} onPress={() => onOpenProduct(p.id, idx)} />
          ))}
        </View>

        <View style={styles.footerActions}>
          <TouchableOpacity style={styles.ghostBtn} onPress={onRetry}>
            <Text style={styles.ghostBtnText}>Recarregar</Text>
          </TouchableOpacity>
          <TouchableOpacity style={styles.ghostBtn} onPress={() => onFailSafe("cta_home_debug")}>
            <Text style={styles.ghostBtnText}>Debug</Text>
          </TouchableOpacity>
        </View>
      </View>
    </ParallaxScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    paddingHorizontal: 16,
    paddingTop: 12,
    paddingBottom: 28,
    gap: 16,
  },
  searchBox: {
    backgroundColor: "#121212",
    borderRadius: 14,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderWidth: 1,
    borderColor: "#1F1F1F",
  },
  searchInput: {
    color: "#fff",
    fontSize: 14,
  },
  productsWrap: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 12,
  },
  footerActions: {
    flexDirection: "row",
    gap: 10,
    justifyContent: "space-between",
    marginTop: 8,
  },
  ghostBtn: {
    flex: 1,
    height: 44,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: "#121212",
    borderWidth: 1,
    borderColor: "#1F1F1F",
  },
  ghostBtnText: {
    color: "#EAEAEA",
    fontWeight: "700",
  },
});

-----END TS-----

### FILE: app/checkout/review.tsx
### STATUS: OK
-----BEGIN TS-----
// app/checkout/review.tsx
import { router } from "expo-router";
import { useEffect, useMemo, useState } from "react";
import { Pressable, ScrollView, StyleSheet, View } from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";

import { ThemedText } from "../../components/themed-text";
import { ThemedView } from "../../components/themed-view";
import theme from "../../constants/theme";
import { useCart } from "../../context/CartContext";
import type { OrderDraft, Payment } from "../../types/order";
import { formatCurrency } from "../../utils/formatCurrency";
import { loadOrderDraft, saveOrderDraft } from "../../utils/orderStorage";

const FONT_TITLE = "Arimo_400Regular";
const FONT_BODY = "OpenSans_400Regular";
const FONT_BODY_BOLD = "OpenSans_700Bold";

function n(value: unknown) {
  const v = Number(value);
  return Number.isFinite(v) ? v : 0;
}

function calcFromCart(cartItems: any[]) {
  const subtotal = cartItems.reduce((acc, it) => {
    const price = n(it?.price ?? it?.product?.price);
    const qty = Math.max(1, Math.floor(n(it?.qty ?? 1)));
    return acc + price * qty;
  }, 0);

  const discount = cartItems.reduce((acc, it) => {
    const price = n(it?.price ?? it?.product?.price);
    const qty = Math.max(1, Math.floor(n(it?.qty ?? 1)));
    const pct = n(it?.discountPercent ?? it?.product?.discountPercent ?? 0);
    if (pct <= 0) return acc;
    return acc + price * (pct / 100) * qty;
  }, 0);

  const total = Math.max(0, subtotal - discount);

  return { subtotal, discount, total };
}

function toDraftItems(cartItems: any[]) {
  return (cartItems ?? []).map((it) => {
    const p = it?.product;
    return {
      id: String(it?.id ?? p?.id ?? p?.productId ?? `item_${Math.random().toString(16).slice(2)}`),
      title: String(p?.title ?? "Produto"),
      price: n(p?.price ?? 0),
      qty: Math.max(1, Math.floor(n(it?.qty ?? 1))),
      discountPercent: n(p?.discountPercent ?? 0) || undefined,
    };
  });
}

function nowISO() {
  return new Date().toISOString();
}

export default function Review() {
  const cartAny = useCart() as any;
  const goBack = () => router.back();

  const cartItems = useMemo(() => {
    const items = cartAny?.items ?? [];
    return Array.isArray(items) ? items : [];
  }, [cartAny?.items]);

  const computed = useMemo(() => calcFromCart(cartItems), [cartItems]);

  const [storedDraft, setStoredDraft] = useState<OrderDraft | null>(null);

  useEffect(() => {
    let alive = true;

    (async () => {
      try {
        const d = await loadOrderDraft();
        if (!alive) return;
        setStoredDraft(d);
      } catch {
        if (!alive) return;
        setStoredDraft(null);
      }
    })();

    return () => {
      alive = false;
    };
  }, []);

  const draft: OrderDraft = useMemo(() => {
    const baseItems = toDraftItems(cartItems);

    const base: OrderDraft = {
      v: 2,
      createdAt: nowISO(),
      items: baseItems,
      selectedItemIds: baseItems.map((it) => it.id),

      subtotal: n(computed.subtotal),
      discount: n(computed.discount),
      total: n(computed.total),
    };

    if (!storedDraft) return base;

    const hasItems = Array.isArray(storedDraft.items) && storedDraft.items.length > 0;
    const items = hasItems ? storedDraft.items : base.items;

    const subtotal: number = storedDraft.subtotal == null ? n(base.subtotal) : n(storedDraft.subtotal);
    const discount: number = storedDraft.discount == null ? n(base.discount) : n(storedDraft.discount);
    const shippingPrice: number = n(storedDraft.shipping?.price ?? 0);

    const total: number =
      storedDraft.total == null ? Math.max(0, subtotal - discount + shippingPrice) : Math.max(0, n(storedDraft.total));

    return {
      ...base,
      ...storedDraft,
      items,
      subtotal,
      discount,
      total,
    };
  }, [storedDraft, cartItems, computed.subtotal, computed.discount, computed.total]);

  const subtotal = useMemo(() => n(draft.subtotal ?? 0), [draft.subtotal]);
  const discount = useMemo(() => n(draft.discount ?? 0), [draft.discount]);
  const shipping = useMemo(() => n(draft.shipping?.price ?? 0), [draft.shipping?.price]);
  const total = useMemo(() => {
    const t = draft.total == null ? subtotal - discount + shipping : n(draft.total);
    return Math.max(0, t);
  }, [draft.total, subtotal, discount, shipping]);

  const [saving, setSaving] = useState(false);

  const handleConfirm = async () => {
    if (saving) return;

    setSaving(true);
    try {
      const fallbackPayment: Payment = { method: "pix", status: "pending" };

      const toSave: OrderDraft = {
        ...draft,
        payment: draft.payment ?? fallbackPayment,
      };

      await saveOrderDraft(toSave);
      router.push("/checkout/success");
    } finally {
      setSaving(false);
    }
  };

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: theme.colors.background }}>
      <ThemedView style={styles.container}>
        <View style={styles.header}>
          <Pressable onPress={goBack} style={styles.backBtn}>
            <ThemedText style={styles.backIcon}>â†</ThemedText>
          </Pressable>

          <ThemedText style={styles.title}>RevisÃ£o</ThemedText>

          <View style={styles.rightSpacer} />
        </View>

        <ScrollView contentContainerStyle={styles.content} showsVerticalScrollIndicator={false}>
          <View style={styles.card}>
            <ThemedText style={styles.sectionTitle}>Resumo</ThemedText>

            <View style={styles.summaryRow}>
              <ThemedText style={styles.summaryKey}>Subtotal</ThemedText>
              <ThemedText style={styles.summaryVal}>{formatCurrency(subtotal)}</ThemedText>
            </View>

            <View style={styles.summaryRow}>
              <ThemedText style={styles.summaryKey}>Descontos</ThemedText>
              <ThemedText style={styles.summaryVal}>-{formatCurrency(discount)}</ThemedText>
            </View>

            <View style={styles.summaryRow}>
              <ThemedText style={styles.summaryKey}>Frete</ThemedText>
              <ThemedText style={styles.summaryVal}>{formatCurrency(shipping)}</ThemedText>
            </View>

            <View style={styles.hr} />

            <View style={styles.summaryRow}>
              <ThemedText style={styles.totalKey}>Total</ThemedText>
              <ThemedText style={styles.totalVal}>{formatCurrency(total)}</ThemedText>
            </View>
          </View>

          <View style={{ height: 80 }} />
        </ScrollView>

        <View style={styles.footer}>
          <Pressable
            style={[styles.primaryBtn, saving && { opacity: 0.7 }]}
            onPress={handleConfirm}
            disabled={saving}
          >
            <ThemedText style={styles.primaryBtnText}>
              {saving ? "Confirmando..." : "Confirmar pedido"}
            </ThemedText>
          </Pressable>
        </View>
      </ThemedView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, paddingHorizontal: 14 },
  header: {
    height: 56,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  content: { paddingVertical: 14 },

  backBtn: { width: 40, height: 40, borderRadius: 999, alignItems: "center", justifyContent: "center" },
  backIcon: { fontSize: 22, fontFamily: FONT_BODY_BOLD },
  rightSpacer: { width: 40, height: 40 },
  title: { fontSize: 20, fontFamily: FONT_TITLE, textAlign: "center", fontWeight: "700" },

  card: {
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.border,
    borderRadius: 14,
    padding: 14,
    marginBottom: 10,
  },

  sectionTitle: { fontSize: 14, fontFamily: FONT_BODY_BOLD, marginBottom: 6 },

  summaryRow: { flexDirection: "row", justifyContent: "space-between", alignItems: "center", paddingVertical: 8 },
  summaryKey: { fontSize: 12, fontFamily: FONT_BODY, opacity: 0.85 },
  summaryVal: { fontSize: 12, fontFamily: FONT_BODY_BOLD, opacity: 0.9 },

  hr: { height: 1, backgroundColor: theme.colors.divider, marginVertical: 8 },

  totalKey: { fontSize: 12, fontFamily: FONT_BODY_BOLD, opacity: 0.9 },
  totalVal: { fontSize: 14, fontFamily: FONT_BODY_BOLD, opacity: 0.95 },

  footer: {
    position: "absolute",
    left: 14,
    right: 14,
    bottom: 10,
  },

  primaryBtn: {
    height: 48,
    borderRadius: 14,
    backgroundColor: theme.colors.primary,
    alignItems: "center",
    justifyContent: "center",
  },
  primaryBtnText: {
    color: "#fff",
    fontSize: 12,
    fontFamily: FONT_BODY_BOLD,
    textTransform: "uppercase",
  },
});

-----END TS-----

### FILE: app/orders/[id]/review.tsx
### STATUS: OK
-----BEGIN TS-----
// app/orders/[id]/review.tsx
import { router, useFocusEffect, useLocalSearchParams } from "expo-router";
import { useCallback, useMemo, useState } from "react";
import { Alert, Pressable, ScrollView, StyleSheet, TextInput, View } from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";

import { ThemedText } from "../../../components/themed-text";
import { ThemedView } from "../../../components/themed-view";
import theme, { Radius, Spacing } from "../../../constants/theme";
import type { Order } from "../../../utils/ordersStore";
import { getOrderById, setOrderReview } from "../../../utils/ordersStore";

function safeString(v: unknown) {
  if (typeof v === "string") return v;
  if (typeof v === "number") return String(v);
  return "";
}

export default function OrderReviewScreen() {
  const params = useLocalSearchParams();
  const orderId = safeString(params?.id);

  const [order, setOrder] = useState<Order | null>(null);
  const [stars, setStars] = useState<number>(5);
  const [comment, setComment] = useState<string>("");

  const load = useCallback(async () => {
    if (!orderId) {
      setOrder(null);
      return;
    }
    const found = await getOrderById(orderId);
    setOrder(found ?? null);

    if (found?.review) {
      setStars(found.review.stars);
      setComment(String(found.review.comment ?? ""));
    } else {
      setStars(5);
      setComment("");
    }
  }, [orderId]);

  useFocusEffect(
    useCallback(() => {
      load();
    }, [load])
  );

  const starsLabel = useMemo(() => `${stars} estrela(s)`, [stars]);

  const save = async () => {
    if (!orderId) return;

    const updated = await setOrderReview(orderId, stars, comment);
    if (!updated) {
      Alert.alert("AvaliaÃ§Ã£o", "NÃ£o foi possÃ­vel salvar sua avaliaÃ§Ã£o.");
      return;
    }
    Alert.alert("AvaliaÃ§Ã£o", "AvaliaÃ§Ã£o salva com sucesso!");
    router.back();
  };

  return (
    <SafeAreaView edges={["top", "left", "right"]} style={styles.safe}>
      <ThemedView style={styles.container}>
        <View style={styles.topbar}>
          <Pressable onPress={() => router.back()} hitSlop={12} style={styles.backBtn}>
            <ThemedText style={styles.backArrow}>â†</ThemedText>
          </Pressable>

          <ThemedText style={styles.title}>Avaliar compra</ThemedText>

          <View style={{ width: 44 }} />
        </View>

        <ScrollView contentContainerStyle={styles.scroll} showsVerticalScrollIndicator={false}>
          <ThemedView style={styles.card}>
            <ThemedText style={styles.cardTitle}>Pedido #{orderId}</ThemedText>
            <ThemedText style={styles.secondary}>
              {order?.review
                ? "VocÃª jÃ¡ avaliou este pedido. Pode atualizar a qualquer momento."
                : "Conte como foi sua experiÃªncia."}
            </ThemedText>

            <View style={styles.divider} />

            <ThemedText style={styles.sectionTitle}>Sua nota</ThemedText>

            <View style={styles.starsRow}>
              {[1, 2, 3, 4, 5].map((n) => {
                const active = n <= stars;
                return (
                  <Pressable
                    key={n}
                    onPress={() => setStars(n)}
                    style={[styles.starPill, active ? styles.starActive : styles.starIdle]}
                  >
                    <ThemedText style={[styles.starText, active ? styles.starTextActive : styles.starTextIdle]}>
                      â˜…
                    </ThemedText>
                  </Pressable>
                );
              })}
              <ThemedText style={styles.secondary}>{starsLabel}</ThemedText>
            </View>

            <ThemedText style={styles.sectionTitle}>ComentÃ¡rio</ThemedText>

            <TextInput
              value={comment}
              onChangeText={setComment}
              placeholder="Escreva um comentÃ¡rio (opcional)"
              placeholderTextColor={"rgba(0,0,0,0.45)"}
              style={styles.input}
              multiline
              textAlignVertical="top"
            />

            <Pressable onPress={save} style={styles.primaryBtn}>
              <ThemedText style={styles.primaryBtnText}>Salvar avaliaÃ§Ã£o</ThemedText>
            </Pressable>
          </ThemedView>

          <View style={{ height: 24 }} />
        </ScrollView>
      </ThemedView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safe: { flex: 1, backgroundColor: theme.colors.background },
  container: { flex: 1, paddingHorizontal: Spacing.lg, paddingBottom: Spacing.lg },

  topbar: {
    height: 54,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: Spacing.md,
  },
  backBtn: {
    width: 44,
    height: 44,
    borderRadius: 999,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.divider,
  },
  backArrow: { fontFamily: "Arimo", fontSize: 22, fontWeight: "700", color: theme.colors.text },
  title: { fontFamily: "Arimo", fontSize: 20, fontWeight: "700", color: theme.colors.text },

  scroll: { gap: Spacing.md, paddingBottom: 20 },

  card: {
    backgroundColor: theme.colors.surface,
    borderRadius: Radius.xl,
    borderWidth: 1,
    borderColor: theme.colors.divider,
    padding: Spacing.lg,
    gap: Spacing.md,
  },
  cardTitle: { fontFamily: "Arimo", fontSize: 18, fontWeight: "700", color: theme.colors.text },

  divider: { height: 1, backgroundColor: theme.colors.divider, width: "100%", marginVertical: 6 },

  sectionTitle: { fontFamily: "OpenSans", fontSize: 12, fontWeight: "700", color: theme.colors.text },
  secondary: { fontFamily: "OpenSans", fontSize: 12, color: "rgba(0,0,0,0.65)" },

  starsRow: { flexDirection: "row", alignItems: "center", gap: 10, flexWrap: "wrap" },
  starPill: {
    width: 38,
    height: 38,
    borderRadius: 999,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
  },
  starIdle: { backgroundColor: theme.colors.surface, borderColor: theme.colors.divider },
  starActive: { backgroundColor: theme.colors.primary, borderColor: theme.colors.primary },
  starText: { fontFamily: "OpenSans", fontSize: 16, fontWeight: "700" },
  starTextIdle: { color: theme.colors.text },
  starTextActive: { color: "#FFFFFF" },

  input: {
    minHeight: 110,
    borderRadius: Radius.lg,
    borderWidth: 1,
    borderColor: theme.colors.divider,
    backgroundColor: theme.colors.surface,
    paddingHorizontal: 12,
    paddingVertical: 10,
    fontFamily: "OpenSans",
    fontSize: 12,
    color: theme.colors.text,
  },

  primaryBtn: {
    paddingVertical: 12,
    borderRadius: Radius.lg,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.primary,
    marginTop: 6,
  },
  primaryBtnText: { fontFamily: "OpenSans", fontSize: 16, fontWeight: "700", color: "#FFFFFF" },
});

-----END TS-----

### FILE: types/order.ts
### STATUS: OK
-----BEGIN TS-----
// types/order.ts

/**
 * Compatibilidade com utils/orderDraftBuilder.ts e fluxo antigo
 * - Exporta Address, Payment, Shipping
 * - OrderDraft inclui campos legados: subtotal/discount/total/note (opcionais)
 * - MantÃ©m Etapa 21: coupon + pricing snapshot + selectedItemIds + protectionById
 */

export type Address = {
  fullName?: string;
  phone?: string;

  cep?: string;
  cep8?: string;

  street?: string;
  number?: string;
  complement?: string;
  neighborhood?: string;

  city?: string;
  state?: string;

  reference?: string;
};

export type Payment = {
  method: "pix" | "card" | "boleto" | "cash" | "other";
  brand?: string; // ex: visa/master
  last4?: string;
  installments?: number;
};

export type Shipping = {
  method: "delivery" | "pickup";
  cep8: string;
  price: number;
  carrier?: string;
  etaDays?: number;
};

export type OrderItem = {
  id: string;
  title: string;
  price: number;
  qty: number;
  discountPercent?: number;
};

export type OrderCoupon =
  | { code: string; type: "percent"; value: number }
  | { code: string; type: "fixed"; value: number }
  | { code: string; type: "free_shipping"; value: 0 };

export type OrderPricingSnapshot = {
  subtotalRaw: number;
  productDiscountTotal: number;
  couponDiscount: number;
  protectionTotal: number;
  shippingEstimated: number;
  discountTotal: number;
  total: number;
};

export type OrderDraft = {
  /** Compat: alguns fluxos criam um draft com id */
  id?: string;

  /** versionamento do draft */
  v: 2;
  createdAt: string;

  items: OrderItem[];
  selectedItemIds: string[];

  coupon?: OrderCoupon | null;

  /** Compat: seu projeto pode estar usando Shipping/Address/Payment diretamente no draft */
  shipping?: Shipping | null;
  address?: Address | null;
  payment?: Payment | null;

  protectionById?: Record<string, number>;

  /**
   * Etapa 21 (novo): snapshot completo e determinÃ­stico.
   * Deve ser a source of truth do checkout quando existir.
   */
  pricing?: OrderPricingSnapshot;

  /** opcional: hash simples para debug/observabilidade */
  pricingHash?: string;

  /**
   * Campos legados (compat com orderDraftBuilder.ts)
   * Mantidos como opcionais para nÃ£o quebrar cÃ³digo antigo.
   */
  subtotal?: number;
  discount?: number;
  total?: number;

  /** ObservaÃ§Ã£o/nota do pedido (campo legado) */
  note?: string;
};

-----END TS-----

### TSC: START
-----BEGIN TSC-----
app/(tabs)/index.tsx(236,7): error TS2322: Type '{ children: Element; headerBackgroundColor: { light: string; dark: string; }; headerImage: Element; onScroll: (e: NativeSyntheticEvent<NativeScrollEvent>) => void; scrollEventThrottle: number; }' is not assignable to type 'IntrinsicAttributes & { headerImage: ReactElement<unknown, string | JSXElementConstructor<any>>; headerBackgroundColor: { ...; }; scrollViewProps?: Omit<...> | undefined; } & { ...; }'.
  Property 'onScroll' does not exist on type 'IntrinsicAttributes & { headerImage: ReactElement<unknown, string | JSXElementConstructor<any>>; headerBackgroundColor: { ...; }; scrollViewProps?: Omit<...> | undefined; } & { ...; }'.
app/checkout/review.tsx(144,57): error TS2353: Object literal may only specify known properties, and 'status' does not exist in type 'Payment'.
hooks/useHomeScreenTelemetry.ts(14,13): error TS2345: Argument of type '"view_home"' is not assignable to parameter of type 'TelemetryEvent'.
hooks/useHomeScreenTelemetry.ts(22,13): error TS2345: Argument of type '"click_home"' is not assignable to parameter of type 'TelemetryEvent'.
hooks/useHomeScreenTelemetry.ts(30,13): error TS2345: Argument of type '"fail_home"' is not assignable to parameter of type 'TelemetryEvent'.
hooks/useOrdersAutoProgress.ts(4,15): error TS2305: Module '"../types/order"' has no exported member 'Order'.
src/cart/useCartRows.ts(14,26): error TS2339: Property 'title' does not exist on type 'CartItem'.
src/cart/useCartRows.ts(15,26): error TS2339: Property 'price' does not exist on type 'CartItem'.
src/cart/useCartRows.ts(17,33): error TS2339: Property 'image' does not exist on type 'CartItem'.
src/cart/useCartRows.ts(18,36): error TS2339: Property 'discountPercent' does not exist on type 'CartItem'.
src/cart/useCartRows.ts(19,30): error TS2339: Property 'unitLabel' does not exist on type 'CartItem'.
types/orderPayload.ts(1,15): error TS2305: Module '"./order"' has no exported member 'Order'.
utils/orderExport.ts(1,15): error TS2305: Module '"../types/order"' has no exported member 'Order'.
utils/orderNotifier.ts(2,15): error TS2305: Module '"../types/order"' has no exported member 'Order'.
utils/orderPayloadBuilder.ts(1,15): error TS2305: Module '"../types/order"' has no exported member 'Order'.
utils/orderStatus.ts(2,15): error TS2305: Module '"../types/order"' has no exported member 'Order'.
utils/orderStatus.ts(13,20): error TS2339: Property 'status' does not exist on type 'Payment'.
utils/orderTimelineAuto.ts(2,15): error TS2305: Module '"../types/order"' has no exported member 'Order'.
utils/paymentBridge.ts(30,20): error TS2353: Object literal may only specify known properties, and 'status' does not exist in type 'Payment'.
utils/paymentMock.ts(6,5): error TS2353: Object literal may only specify known properties, and 'status' does not exist in type 'Payment'.
utils/shippingMock.ts(10,73): error TS2353: Object literal may only specify known properties, and 'deadline' does not exist in type 'Shipping'.
utils/shippingMock.ts(18,5): error TS2353: Object literal may only specify known properties, and 'deadline' does not exist in type 'Shipping'.
utils/shippingService.ts(22,85): error TS2353: Object literal may only specify known properties, and 'deadline' does not exist in type 'ShippingOption'.
utils/shippingService.ts(23,89): error TS2353: Object literal may only specify known properties, and 'deadline' does not exist in type 'ShippingOption'.
utils/shippingService.ts(24,93): error TS2353: Object literal may only specify known properties, and 'deadline' does not exist in type 'ShippingOption'.
utils/shippingService.ts(31,82): error TS2353: Object literal may only specify known properties, and 'deadline' does not exist in type 'ShippingOption'.
utils/shippingService.ts(32,93): error TS2353: Object literal may only specify known properties, and 'deadline' does not exist in type 'ShippingOption'.
utils/shippingService.ts(33,97): error TS2353: Object literal may only specify known properties, and 'deadline' does not exist in type 'ShippingOption'.

-----END TSC-----
### TSC: END





===== PATH: scripts\ai\bootstrap_patch_repo.ps1 =====
# scripts/ai/bootstrap_patch_repo.ps1
# PS 5.1-safe. NÃO usa MyInvocation.
# Sempre gera scripts/ai/patch_repo.py em UTF-8 sem BOM e valida com py_compile.

$ErrorActionPreference = "Stop"

function Write-Utf8NoBomFile {
  param(
    [Parameter(Mandatory=$true)][string]$Path,
    [Parameter(Mandatory=$true)][string]$Content
  )
  $dir = Split-Path -Parent $Path
  if (-not (Test-Path $dir)) { New-Item -ItemType Directory -Force $dir | Out-Null }

  $utf8NoBom = New-Object System.Text.UTF8Encoding($false)
  [System.IO.File]::WriteAllText($Path, $Content, $utf8NoBom)
}

function Get-ScriptDir {
  if ($PSScriptRoot -and $PSScriptRoot.Length -gt 0) { return $PSScriptRoot }
  if ($PSCommandPath -and $PSCommandPath.Length -gt 0) { return (Split-Path -Parent $PSCommandPath) }
  return (Get-Location).Path
}

$scriptDir = Get-ScriptDir
$repoRoot  = Resolve-Path (Join-Path $scriptDir "..\..")
$aiDir     = Join-Path $repoRoot "scripts\ai"
New-Item -ItemType Directory -Force $aiDir | Out-Null

$py = Get-Command python -ErrorAction SilentlyContinue
if (-not $py) { throw "python não encontrado no PATH." }

$patchRepo = Join-Path $aiDir "patch_repo.py"

# Conteúdo do patch_repo.py (PYTHON PURO). Sem PowerShell aqui dentro.
$pyContent = @'
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from __future__ import annotations

import argparse
import re
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, Optional

ROOT = Path(__file__).resolve().parents[2]

@dataclass(frozen=True)
class PatchResult:
    path: Path
    changed: bool
    reason: str

def read_text(p: Path) -> Optional[str]:
    if not p.exists():
        return None
    return p.read_text(encoding="utf-8", errors="replace")

def write_text(p: Path, s: str) -> None:
    s = s.replace("\r\n", "\n")
    p.parent.mkdir(parents=True, exist_ok=True)
    with p.open("w", encoding="utf-8", errors="replace", newline="\n") as f:
        f.write(s)

def ensure_field_in_export_type(ts: str, type_name: str, field_line: str) -> tuple[str, bool]:
    m = re.search(rf"(export\s+type\s+{re.escape(type_name)}\s*=\s*\{{)([\s\S]*?)(\n\}};)", ts)
    if not m:
        return ts, False
    head, body, tail = m.group(1), m.group(2), m.group(3)

    field_name = field_line.strip().split(":")[0].strip()
    if re.search(rf"\n\s*{re.escape(field_name)}\s*:", body):
        return ts, False

    new_body = body.rstrip() + "\n  " + field_line.rstrip() + "\n"
    out = ts[:m.start()] + head + new_body + tail + ts[m.end():]
    return out, True

def ensure_exported_order_type(ts: str) -> tuple[str, bool]:
    if re.search(r"export\s+type\s+Order\s*=", ts):
        return ts, False

    insert = """
export type Order = {
  id: string;
  createdAt: string;

  items: OrderItem[];
  selectedItemIds: string[];

  coupon?: OrderCoupon | null;

  shipping?: Shipping | null;
  address?: Address | null;
  payment?: Payment | null;

  protectionById?: Record<string, number>;

  pricing?: OrderPricingSnapshot;
  pricingHash?: string;

  subtotal?: number;
  discount?: number;
  total?: number;

  note?: string;

  status?: "created" | "paid" | "shipped" | "delivered" | "canceled" | string;
  review?: { stars: number; comment?: string } | null;
};
""".lstrip("\n")

    m = re.search(r"(export\s+type\s+OrderDraft\s*=\s*\{[\s\S]*?\n\};)", ts)
    if m:
        out = ts[:m.end()] + "\n\n" + insert + "\n" + ts[m.end():]
        return out, True

    return ts.rstrip() + "\n\n" + insert + "\n", True

def patch_parallax_scrollview_props(ts: str) -> tuple[str, bool]:
    if "scrollViewProps=" in ts:
        return ts, False

    pat = re.compile(
        r"(ParallaxScrollView[\s\S]*?\n)(\s*)onScroll=\{(\([\s\S]*?\})\}\s*\n\2scrollEventThrottle=\{(\d+)\}",
        re.M,
    )
    m = pat.search(ts)
    if not m:
        return ts, False

    before = m.group(1)
    indent = m.group(2)
    onscroll_body = m.group(3)
    throttle = m.group(4)

    repl = (
        f"{before}"
        f"{indent}scrollViewProps={{{{\n"
        f"{indent}  onScroll: {onscroll_body},\n"
        f"{indent}  scrollEventThrottle: {throttle},\n"
        f"{indent}}}}}"
    )
    out = ts[:m.start()] + repl + ts[m.end():]
    return out, True

def patch_useHomeScreenTelemetry_cast(ts: str) -> tuple[str, bool]:
    changed = False
    out = ts
    for ev in ["view_home", "click_home", "fail_home"]:
        out2 = re.sub(rf'track\("{ev}"\s*,', f'track("{ev}" as any,', out)
        if out2 != out:
            changed = True
            out = out2
    return out, changed

def patch_cart_rows_cartitem_product(ts: str) -> tuple[str, bool]:
    changed = False
    out = ts
    replacements = [
        (r"\bit\.title\b", "it.product?.title"),
        (r"\bit\.price\b", "it.product?.price"),
        (r"\bit\.image\b", "it.product?.image"),
        (r"\bit\.discountPercent\b", "it.product?.discountPercent"),
        (r"\bit\.unitLabel\b", "it.product?.unitLabel"),
    ]
    for a, b in replacements:
        out2 = re.sub(a, b, out)
        if out2 != out:
            changed = True
            out = out2
    return out, changed

def ensure_shipping_option_deadline_in_file(ts: str) -> tuple[str, bool]:
    m = re.search(r"(export\s+type\s+ShippingOption\s*=\s*\{)([\s\S]*?)(\n\};)", ts)
    if not m:
        m = re.search(r"(type\s+ShippingOption\s*=\s*\{)([\s\S]*?)(\n\};)", ts)
    if not m:
        return ts, False

    head, body, tail = m.group(1), m.group(2), m.group(3)
    if re.search(r"\n\s*deadline\s*:", body):
        return ts, False

    new_body = body.rstrip() + "\n  deadline?: string;\n"
    out = ts[:m.start()] + head + new_body + tail + ts[m.end():]
    return out, True

def find_files_containing(pattern: str, roots: Iterable[Path]) -> list[Path]:
    hits: list[Path] = []
    rx = re.compile(pattern)
    for r in roots:
        if not r.exists():
            continue
        for p in r.rglob("*.ts"):
            try:
                t = p.read_text(encoding="utf-8", errors="replace")
            except Exception:
                continue
            if rx.search(t):
                hits.append(p)
        for p in r.rglob("*.tsx"):
            try:
                t = p.read_text(encoding="utf-8", errors="replace")
            except Exception:
                continue
            if rx.search(t):
                hits.append(p)

    uniq: list[Path] = []
    seen: set[str] = set()
    for p in hits:
        k = str(p.resolve()).lower()
        if k in seen:
            continue
        seen.add(k)
        uniq.append(p)
    return uniq

def apply() -> list[PatchResult]:
    results: list[PatchResult] = []

    order_ts = ROOT / "types" / "order.ts"
    t = read_text(order_ts)
    if t is not None:
        t2, c1 = ensure_field_in_export_type(t, "Payment", 'status?: "pending" | "paid" | "failed";')
        t3, c2 = ensure_field_in_export_type(t2, "Shipping", "deadline?: string;")
        t4, c3 = ensure_exported_order_type(t3)
        if c1 or c2 or c3:
            write_text(order_ts, t4)
            results.append(PatchResult(order_ts, True, "order/payment/shipping types"))

    home = ROOT / "app" / "(tabs)" / "index.tsx"
    t = read_text(home)
    if t is not None:
        t2, c = patch_parallax_scrollview_props(t)
        if c:
            write_text(home, t2)
            results.append(PatchResult(home, True, "parallax scrollViewProps"))

    telem_hook = ROOT / "hooks" / "useHomeScreenTelemetry.ts"
    t = read_text(telem_hook)
    if t is not None:
        t2, c = patch_useHomeScreenTelemetry_cast(t)
        if c:
            write_text(telem_hook, t2)
            results.append(PatchResult(telem_hook, True, "cast telemetry events"))

    cart_rows = ROOT / "src" / "cart" / "useCartRows.ts"
    t = read_text(cart_rows)
    if t is not None:
        t2, c = patch_cart_rows_cartitem_product(t)
        if c:
            write_text(cart_rows, t2)
            results.append(PatchResult(cart_rows, True, "cart item -> product fields"))

    candidates = find_files_containing(r"type\s+ShippingOption\s*=", [ROOT / "types", ROOT / "utils", ROOT])
    for p in candidates[:5]:
        tt = read_text(p)
        if tt is None:
            continue
        tt2, c = ensure_shipping_option_deadline_in_file(tt)
        if c:
            write_text(p, tt2)
            results.append(PatchResult(p, True, "ShippingOption.deadline"))
            break

    return results

def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--apply", action="store_true", help="apply patches")
    args = ap.parse_args()

    if args.apply:
        res = apply()
        changed = [r for r in res if r.changed]
        print(f"[patch_repo] changed={len(changed)}")
        for r in changed:
            print(f" - {r.path.relative_to(ROOT)} ({r.reason})")
        return 0

    ap.print_help()
    return 2

if __name__ == "__main__":
    raise SystemExit(main())
'@

Write-Host "[bootstrap] Writing patch_repo.py (utf8 no bom): $patchRepo"
Write-Utf8NoBomFile -Path $patchRepo -Content $pyContent

Write-Host "[bootstrap] Validating python syntax..."
python -m py_compile $patchRepo
if ($LASTEXITCODE -ne 0) { throw "py_compile failed" }

Write-Host "[bootstrap] OK"
Write-Host "Run: python scripts/ai/patch_repo.py --apply"



===== PATH: scripts\ai\CORRECAO_CARRINHO_PERFORMANCE_3.md =====
# Correção Carrinho e Performance 3

## Objetivo
Eliminar erros de TypeScript relacionados a:
- `ParallaxScrollView` (props de scroll)
- Contrato de tipos de Pedido (`Order`, `Payment.status`, `Shipping.method`)
- Contrato de itens do carrinho (`CartItem` -> `CartRow` via `product`)

## Regras
- Layout congelado (sem mudanças visuais)
- Incremental (sem reescrever do zero)
- Prompt Zero (toda correção baseada em arquivos completos)

## Escopo desta rodada
### Fixes
1. Home (`app/(tabs)/index.tsx`)
   - mover `onScroll` e `scrollEventThrottle` para `scrollViewProps` (contrato do `ParallaxScrollView`)

2. Tipos de Pedido (`types/order.ts`)
   - adicionar `PaymentStatus` e `Payment.status?`
   - ampliar `Shipping.method` para aceitar labels usados pelos mocks/serviços (sem impacto em runtime)
   - adicionar `Shipping.deadline?`
   - exportar `Order` (consumido por hooks/utils/payload)

3. Carrinho (`src/cart/useCartRows.ts`)
   - alinhar `CartItem` com source-of-truth: `CartItem.product.*`
   - remover acessos inexistentes (`it.title/price/image/...`)

## Comandos Git (PowerShell)
```powershell
git add -- "app/(tabs)/index.tsx" "types/order.ts" "src/cart/useCartRows.ts" "scripts/ai/CORRECAO_CARRINHO_PERFORMANCE_3.md"
git commit -m "fix(ts): align parallax scroll props + order/payment/shipping types + cart rows"
npm run typecheck
npm run lint



===== PATH: scripts\ai\CORRECAO_CARRINHO_PERFORMANCE_5.md =====
# CORREÇÃO CARRINHO E PERFORMANCE 5

## Objetivo
(1 frase)

## Problemas atuais (copie erros/prints)
- 

## Regras do projeto
- Layout congelado
- Incremental
- Arquivos completos + paths corretos

## Plano / Backlog
- [ ] 

## Flags
- 

## Métricas
- North Star:
- Métricas:



===== PATH: scripts\ai\export-context.ps1 =====
# scripts/ai/export-context.ps1
[CmdletBinding()]
param(
  [string]$OutFile = "scripts/ai/_out/context-bundle.txt",
  [switch]$IncludeTSCDiagnostics
)

$ErrorActionPreference = "Stop"

function Say([string]$m) { Write-Host ("[export] " + $m) }

# UTF-8 no console/arquivos
try {
  chcp 65001 | Out-Null
  $utf8 = [System.Text.UTF8Encoding]::new($false)
  [Console]::OutputEncoding = $utf8
  $OutputEncoding = $utf8
} catch {}

$root = (Resolve-Path ".").Path
$outPath = Join-Path $root $OutFile
$outDir = Split-Path $outPath -Parent
New-Item -ItemType Directory -Force $outDir | Out-Null

# Arquivos alvo
$files = @(
  "context/CartContext.tsx",
  "utils/cartPricing.ts",
  "utils/orderDraftBuilder.ts",
  "app/(tabs)/cart.tsx",
  "app/(tabs)/index.tsx",
  "app/checkout/review.tsx",
  "app/orders/[id]/review.tsx",
  "types/order.ts"
)

# Possíveis "ghost" paths
$maybeGhost = @(
  "app/(tabs)/checkout/review.tsx",
  "app/(tabs)/checkout/review.ts"
)

$sb = New-Object System.Text.StringBuilder
$null = $sb.AppendLine("## plugaishop context bundle")
$null = $sb.AppendLine("repo: " + $root)
$null = $sb.AppendLine("generatedAt: " + (Get-Date -Format o))
$null = $sb.AppendLine("")

function AppendFile([string]$rel) {
  $full = Join-Path $root $rel

  $null = $sb.AppendLine("### FILE: " + $rel)

  if (-not (Test-Path -LiteralPath $full)) {
    $null = $sb.AppendLine("### STATUS: MISSING")
    $null = $sb.AppendLine("")
    return
  }

  $null = $sb.AppendLine("### STATUS: OK")
  $null = $sb.AppendLine("-----BEGIN TS-----")
  $content = Get-Content -LiteralPath $full -Raw
  $null = $sb.AppendLine($content)
  $null = $sb.AppendLine("-----END TS-----")
  $null = $sb.AppendLine("")
}

Say "Bundling files..."
foreach ($f in $files) { AppendFile $f }

Say "Checking ghost paths..."
foreach ($g in $maybeGhost) {
  $full = Join-Path $root $g
  if (Test-Path -LiteralPath $full) { AppendFile $g }
}

if ($IncludeTSCDiagnostics) {
  Say "Running tsc diagnostics..."
  $null = $sb.AppendLine("### TSC: START")
  $null = $sb.AppendLine("-----BEGIN TSC-----")
  try {
    $tscOut = (npx tsc -p . --noEmit 2>&1) | Out-String
    $null = $sb.AppendLine($tscOut)
  } catch {
    $null = $sb.AppendLine(($_ | Out-String))
  }
  $null = $sb.AppendLine("-----END TSC-----")
  $null = $sb.AppendLine("### TSC: END")
  $null = $sb.AppendLine("")
}

Set-Content -LiteralPath $outPath -Value $sb.ToString() -Encoding utf8
Say ("Wrote: " + $OutFile)


===== PATH: scripts\ai\export-tsc-bundle.ps1 =====
# scripts/ai/export-tsc-bundle.ps1
[CmdletBinding()]
param(
  [string]$OutFile = "scripts/ai/_out/tsc-bundle.txt"
)

$ErrorActionPreference = "Stop"

function Say([string]$m) { Write-Host ("[bundle] " + $m) }

# UTF-8 best-effort (não quebra se falhar)
try {
  chcp 65001 | Out-Null
  $utf8 = [System.Text.UTF8Encoding]::new($false)
  [Console]::OutputEncoding = $utf8
  $OutputEncoding = $utf8
} catch {}

$root = (Resolve-Path ".").Path
$outPath = Join-Path $root $OutFile
$outDir = Split-Path $outPath -Parent
New-Item -ItemType Directory -Force $outDir | Out-Null

# Lista baseada nos ERROS DO SEU TSC (os 15 arquivos)
$files = @(
  "app/(tabs)/index.tsx",
  "app/checkout/review.tsx",
  "hooks/useHomeScreenTelemetry.ts",
  "hooks/useOrdersAutoProgress.ts",
  "src/cart/useCartRows.ts",
  "types/order.ts",
  "types/orderPayload.ts",
  "utils/orderExport.ts",
  "utils/orderNotifier.ts",
  "utils/orderPayloadBuilder.ts",
  "utils/orderStatus.ts",
  "utils/orderTimelineAuto.ts",
  "utils/paymentBridge.ts",
  "utils/paymentMock.ts",
  "utils/shippingMock.ts",
  "utils/shippingService.ts",

  # Tipos/infra frequentemente necessários p/ esses erros
  "components/ParallaxScrollView.tsx",
  "utils/telemetry.ts",
  "utils/homeAnalytics.ts",
  "constants/featureFlags.ts",
  "tsconfig.json",
  "package.json"
)

# E scripts que estão te travando
$files += @(
  "scripts/ai/fix-all.ps1",
  "scripts/ai/fix-ghost-ts-review.ps1",
  "scripts/ai/fix-mojibake.py"
)

# Possíveis ghost paths que você citou antes
$maybeGhost = @(
  "app/(tabs)/checkout/review.tsx",
  "app/(tabs)/checkout/review.ts"
)

$sb = New-Object System.Text.StringBuilder
$null = $sb.AppendLine("## plugaishop tsc bundle")
$null = $sb.AppendLine("repo: " + $root)
$null = $sb.AppendLine("generatedAt: " + (Get-Date -Format o))
$null = $sb.AppendLine("")

function AppendFile([string]$rel) {
  $full = Join-Path $root $rel

  $null = $sb.AppendLine("### FILE: " + $rel)

  if (-not (Test-Path -LiteralPath $full)) {
    $null = $sb.AppendLine("### STATUS: MISSING")
    $null = $sb.AppendLine("")
    return
  }

  $null = $sb.AppendLine("### STATUS: OK")
  $null = $sb.AppendLine("-----BEGIN-----")
  try {
    $content = Get-Content -LiteralPath $full -Raw
    $null = $sb.AppendLine($content)
  } catch {
    $null = $sb.AppendLine("<<READ ERROR>>")
    $null = $sb.AppendLine(($_ | Out-String))
  }
  $null = $sb.AppendLine("-----END-----")
  $null = $sb.AppendLine("")
}

Say "Bundling files..."
$files | Select-Object -Unique | ForEach-Object { AppendFile $_ }

Say "Checking ghost paths..."
foreach ($g in $maybeGhost) {
  $full = Join-Path $root $g
  if (Test-Path -LiteralPath $full) { AppendFile $g }
}

Say "Running tsc..."
$null = $sb.AppendLine("### TSC: START")
$null = $sb.AppendLine("-----BEGIN TSC-----")
try {
  $tscOut = (npx tsc -p . --noEmit 2>&1) | Out-String
  $null = $sb.AppendLine($tscOut)
} catch {
  $null = $sb.AppendLine(($_ | Out-String))
}
$null = $sb.AppendLine("-----END TSC-----")
$null = $sb.AppendLine("### TSC: END")
$null = $sb.AppendLine("")

Set-Content -LiteralPath $outPath -Value $sb.ToString() -Encoding utf8
Say ("Wrote: " + $OutFile)



===== PATH: scripts\ai\export-tsc-context.ps1 =====
# scripts/ai/export-tsc-context.ps1
[CmdletBinding()]
param(
  [string]$OutFile = "scripts/ai/_out/tsc-context-bundle.txt"
)

$ErrorActionPreference = "Stop"

function Write-Log([string]$m) { Write-Host ("[export-tsc] " + $m) }

# Console/arquivos em UTF-8
try {
  chcp 65001 | Out-Null
  $utf8 = [System.Text.UTF8Encoding]::new($false)
  [Console]::OutputEncoding = $utf8
  $OutputEncoding = $utf8
} catch {}

$root = (Resolve-Path ".").Path
$outPath = Join-Path $root $OutFile
$outDir  = Split-Path $outPath -Parent

New-Item -ItemType Directory -Force -Path $outDir | Out-Null

Write-Log "Running tsc..."
$tscText = ""
try {
  $tscText = (npx tsc -p . --noEmit 2>&1) | Out-String
} catch {
  $tscText = ($_ | Out-String)
}

# Extrai caminhos de arquivo do output do tsc (inclui padrão: "path(line,col): error TSxxxx")
$paths = New-Object System.Collections.Generic.HashSet[string]

$regexes = @(
  # Windows path
  '(?m)^(?<p>[A-Za-z]:[\\/][^:\r\n]+)\(\d+,\d+\):\s+error\s+TS\d+',
  # Repo-relative (ex: app/(tabs)/index.tsx(236,7): error ...)
  '(?m)^(?<p>[^:\r\n]+)\(\d+,\d+\):\s+error\s+TS\d+'
)

foreach ($rx in $regexes) {
  foreach ($m in [regex]::Matches($tscText, $rx)) {
    $p = $m.Groups["p"].Value.Trim()
    if (-not $p) { continue }

    # Normaliza para fullpath
    $full = $p
    if ($p -notmatch '^[A-Za-z]:[\\/]') {
      $full = Join-Path $root $p
    }

    # Resolve symlinks/.. se possível
    try { $full = (Resolve-Path -LiteralPath $full).Path } catch {}

    $null = $paths.Add($full)
  }
}

# Também inclui types/order.ts (quase sempre é a raiz dos erros atuais)
$mustHave = @(
  (Join-Path $root "types\order.ts"),
  (Join-Path $root "context\CartContext.tsx"),
  (Join-Path $root "app\(tabs)\cart.tsx"),
  (Join-Path $root "app\(tabs)\index.tsx"),
  (Join-Path $root "app\checkout\review.tsx")
)

foreach ($m in $mustHave) {
  if (Test-Path -LiteralPath $m) { $null = $paths.Add((Resolve-Path -LiteralPath $m).Path) }
}

$sb = New-Object System.Text.StringBuilder
$null = $sb.AppendLine("## plugaishop tsc context bundle")
$null = $sb.AppendLine("repo: " + $root)
$null = $sb.AppendLine("generatedAt: " + (Get-Date -Format o))
$null = $sb.AppendLine("")
$null = $sb.AppendLine("### TSC OUTPUT (raw)")
$null = $sb.AppendLine("-----BEGIN TSC-----")
$null = $sb.AppendLine($tscText)
$null = $sb.AppendLine("-----END TSC-----")
$null = $sb.AppendLine("")

function Append-File([string]$fullPath) {
  $rel = $fullPath
  if ($fullPath.StartsWith($root, [System.StringComparison]::OrdinalIgnoreCase)) {
    $rel = $fullPath.Substring($root.Length).TrimStart("\","/")
  }

  $null = $sb.AppendLine("### FILE: " + $rel)

  if (-not (Test-Path -LiteralPath $fullPath)) {
    $null = $sb.AppendLine("### STATUS: MISSING")
    $null = $sb.AppendLine("")
    return
  }

  $null = $sb.AppendLine("### STATUS: OK")
  $null = $sb.AppendLine("-----BEGIN TS-----")
  try {
    $content = Get-Content -LiteralPath $fullPath -Raw
    $null = $sb.AppendLine($content)
  } catch {
    $null = $sb.AppendLine("<<FAILED TO READ>>")
    $null = $sb.AppendLine($_ | Out-String)
  }
  $null = $sb.AppendLine("-----END TS-----")
  $null = $sb.AppendLine("")
}

Write-Log ("Bundling " + $paths.Count + " file(s)...")
foreach ($p in $paths) { Append-File $p }

Set-Content -LiteralPath $outPath -Value $sb.ToString() -Encoding utf8
Write-Log ("Wrote: " + $OutFile)



===== PATH: scripts\ai\fix-all.ps1 =====
@'
# scripts/ai/fix-all.ps1
[CmdletBinding()]
param(
  [switch]$SkipTsc,
  [switch]$FixMojibake
)

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

function Say([string]$m) { Write-Host ("[fix-all] " + $m) }

# UTF-8 best-effort (não quebra se falhar)
try { chcp 65001 | Out-Null } catch {}

$root = (Resolve-Path ".").Path

$pyRel  = "scripts/ai/patch_repo.py"
$pyPath = Join-Path $root $pyRel

if (-not (Test-Path -LiteralPath $pyPath)) {
  throw "Arquivo Python não encontrado: $pyRel (esperado em: $pyPath)."
}

# Escolhe executável Python (py -3 preferível no Windows)
$pythonCmd = $null
if (Get-Command py -ErrorAction SilentlyContinue) {
  $pythonCmd = @("py", "-3")
} elseif (Get-Command python -ErrorAction SilentlyContinue) {
  $pythonCmd = @("python")
} else {
  throw "Python não encontrado (nem 'py' nem 'python' no PATH)."
}

if ($FixMojibake) {
  Say ("Running: " + ($pythonCmd -join " ") + " " + $pyRel + " --fix-mojibake")
  & $pythonCmd[0] @($pythonCmd[1..($pythonCmd.Length-1)] | Where-Object { $_ }) $pyPath --fix-mojibake
  if ($LASTEXITCODE -ne 0) { throw "Python falhou (fix-mojibake) com exit code $LASTEXITCODE" }
}

Say ("Running: " + ($pythonCmd -join " ") + " " + $pyRel + " --apply")
& $pythonCmd[0] @($pythonCmd[1..($pythonCmd.Length-1)] | Where-Object { $_ }) $pyPath --apply
if ($LASTEXITCODE -ne 0) { throw "Python falhou (apply) com exit code $LASTEXITCODE" }

if (-not $SkipTsc) {
  Say "Running tsc..."
  & npx tsc -p . --noEmit
  if ($LASTEXITCODE -ne 0) { throw "TSC falhou com exit code $LASTEXITCODE" }
  Say "OK: tsc passou"
}

Say "Done."
'@ | Set-Content -LiteralPath .\scripts\ai\fix-all.ps1 -Encoding utf8 -NoNewline



===== PATH: scripts\ai\fix-ghost-ts-review.ps1 =====
# (cole aqui o conteudo do arquivo exatamente como acima)


===== PATH: scripts\ai\fix-mojibake.py =====
# scripts/ai/fix-mojibake.py
import sys
from pathlib import Path

def fix_mojibake(s: str) -> str:
    # padrão clássico: UTF-8 bytes interpretados como latin1/cp1252
    # "RevisÃ£o" -> "Revisão"
    try:
        b = s.encode("latin1", errors="strict")
        return b.decode("utf-8", errors="strict")
    except Exception:
        return s

def score(s: str) -> int:
    # quanto menor, melhor (menos sinais típicos de mojibake)
    bad = ["Ã", "Â", "â", "�"]
    return sum(s.count(x) for x in bad)

def process_file(p: Path) -> bool:
    raw = p.read_text(encoding="utf-8", errors="replace")
    fixed = fix_mojibake(raw)

    if fixed == raw:
        return False

    if score(fixed) >= score(raw):
        # não melhora -> não toca
        return False

    bak = p.with_suffix(p.suffix + ".bak")
    bak.write_text(raw, encoding="utf-8")
    p.write_text(fixed, encoding="utf-8")
    return True

def main():
    if len(sys.argv) < 2:
        print("usage: python scripts/ai/fix-mojibake.py <file1> <file2> ...")
        sys.exit(2)

    changed = 0
    for arg in sys.argv[1:]:
        p = Path(arg)
        if not p.exists():
            print(f"[skip] missing: {p}")
            continue
        if process_file(p):
            changed += 1
            print(f"[ok] fixed: {p}")
        else:
            print(f"[no] unchanged: {p}")

    print(f"done. changed={changed}")

if __name__ == "__main__":
    main()



===== PATH: scripts\ai\patch_repo.py =====
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from __future__ import annotations

import argparse
import re
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, Optional

ROOT = Path(__file__).resolve().parents[2]

@dataclass(frozen=True)
class PatchResult:
    path: Path
    changed: bool
    reason: str

def read_text(p: Path) -> Optional[str]:
    if not p.exists():
        return None
    return p.read_text(encoding="utf-8", errors="replace")

def write_text(p: Path, s: str) -> None:
    s = s.replace("\r\n", "\n")
    p.parent.mkdir(parents=True, exist_ok=True)
    with p.open("w", encoding="utf-8", errors="replace", newline="\n") as f:
        f.write(s)

def ensure_field_in_export_type(ts: str, type_name: str, field_line: str) -> tuple[str, bool]:
    m = re.search(rf"(export\s+type\s+{re.escape(type_name)}\s*=\s*\{{)([\s\S]*?)(\n\}};)", ts)
    if not m:
        return ts, False
    head, body, tail = m.group(1), m.group(2), m.group(3)

    field_name = field_line.strip().split(":")[0].strip()
    if re.search(rf"\n\s*{re.escape(field_name)}\s*:", body):
        return ts, False

    new_body = body.rstrip() + "\n  " + field_line.rstrip() + "\n"
    out = ts[:m.start()] + head + new_body + tail + ts[m.end():]
    return out, True

def ensure_exported_order_type(ts: str) -> tuple[str, bool]:
    if re.search(r"export\s+type\s+Order\s*=", ts):
        return ts, False

    insert = """
export type Order = {
  id: string;
  createdAt: string;

  items: OrderItem[];
  selectedItemIds: string[];

  coupon?: OrderCoupon | null;

  shipping?: Shipping | null;
  address?: Address | null;
  payment?: Payment | null;

  protectionById?: Record<string, number>;

  pricing?: OrderPricingSnapshot;
  pricingHash?: string;

  subtotal?: number;
  discount?: number;
  total?: number;

  note?: string;

  status?: "created" | "paid" | "shipped" | "delivered" | "canceled" | string;
  review?: { stars: number; comment?: string } | null;
};
""".lstrip("\n")

    m = re.search(r"(export\s+type\s+OrderDraft\s*=\s*\{[\s\S]*?\n\};)", ts)
    if m:
        out = ts[:m.end()] + "\n\n" + insert + "\n" + ts[m.end():]
        return out, True

    return ts.rstrip() + "\n\n" + insert + "\n", True

def patch_parallax_scrollview_props(ts: str) -> tuple[str, bool]:
    if "scrollViewProps=" in ts:
        return ts, False

    pat = re.compile(
        r"(ParallaxScrollView[\s\S]*?\n)(\s*)onScroll=\{(\([\s\S]*?\})\}\s*\n\2scrollEventThrottle=\{(\d+)\}",
        re.M,
    )
    m = pat.search(ts)
    if not m:
        return ts, False

    before = m.group(1)
    indent = m.group(2)
    onscroll_body = m.group(3)
    throttle = m.group(4)

    repl = (
        f"{before}"
        f"{indent}scrollViewProps={{{{\n"
        f"{indent}  onScroll: {onscroll_body},\n"
        f"{indent}  scrollEventThrottle: {throttle},\n"
        f"{indent}}}}}"
    )
    out = ts[:m.start()] + repl + ts[m.end():]
    return out, True

def patch_useHomeScreenTelemetry_cast(ts: str) -> tuple[str, bool]:
    changed = False
    out = ts
    for ev in ["view_home", "click_home", "fail_home"]:
        out2 = re.sub(rf'track\("{ev}"\s*,', f'track("{ev}" as any,', out)
        if out2 != out:
            changed = True
            out = out2
    return out, changed

def patch_cart_rows_cartitem_product(ts: str) -> tuple[str, bool]:
    changed = False
    out = ts
    replacements = [
        (r"\bit\.title\b", "it.product?.title"),
        (r"\bit\.price\b", "it.product?.price"),
        (r"\bit\.image\b", "it.product?.image"),
        (r"\bit\.discountPercent\b", "it.product?.discountPercent"),
        (r"\bit\.unitLabel\b", "it.product?.unitLabel"),
    ]
    for a, b in replacements:
        out2 = re.sub(a, b, out)
        if out2 != out:
            changed = True
            out = out2
    return out, changed

def ensure_shipping_option_deadline_in_file(ts: str) -> tuple[str, bool]:
    m = re.search(r"(export\s+type\s+ShippingOption\s*=\s*\{)([\s\S]*?)(\n\};)", ts)
    if not m:
        m = re.search(r"(type\s+ShippingOption\s*=\s*\{)([\s\S]*?)(\n\};)", ts)
    if not m:
        return ts, False

    head, body, tail = m.group(1), m.group(2), m.group(3)
    if re.search(r"\n\s*deadline\s*:", body):
        return ts, False

    new_body = body.rstrip() + "\n  deadline?: string;\n"
    out = ts[:m.start()] + head + new_body + tail + ts[m.end():]
    return out, True

def find_files_containing(pattern: str, roots: Iterable[Path]) -> list[Path]:
    hits: list[Path] = []
    rx = re.compile(pattern)
    for r in roots:
        if not r.exists():
            continue
        for p in r.rglob("*.ts"):
            try:
                t = p.read_text(encoding="utf-8", errors="replace")
            except Exception:
                continue
            if rx.search(t):
                hits.append(p)
        for p in r.rglob("*.tsx"):
            try:
                t = p.read_text(encoding="utf-8", errors="replace")
            except Exception:
                continue
            if rx.search(t):
                hits.append(p)

    uniq: list[Path] = []
    seen: set[str] = set()
    for p in hits:
        k = str(p.resolve()).lower()
        if k in seen:
            continue
        seen.add(k)
        uniq.append(p)
    return uniq

def apply() -> list[PatchResult]:
    results: list[PatchResult] = []

    order_ts = ROOT / "types" / "order.ts"
    t = read_text(order_ts)
    if t is not None:
        t2, c1 = ensure_field_in_export_type(t, "Payment", 'status?: "pending" | "paid" | "failed";')
        t3, c2 = ensure_field_in_export_type(t2, "Shipping", "deadline?: string;")
        t4, c3 = ensure_exported_order_type(t3)
        if c1 or c2 or c3:
            write_text(order_ts, t4)
            results.append(PatchResult(order_ts, True, "order/payment/shipping types"))

    home = ROOT / "app" / "(tabs)" / "index.tsx"
    t = read_text(home)
    if t is not None:
        t2, c = patch_parallax_scrollview_props(t)
        if c:
            write_text(home, t2)
            results.append(PatchResult(home, True, "parallax scrollViewProps"))

    telem_hook = ROOT / "hooks" / "useHomeScreenTelemetry.ts"
    t = read_text(telem_hook)
    if t is not None:
        t2, c = patch_useHomeScreenTelemetry_cast(t)
        if c:
            write_text(telem_hook, t2)
            results.append(PatchResult(telem_hook, True, "cast telemetry events"))

    cart_rows = ROOT / "src" / "cart" / "useCartRows.ts"
    t = read_text(cart_rows)
    if t is not None:
        t2, c = patch_cart_rows_cartitem_product(t)
        if c:
            write_text(cart_rows, t2)
            results.append(PatchResult(cart_rows, True, "cart item -> product fields"))

    candidates = find_files_containing(r"type\s+ShippingOption\s*=", [ROOT / "types", ROOT / "utils", ROOT])
    for p in candidates[:5]:
        tt = read_text(p)
        if tt is None:
            continue
        tt2, c = ensure_shipping_option_deadline_in_file(tt)
        if c:
            write_text(p, tt2)
            results.append(PatchResult(p, True, "ShippingOption.deadline"))
            break

    return results

def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--apply", action="store_true", help="apply patches")
    args = ap.parse_args()

    if args.apply:
        res = apply()
        changed = [r for r in res if r.changed]
        print(f"[patch_repo] changed={len(changed)}")
        for r in changed:
            print(f" - {r.path.relative_to(ROOT)} ({r.reason})")
        return 0

    ap.print_help()
    return 2

if __name__ == "__main__":
    raise SystemExit(main())


===== PATH: scripts\ai\run_ai_patch.ps1 =====
# scripts/ai/run_ai_patch.ps1
# 1 comando: bootstrap -> apply -> git resumo (PS 5.1-safe)

$ErrorActionPreference = "Stop"

$repoRoot = Resolve-Path (Join-Path $PSScriptRoot "..\..")
Set-Location $repoRoot

$bootstrap = Join-Path $repoRoot "scripts\ai\bootstrap_patch_repo.ps1"
$patchRepo = Join-Path $repoRoot "scripts\ai\patch_repo.py"

Write-Host "[run] repoRoot: $repoRoot"

Write-Host "[run] bootstrap..."
powershell -NoProfile -ExecutionPolicy Bypass -File $bootstrap

Write-Host "[run] py_compile..."
python -m py_compile $patchRepo
if ($LASTEXITCODE -ne 0) { throw "[run] py_compile failed" }

Write-Host "[run] apply..."
python $patchRepo --apply
if ($LASTEXITCODE -ne 0) { throw "[run] apply failed" }

Write-Host ""
Write-Host "[run] git diff --stat"
git diff --stat

Write-Host ""
Write-Host "[run] git status -sb"
git status -sb

Write-Host ""
Write-Host "[run] done."



===== PATH: tools\maxximus-orchestrator\data\metrics.json =====
{
  "tasks_created": 4,
  "tasks_assigned": 4,
  "tasks_done": 0,
  "tasks_failed": 0,
  "goals_set": 1,
  "last_event": {
    "type": "task_assigned",
    "at": "2026-01-30T17:03:14.915Z"
  }
}


===== PATH: tools\maxximus-orchestrator\data\reports\report-2026-01-30T17-14-54-830Z.json =====
{
  "generatedAt": "2026-01-30T17:14:54.831Z",
  "api": "http://127.0.0.1:8080",
  "summary": {
    "goals_count": 1,
    "tasks_total": 4,
    "tasks_by_status": {
      "assigned": 4
    },
    "metrics": {
      "tasks_created": 4,
      "tasks_assigned": 4,
      "tasks_done": 0,
      "tasks_failed": 0,
      "goals_set": 1,
      "last_event": {
        "type": "task_assigned",
        "at": "2026-01-30T17:03:14.915Z"
      }
    }
  },
  "snapshot": {
    "ok": true,
    "agents": [
      {
        "id": "architect_ai",
        "avatar": "👨‍💻",
        "name": "Arquimedes",
        "role": "Arquiteto de Sistemas",
        "specialty": "Arquitetura escalável",
        "port": 5001
      },
      {
        "id": "frontend_ai",
        "avatar": "🎨",
        "name": "DaVinci",
        "role": "Designer & Frontend",
        "specialty": "UI/UX e React Native",
        "port": 5002
      },
      {
        "id": "backend_ai",
        "avatar": "⚙️",
        "name": "Tesla",
        "role": "Backend & Database",
        "specialty": "APIs e Microserviços",
        "port": 5003
      },
      {
        "id": "qa_ai",
        "avatar": "🔬",
        "name": "Marie",
        "role": "Quality Assurance",
        "specialty": "Testes e Debug",
        "port": 5004
      },
      {
        "id": "devops_ai",
        "avatar": "🚀",
        "name": "Sputnik",
        "role": "DevOps & Deploy",
        "specialty": "CI/CD e Cloud",
        "port": 5005
      }
    ],
    "state": {
      "goals": [
        {
          "id": "f8ef5c88-ed99-48d0-8586-0e0b95ec3ed5",
          "text": "Etapa 2: ativar ciclo de tarefas",
          "createdAt": "2026-01-30T17:02:50.994Z"
        }
      ]
    },
    "tasks": [
      {
        "id": "6ef2ad94-021e-4bde-9d9c-cfa45585b844",
        "title": "Etapa 2: ativar ciclo de tarefas :: Executar 1 melhoria pequena (perf/robustez)",
        "tags": [
          "planning"
        ],
        "createdAt": "2026-01-30T17:02:51.035Z",
        "status": "assigned",
        "notes": [
          "assigned_to:architect_ai@2026-01-30T17:02:54.895Z"
        ],
        "assignedTo": "architect_ai"
      },
      {
        "id": "d15866bd-5b75-4580-88a7-592ba71f0425",
        "title": "Etapa 2: ativar ciclo de tarefas :: Criar plano incremental (feature flags)",
        "tags": [
          "planning"
        ],
        "createdAt": "2026-01-30T17:02:51.028Z",
        "status": "assigned",
        "notes": [
          "assigned_to:architect_ai@2026-01-30T17:02:55.530Z"
        ],
        "assignedTo": "architect_ai"
      },
      {
        "id": "b056aa00-f8a5-4bd1-8eef-504528ef7858",
        "title": "Etapa 2: ativar ciclo de tarefas :: Definir métrica principal e eventos",
        "tags": [
          "planning"
        ],
        "createdAt": "2026-01-30T17:02:51.020Z",
        "status": "assigned",
        "notes": [
          "assigned_to:architect_ai@2026-01-30T17:03:04.902Z"
        ],
        "assignedTo": "architect_ai"
      },
      {
        "id": "3dcc3364-2a43-4005-bc68-f85db9313fc5",
        "title": "Etapa 2: ativar ciclo de tarefas :: Mapear riscos e dependências",
        "tags": [
          "planning"
        ],
        "createdAt": "2026-01-30T17:02:51.008Z",
        "status": "assigned",
        "notes": [
          "assigned_to:architect_ai@2026-01-30T17:03:14.909Z"
        ],
        "assignedTo": "architect_ai"
      }
    ],
    "metrics": {
      "tasks_created": 4,
      "tasks_assigned": 4,
      "tasks_done": 0,
      "tasks_failed": 0,
      "goals_set": 1,
      "last_event": {
        "type": "task_assigned",
        "at": "2026-01-30T17:03:14.915Z"
      }
    },
    "guidelines": {
      "ok": false,
      "reason": "MAXXIMUS_GUIDELINES_ROOT not set"
    }
  }
}


===== PATH: tools\maxximus-orchestrator\data\reports\report-2026-01-30T17-35-21-685Z.json =====
{
  "generatedAt": "2026-01-30T17:35:21.686Z",
  "api": "http://127.0.0.1:8080",
  "summary": {
    "goals_count": 1,
    "tasks_total": 4,
    "tasks_by_status": {
      "assigned": 4
    },
    "metrics": {
      "tasks_created": 4,
      "tasks_assigned": 4,
      "tasks_done": 0,
      "tasks_failed": 0,
      "goals_set": 1,
      "last_event": {
        "type": "task_assigned",
        "at": "2026-01-30T17:03:14.915Z"
      }
    }
  },
  "snapshot": {
    "ok": true,
    "agents": [
      {
        "id": "architect_ai",
        "avatar": "👨‍💻",
        "name": "Arquimedes",
        "role": "Arquiteto de Sistemas",
        "specialty": "Arquitetura escalável",
        "port": 5001
      },
      {
        "id": "frontend_ai",
        "avatar": "🎨",
        "name": "DaVinci",
        "role": "Designer & Frontend",
        "specialty": "UI/UX e React Native",
        "port": 5002
      },
      {
        "id": "backend_ai",
        "avatar": "⚙️",
        "name": "Tesla",
        "role": "Backend & Database",
        "specialty": "APIs e Microserviços",
        "port": 5003
      },
      {
        "id": "qa_ai",
        "avatar": "🔬",
        "name": "Marie",
        "role": "Quality Assurance",
        "specialty": "Testes e Debug",
        "port": 5004
      },
      {
        "id": "devops_ai",
        "avatar": "🚀",
        "name": "Sputnik",
        "role": "DevOps & Deploy",
        "specialty": "CI/CD e Cloud",
        "port": 5005
      }
    ],
    "state": {
      "goals": [
        {
          "id": "f8ef5c88-ed99-48d0-8586-0e0b95ec3ed5",
          "text": "Etapa 2: ativar ciclo de tarefas",
          "createdAt": "2026-01-30T17:02:50.994Z"
        }
      ]
    },
    "tasks": [
      {
        "id": "6ef2ad94-021e-4bde-9d9c-cfa45585b844",
        "title": "Etapa 2: ativar ciclo de tarefas :: Executar 1 melhoria pequena (perf/robustez)",
        "tags": [
          "planning"
        ],
        "createdAt": "2026-01-30T17:02:51.035Z",
        "status": "assigned",
        "notes": [
          "assigned_to:architect_ai@2026-01-30T17:02:54.895Z"
        ],
        "assignedTo": "architect_ai"
      },
      {
        "id": "d15866bd-5b75-4580-88a7-592ba71f0425",
        "title": "Etapa 2: ativar ciclo de tarefas :: Criar plano incremental (feature flags)",
        "tags": [
          "planning"
        ],
        "createdAt": "2026-01-30T17:02:51.028Z",
        "status": "assigned",
        "notes": [
          "assigned_to:architect_ai@2026-01-30T17:02:55.530Z"
        ],
        "assignedTo": "architect_ai"
      },
      {
        "id": "b056aa00-f8a5-4bd1-8eef-504528ef7858",
        "title": "Etapa 2: ativar ciclo de tarefas :: Definir métrica principal e eventos",
        "tags": [
          "planning"
        ],
        "createdAt": "2026-01-30T17:02:51.020Z",
        "status": "assigned",
        "notes": [
          "assigned_to:architect_ai@2026-01-30T17:03:04.902Z"
        ],
        "assignedTo": "architect_ai"
      },
      {
        "id": "3dcc3364-2a43-4005-bc68-f85db9313fc5",
        "title": "Etapa 2: ativar ciclo de tarefas :: Mapear riscos e dependências",
        "tags": [
          "planning"
        ],
        "createdAt": "2026-01-30T17:02:51.008Z",
        "status": "assigned",
        "notes": [
          "assigned_to:architect_ai@2026-01-30T17:03:14.909Z"
        ],
        "assignedTo": "architect_ai"
      }
    ],
    "metrics": {
      "tasks_created": 4,
      "tasks_assigned": 4,
      "tasks_done": 0,
      "tasks_failed": 0,
      "goals_set": 1,
      "last_event": {
        "type": "task_assigned",
        "at": "2026-01-30T17:03:14.915Z"
      }
    },
    "guidelines": {
      "ok": false,
      "reason": "missing:PROJETO_PLUGAISHOP_2026,PROJETO_MAXXIMUS,INTERSECAO_DIRETRIZES,CONSULTA_RAPIDA"
    }
  }
}


===== PATH: tools\maxximus-orchestrator\data\state.json =====
{
  "goals": [
    {
      "id": "f8ef5c88-ed99-48d0-8586-0e0b95ec3ed5",
      "text": "Etapa 2: ativar ciclo de tarefas",
      "createdAt": "2026-01-30T17:02:50.994Z"
    }
  ]
}


===== PATH: tools\maxximus-orchestrator\data\tasks.json =====
[
  {
    "id": "6ef2ad94-021e-4bde-9d9c-cfa45585b844",
    "title": "Etapa 2: ativar ciclo de tarefas :: Executar 1 melhoria pequena (perf/robustez)",
    "tags": [
      "planning"
    ],
    "createdAt": "2026-01-30T17:02:51.035Z",
    "status": "assigned",
    "notes": [
      "assigned_to:architect_ai@2026-01-30T17:02:54.895Z"
    ],
    "assignedTo": "architect_ai"
  },
  {
    "id": "d15866bd-5b75-4580-88a7-592ba71f0425",
    "title": "Etapa 2: ativar ciclo de tarefas :: Criar plano incremental (feature flags)",
    "tags": [
      "planning"
    ],
    "createdAt": "2026-01-30T17:02:51.028Z",
    "status": "assigned",
    "notes": [
      "assigned_to:architect_ai@2026-01-30T17:02:55.530Z"
    ],
    "assignedTo": "architect_ai"
  },
  {
    "id": "b056aa00-f8a5-4bd1-8eef-504528ef7858",
    "title": "Etapa 2: ativar ciclo de tarefas :: Definir métrica principal e eventos",
    "tags": [
      "planning"
    ],
    "createdAt": "2026-01-30T17:02:51.020Z",
    "status": "assigned",
    "notes": [
      "assigned_to:architect_ai@2026-01-30T17:03:04.902Z"
    ],
    "assignedTo": "architect_ai"
  },
  {
    "id": "3dcc3364-2a43-4005-bc68-f85db9313fc5",
    "title": "Etapa 2: ativar ciclo de tarefas :: Mapear riscos e dependências",
    "tags": [
      "planning"
    ],
    "createdAt": "2026-01-30T17:02:51.008Z",
    "status": "assigned",
    "notes": [
      "assigned_to:architect_ai@2026-01-30T17:03:14.909Z"
    ],
    "assignedTo": "architect_ai"
  }
]


===== PATH: tsconfig.json =====
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "jsx": "react-jsx",
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["**/*.ts", "**/*.tsx", ".expo/types/**/*.ts", "expo-env.d.ts"],
  "exclude": ["node_modules"]
}



===== PATH: types\order.ts =====
// types/order.ts
import type { CartItem } from "../context/CartContext";
import type { OrderStatus, OrderTimelineEvent } from "./orderStatus";

export type Address = {
  id: string;
  label?: string;
  street?: string;
  number?: string;
  city?: string;
  state?: string;
  zip?: string;
};

export type Shipping = {
  method: string;
  price: number;
  deadline: string;
};

export type Payment = {
  method?: "pix" | "card" | "boleto" | "cash" | "unknown";
  status?: "paid" | "pending" | "failed";
};

export type OrderDraft = {
  /**
   * Draft pode existir sem id nas etapas iniciais do checkout.
   * O Order final SEMPRE terá id (ver type Order abaixo).
   */
  id?: string;

  items: CartItem[];
  subtotal: number;

  /** desconto total aplicado ao pedido (default: 0) */
  discount?: number;

  shipping?: Shipping;
  total: number;
  address?: Address;
  payment?: Payment;
  note?: string;
};

export type Order = Omit<OrderDraft, "id"> & {
  id: string;
  status: OrderStatus;
  timeline: OrderTimelineEvent[];
  createdAt: string; // ISO
};

/**
 * Tipos adicionais usados pelo ordersStore (stubs tipados e compatíveis com mocks).
 */
export type InAppNotification = {
  id: string;
  title: string;
  body: string;
  createdAt: string; // ISO
  read?: boolean;
  data?: Record<string, any>;
  orderId?: string;
};

export type Invoice = {
  id?: string;
  number?: string;
  url?: string;
  issuedAt?: string; // ISO
  total?: number;

  status?: string;
  series?: string;
  accessKey?: string;
  danfeUrl?: string;
};

export type LogisticsEventType =
  | "created"
  | "payment_pending"
  | "processing"
  | "paid"
  | "shipped"
  | "delivered"
  | "cancelled"
  | "canceled"
  | "custom";

export type LogisticsEvent = {
  id: string;
  type: LogisticsEventType;

  date?: string; // ISO
  at?: string; // ISO

  note?: string;
  location?: string;

  title?: string;
  description?: string;
};

export type OrderReview = {
  id?: string;
  rating: 1 | 2 | 3 | 4 | 5;
  comment?: string;
  createdAt: string; // ISO
};

export type ReturnType = "refund" | "exchange" | "repair" | "other";

export type ReturnAttachment = {
  id: string;
  uri?: string;
  url?: string;
  mimeType?: string;
  name?: string;
  createdAt?: string; // ISO
};

export type ReturnRequestStatus =
  | "requested"
  | "approved"
  | "rejected"
  | "shipped_back"
  | "completed"
  | "ABERTA"
  | "APROVADA"
  | "REJEITADA"
  | "CONCLUIDA";

export type ReturnRequest = {
  id?: string;
  orderId?: string;

  type: ReturnType;
  reason?: string;
  status?: ReturnRequestStatus;
  createdAt: string; // ISO
  protocol?: string;

  attachments?: ReturnAttachment[];
};



===== PATH: types\orderPayload.ts =====
import type { Order } from "./order";

export type CustomerPayload = {
  name?: string;
  email?: string;
  phone?: string;
  document?: string; // CPF/CNPJ (opcional)
};

export type AddressPayload = {
  zip?: string;
  street?: string;
  number?: string;
  city?: string;
  state?: string;
  complement?: string;
};

export type LineItemPayload = {
  sku?: string;
  productId?: string;
  title: string;
  quantity: number;
  unitPrice: number; // em reais
  discount?: number; // em reais
};

export type ShippingPayload = {
  method?: string;
  price: number;
  deadline?: string;
};

export type PaymentPayload = {
  method: "pix" | "card" | "boleto";
  status: "pending" | "paid" | "failed";
};

export type OrderPayload = {
  source: "plugaishop-app";
  orderId: string;
  createdAt: string;

  customer?: CustomerPayload;
  address?: AddressPayload;

  items: LineItemPayload[];

  subtotal: number;
  discount: number;
  shipping: ShippingPayload;
  total: number;

  payment?: PaymentPayload;

  rawOrder: Order; // mantém o original para debug/telemetria
};



===== PATH: types\orderStatus.ts =====
// types/orderStatus.ts
export type OrderStatus =
  | "created"
  | "payment_pending"
  | "paid"
  | "processing"
  | "shipped"
  | "delivered"
  | "canceled"
  | "cancelled"; // compatibilidade

export type OrderTimelineEvent = {
  status: OrderStatus;
  date: string; // ISO
};



===== PATH: types\shippingProviders.ts =====
export type ShippingQuote = {
  provider: "correios" | "loggi" | "dropi";
  service: string;
  price: number;
  deadline: string;
};

export type ShippingRequest = {
  zip: string;
  weightKg?: number;
  declaredValue?: number;
};



===== PATH: utils\blingPayload.ts =====
import type { OrderPayload } from "../types/orderPayload";

export type BlingOrderPayload = {
  pedido: {
    numero?: string;
    data: string; // YYYY-MM-DD
    loja?: string;
    cliente?: {
      nome?: string;
      email?: string;
      fone?: string;
      documento?: string;
    };
    enderecoEntrega?: {
      cep?: string;
      endereco?: string;
      numero?: string;
      cidade?: string;
      uf?: string;
      complemento?: string;
    };
    itens: Array<{
      codigo?: string; // SKU
      descricao: string;
      quantidade: number;
      valor: number; // unit
      desconto?: number;
    }>;
    transporte?: {
      frete: number;
      servico?: string;
      prazo?: string;
    };
    pagamento?: {
      forma?: string; // pix/card/boleto
      status?: string; // pending/paid/failed
    };
    totais: {
      subtotal: number;
      desconto: number;
      frete: number;
      total: number;
    };
    observacoes?: string;
  };
};

function toISODate(iso: string) {
  // "2025-12-21T..." -> "2025-12-21"
  return iso?.slice(0, 10) || new Date().toISOString().slice(0, 10);
}

export function toBlingPayload(p: OrderPayload): BlingOrderPayload {
  return {
    pedido: {
      numero: p.orderId,
      data: toISODate(p.createdAt),
      loja: p.source,

      cliente: {
        nome: p.customer?.name,
        email: p.customer?.email,
        fone: p.customer?.phone,
        documento: p.customer?.document,
      },

      enderecoEntrega: {
        cep: p.address?.zip,
        endereco: p.address?.street,
        numero: p.address?.number,
        cidade: p.address?.city,
        uf: p.address?.state,
        complemento: p.address?.complement,
      },

      itens: p.items.map((it) => ({
        codigo: it.sku,
        descricao: it.title,
        quantidade: it.quantity,
        valor: it.unitPrice,
        desconto: it.discount ?? 0,
      })),

      transporte: {
        frete: p.shipping.price,
        servico: p.shipping.method,
        prazo: p.shipping.deadline,
      },

      pagamento: p.payment
        ? {
            forma: p.payment.method,
            status: p.payment.status,
          }
        : undefined,

      totais: {
        subtotal: p.subtotal,
        desconto: p.discount,
        frete: p.shipping.price,
        total: p.total,
      },

      observacoes: `Pedido gerado pelo app Plugaí Shop (${p.orderId}).`,
    },
  };
}



===== PATH: utils\cep.ts =====
export function normalizeCEP(input: string): string {
  return (input ?? "").replace(/\D/g, "").slice(0, 8);
}

export function formatCEP(input: string): string {
  const cep = normalizeCEP(input);
  if (cep.length <= 5) return cep;
  return `${cep.slice(0, 5)}-${cep.slice(5)}`;
}

export function isValidCEP(input: string): boolean {
  const cep = normalizeCEP(input);
  return cep.length === 8;
}



===== PATH: utils\checkoutFlow.ts =====
import type { OrderDraft } from "../types/order";

export type CheckoutStep = "address" | "shipping" | "payment" | "review";

export function getNextCheckoutStep(draft: OrderDraft | null): CheckoutStep {
  if (!draft) return "address";

  const hasZip = !!draft.address?.zip && String(draft.address?.zip).length === 8;
  const hasShipping = !!draft.shipping && typeof draft.shipping.price === "number";
  const hasPayment = !!draft.payment?.method;

  if (!hasZip) return "address";
  if (!hasShipping) return "shipping";
  if (!hasPayment) return "payment";

  return "review";
}

export function stepToRoute(step: CheckoutStep): string {
  switch (step) {
    case "address":
      return "/checkout/address";
    case "shipping":
      return "/checkout/shipping";
    case "payment":
      return "/checkout/payment";
    case "review":
    default:
      return "/checkout/review";
  }
}



===== PATH: utils\formatCurrency.ts =====
function toNumber(value: unknown): number {
  if (typeof value === "number") return Number.isFinite(value) ? value : 0;

  if (typeof value === "string") {
    // remove "R$", espaços e converte "129,90" -> "129.90"
    const cleaned = value
      .replace(/\s/g, "")
      .replace("R$", "")
      .replace(/\./g, "") // remove separador de milhar (se houver)
      .replace(",", "."); // converte decimal BR

    const n = Number(cleaned);
    return Number.isFinite(n) ? n : 0;
  }

  return 0;
}

export function formatCurrency(value: unknown, locale = "pt-BR", currency = "BRL") {
  const safe = toNumber(value);
  return new Intl.NumberFormat(locale, {
    style: "currency",
    currency,
    maximumFractionDigits: 2,
  }).format(safe);
}

export function asNumber(value: unknown) {
  return toNumber(value);
}



===== PATH: utils\httpClient.ts =====
export type HttpMethod = "POST" | "PUT" | "PATCH";

export async function httpJson<T>(url: string, method: HttpMethod, body: unknown): Promise<T> {
  const res = await fetch(url, {
    method,
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });

  if (!res.ok) {
    const text = await res.text().catch(() => "");
    throw new Error(`HTTP ${res.status}: ${text}`);
  }

  return (await res.json()) as T;
}



===== PATH: utils\notifications.ts =====
import * as Notifications from "expo-notifications";

export type LocalNotificationPayload = {
  title: string;
  body: string;
  data?: Record<string, unknown>;
};

export function initNotifications() {
  Notifications.setNotificationHandler({
    handleNotification: async () => ({
      shouldShowAlert: true,
      shouldShowBanner: true,
      shouldShowList: true,
      shouldPlaySound: false,
      shouldSetBadge: false,
    }),
  });
}

export async function notifyLocal(payload: LocalNotificationPayload): Promise<void> {
  const { title, body, data } = payload;

  await Notifications.scheduleNotificationAsync({
    content: {
      title,
      body,
      data: data ?? {},
    },
    trigger: null,
  });
}



===== PATH: utils\nuvemshopPayload.ts =====
import type { OrderPayload } from "../types/orderPayload";

export type NuvemshopOrderPayload = {
  external_id: string;
  created_at: string;

  customer?: {
    name?: string;
    email?: string;
    phone?: string;
    document?: string;
  };

  shipping_address?: {
    zip?: string;
    address?: string;
    number?: string;
    city?: string;
    province?: string; // UF
    complement?: string;
  };

  items: Array<{
    sku?: string;
    title: string;
    quantity: number;
    price: number;
    discount?: number;
  }>;

  totals: {
    subtotal: number;
    discount: number;
    shipping: number;
    total: number;
  };

  shipping?: {
    method?: string;
    price: number;
    deadline?: string;
  };

  payment?: {
    method: "pix" | "card" | "boleto";
    status: "pending" | "paid" | "failed";
  };

  note?: string;
};

export function toNuvemshopPayload(p: OrderPayload): NuvemshopOrderPayload {
  return {
    external_id: p.orderId,
    created_at: p.createdAt,

    customer: p.customer
      ? {
          name: p.customer.name,
          email: p.customer.email,
          phone: p.customer.phone,
          document: p.customer.document,
        }
      : undefined,

    shipping_address: p.address
      ? {
          zip: p.address.zip,
          address: p.address.street,
          number: p.address.number,
          city: p.address.city,
          province: p.address.state,
          complement: p.address.complement,
        }
      : undefined,

    items: p.items.map((it) => ({
      sku: it.sku,
      title: it.title,
      quantity: it.quantity,
      price: it.unitPrice,
      discount: it.discount ?? 0,
    })),

    totals: {
      subtotal: p.subtotal,
      discount: p.discount,
      shipping: p.shipping.price,
      total: p.total,
    },

    shipping: {
      method: p.shipping.method,
      price: p.shipping.price,
      deadline: p.shipping.deadline,
    },

    payment: p.payment
      ? { method: p.payment.method, status: p.payment.status }
      : undefined,

    note: `Pedido gerado pelo app Plugaí Shop (${p.orderId}).`,
  };
}



===== PATH: utils\orderDraft.ts =====
// utils/orderDraft.ts
import type { CartItem } from "../context/CartContext";

export type OrderDraft = {
  id: string;
  createdAt: string;

  items: Array<{
    id: string;
    title: string;
    qty: number;
    price: number;
  }>;

  subtotal: number;
  shipping: number;
  total: number;

  address: any | null;
  payment: string | null;

  channel: "app" | "web" | string;
  source: string;
};

function uid() {
  // simples e estável (sem libs)
  return `OD-${Date.now()}-${Math.floor(Math.random() * 1e6)}`;
}

export function buildOrderDraft(input: {
  items: CartItem[];
  subtotal: number;
  shipping: number;
  total: number;
  address: any | null;
  payment: string | null;
  channel: string;
  source: string;
}): OrderDraft {
  return {
    id: uid(),
    createdAt: new Date().toISOString(),
    items: input.items.map((it) => ({
      id: it.id,
      title: it.title,
      qty: it.qty,
      price: it.price,
    })),
    subtotal: input.subtotal,
    shipping: input.shipping,
    total: input.total,
    address: input.address,
    payment: input.payment,
    channel: input.channel,
    source: input.source,
  };
}



===== PATH: utils\orderDraftBuilder.ts =====
// utils/orderDraftBuilder.ts
import type { Address, OrderDraft, Payment, Shipping } from "../types/order";

type BuildDraftParams = {
  id: string;
  items: OrderDraft["items"];
  subtotal: number;
  discount?: number;
  shipping?: Shipping;
  address?: Address;
  payment?: Payment;
  note?: string;
};

export function buildOrderDraft(params: BuildDraftParams): OrderDraft {
  const shippingPrice = params.shipping?.price ?? 0;
  const discount = params.discount ?? 0;

  return {
    id: params.id,
    items: params.items,
    subtotal: params.subtotal,
    discount,
    shipping: params.shipping,
    address: params.address,
    payment: params.payment,
    note: params.note,
    total: params.subtotal - discount + shippingPrice,
  };
}



===== PATH: utils\orderDraftPatch.ts =====
import type { Address, OrderDraft, Payment, Shipping } from "../types/order";

export function patchOrderDraft(
  draft: OrderDraft,
  patch: Partial<Pick<OrderDraft, "address" | "payment" | "shipping" | "total" | "discount">> & {
    address?: Address;
    payment?: Payment;
    shipping?: Shipping;
  }
): OrderDraft {
  const next: OrderDraft = { ...draft, ...patch };

  const shippingPrice = next.shipping?.price ?? 0;
  const discount = next.discount ?? 0;

  next.total = next.subtotal - discount + shippingPrice;

  return next;
}



===== PATH: utils\orderExport.ts =====
import type { Order } from "../types/order";
import { buildOrderPayload } from "./orderPayloadBuilder";
import { toBlingPayload } from "./blingPayload";
import { toNuvemshopPayload } from "./nuvemshopPayload";

export function exportOrder(order: Order) {
  const canonical = buildOrderPayload(order);

  return {
    canonical,
    bling: toBlingPayload(canonical),
    nuvemshop: toNuvemshopPayload(canonical),
  };
}



===== PATH: utils\orderNotificationStorage.ts =====
import AsyncStorage from "@react-native-async-storage/async-storage";
import type { OrderStatus } from "../types/orderStatus";

const KEY = "plugaishop.lastNotifiedStatus.v1";

type Map = Record<string, OrderStatus>;

async function readMap(): Promise<Map> {
  try {
    const raw = await AsyncStorage.getItem(KEY);
    if (!raw) return {};
    return JSON.parse(raw) as Map;
  } catch {
    return {};
  }
}

async function writeMap(map: Map): Promise<void> {
  try {
    await AsyncStorage.setItem(KEY, JSON.stringify(map));
  } catch {
    // silencioso (não quebra fluxo)
  }
}

export async function getLastNotifiedStatus(orderId: string): Promise<OrderStatus | null> {
  const map = await readMap();
  return map[orderId] ?? null;
}

export async function setLastNotifiedStatus(orderId: string, status: OrderStatus): Promise<void> {
  const map = await readMap();
  map[orderId] = status;
  await writeMap(map);
}



===== PATH: utils\orderNotifier.ts =====
// utils/orderNotifier.ts
import type { Order } from "../types/order";
import type { OrderStatus } from "../types/orderStatus";

import { notifyLocal } from "./notifications";
import { getLastNotifiedStatus, setLastNotifiedStatus } from "./orderNotificationStorage";

function statusLabel(status: OrderStatus) {
  switch (status) {
    case "created":
      return "Pedido criado";
    case "payment_pending":
      return "Aguardando pagamento";
    case "paid":
      return "Pagamento aprovado";
    case "processing":
      return "Em separação";
    case "shipped":
      return "Enviado";
    case "delivered":
      return "Entregue";
    case "canceled":
    case "cancelled":
      return "Cancelado";
    default:
      return "Atualização";
  }
}

export async function notifyIfOrderStatusChanged(order: Order) {
  const last = await getLastNotifiedStatus(order.id);
  if (last === order.status) return;

  await notifyLocal({
    title: "Atualização do pedido",
    body: `Pedido ${order.id}: ${statusLabel(order.status)}`,
    data: { orderId: order.id, status: order.status },
  });

  await setLastNotifiedStatus(order.id, order.status);
}



===== PATH: utils\orderPayloadBuilder.ts =====
import type { Order } from "../types/order";
import type { LineItemPayload, OrderPayload, PaymentPayload } from "../types/orderPayload";

function safeNumber(n: unknown, fallback = 0) {
  const v = typeof n === "number" && Number.isFinite(n) ? n : fallback;
  return v;
}

function buildPaymentPayload(order: Order): PaymentPayload | undefined {
  const method = order.payment?.method;
  const status = order.payment?.status;

  if (!status) return undefined;
  if (method !== "pix" && method !== "card" && method !== "boleto") return undefined;

  return { method, status };
}

export function buildOrderPayload(order: Order): OrderPayload {
  const items: LineItemPayload[] = order.items.map((it) => ({
    sku: (it as any).sku ?? (it as any).id ?? undefined,
    productId: (it as any).id ?? undefined,
    title: (it as any).title ?? (it as any).name ?? "Item",
    quantity: safeNumber((it as any).qty ?? (it as any).quantity ?? 1, 1),
    unitPrice: safeNumber((it as any).price ?? (it as any).unitPrice ?? 0, 0),
    discount: safeNumber((it as any).discount ?? 0, 0),
  }));

  const shippingPrice = safeNumber(order.shipping?.price ?? 0, 0);
  const discount = safeNumber(order.discount ?? 0, 0);

  return {
    source: "plugaishop-app",
    orderId: order.id,
    createdAt: order.createdAt,

    customer: undefined,
    address: {
      zip: order.address?.zip,
      street: order.address?.street,
      number: order.address?.number,
      city: order.address?.city,
      state: order.address?.state,
      complement: undefined,
    },

    items,

    subtotal: safeNumber(order.subtotal, 0),
    discount,
    shipping: {
      method: order.shipping?.method,
      price: shippingPrice,
      deadline: order.shipping?.deadline,
    },
    total: safeNumber(order.total, 0),

    payment: buildPaymentPayload(order),

    rawOrder: order,
  };
}



===== PATH: utils\orderResume.ts =====
import { loadOrderDraft } from "./orderStorage";
import { router } from "expo-router";

export async function resumeCheckoutIfNeeded() {
  const draft = await loadOrderDraft();
  if (!draft) return;

  // Se existe draft, retoma no review (padrão marketplace)
  router.replace("/checkout/review");
}



===== PATH: utils\ordersStorage.ts =====
import AsyncStorage from "@react-native-async-storage/async-storage";
import type { Order } from "../types/order";

const KEY = "@plugaishop:orders";

export async function listOrders(): Promise<Order[]> {
  const raw = await AsyncStorage.getItem(KEY);
  if (!raw) return [];
  try {
    return JSON.parse(raw) as Order[];
  } catch {
    return [];
  }
}

export async function setOrders(orders: Order[]): Promise<void> {
  await AsyncStorage.setItem(KEY, JSON.stringify(orders));
}

export async function addOrder(order: Order): Promise<void> {
  const current = await listOrders();
  const next = [order, ...current];
  await setOrders(next);
}

export async function clearOrders(): Promise<void> {
  await AsyncStorage.removeItem(KEY);
}

export async function getOrderById(id: string): Promise<Order | null> {
  const orders = await listOrders();
  return orders.find((o) => o.id === id) ?? null;
}

export async function updateOrder(order: Order): Promise<void> {
  const orders = await listOrders();
  const next = orders.map((o) => (o.id === order.id ? order : o));
  await setOrders(next);
}



===== PATH: utils\ordersStore.ts =====
export type OrderStatus = "Confirmado" | "Pago" | "Enviado" | "Entregue";

export type OrderItem = {
  productId: string;
  qty: number;
  price: number;
  title: string;
};

export type OrderReview = {
  stars: number; // 1..5
  comment: string;
  updatedAt: string; // ISO
};

export type ReturnType = "Troca" | "Reembolso";
export type ReturnStatus = "Em análise" | "Aprovado" | "Recusado" | "Concluído";

export type ReturnAttachment = {
  id: string;
  uri: string;
  createdAt: string; // ISO
};

export type ReturnRequest = {
  protocol: string;
  type: ReturnType;
  reason: string;
  status: ReturnStatus;
  createdAt: string; // ISO
  attachments?: ReturnAttachment[];
};

export type OrderStatusEvent = {
  status: OrderStatus;
  at: string; // ISO
};

export type LogisticsEventType =
  | "POSTED"
  | "IN_TRANSIT"
  | "OUT_FOR_DELIVERY"
  | "DELIVERED"
  | "EXCEPTION";

export type LogisticsEvent = {
  id: string;
  at: string; // ISO
  type: LogisticsEventType;
  title: string;
  description?: string;
  location?: string;
};

export type InvoiceStatus = "AGUARDANDO" | "EMITIDA";

export type InvoiceInfo = {
  status: InvoiceStatus;
  issuedAt?: string; // ISO
  number?: string; // ex: "12345"
  series?: string; // ex: "1"
  accessKey?: string; // chave 44 dígitos (mock)
  danfeUrl?: string; // URL PDF (mock / backend)
};

export type Order = {
  id: string;
  createdAt: string; // ISO
  status: OrderStatus;
  discount: number;
  shipping: number;
  items: OrderItem[];

  statusHistory?: OrderStatusEvent[];

  trackingCode?: string;
  logisticsEvents?: LogisticsEvent[];

  invoice?: InvoiceInfo;

  review?: OrderReview;
  returnRequest?: ReturnRequest;
};

export type InAppNotificationType =
  | "ORDER_STATUS"
  | "ORDER_REVIEW"
  | "RETURN_REQUEST"
  | "LOGISTICS"
  | "INVOICE";

export type InAppNotification = {
  id: string;
  createdAt: string; // ISO
  type: InAppNotificationType;
  orderId?: string;
  title: string;
  body: string;
  read: boolean;
};

const ORDERS_KEY = "@plugaishop_orders_v3";
const NOTIFS_KEY = "@plugaishop_notifications_v1";

let memoryOrders: Order[] = [];
let memoryNotifs: InAppNotification[] = [];

async function getAsyncStorage() {
  try {
    const mod = await import("@react-native-async-storage/async-storage");
    return mod?.default;
  } catch {
    return null;
  }
}

function nowISO() {
  return new Date().toISOString();
}

function makeId() {
  const t = Date.now().toString(36).toUpperCase();
  const r = Math.random().toString(36).slice(2, 6).toUpperCase();
  return `${t}${r}`;
}

function makeProtocol() {
  const a = Date.now().toString(36).toUpperCase();
  const b = Math.random().toString(36).slice(2, 6).toUpperCase();
  return `PLG-${a}-${b}`;
}

function makeAccessKeyMock() {
  // 44 dígitos mock
  let s = "";
  while (s.length < 44) s += Math.floor(Math.random() * 10).toString();
  return s.slice(0, 44);
}

/* ---------------- ORDERS ---------------- */

export function createOrderFromCart(params: {
  items: Array<{ productId: string; qty: number; price: number; title: string }>;
  discount?: number;
  shipping?: number;
  status?: OrderStatus;
  createdAt?: string;
  id?: string;
}): Order {
  const createdAt = params.createdAt ?? nowISO();
  const status: OrderStatus = params.status ?? "Confirmado";

  return {
    id: params.id ?? makeId(),
    createdAt,
    status,
    discount: Number(params.discount ?? 0),
    shipping: Number(params.shipping ?? 0),
    items: (params.items ?? []).map((it) => ({
      productId: String(it.productId),
      qty: Math.max(1, Number(it.qty ?? 1)),
      price: Number(it.price ?? 0),
      title: String(it.title ?? "Produto"),
    })),
    statusHistory: [{ status, at: createdAt }],
    trackingCode: "",
    logisticsEvents: [],
    invoice: { status: "AGUARDANDO" },
  };
}

export async function listOrders(): Promise<Order[]> {
  const storage = await getAsyncStorage();
  if (!storage) return memoryOrders;

  try {
    const raw = await storage.getItem(ORDERS_KEY);
    if (!raw) return [];
    const parsed = JSON.parse(raw) as Order[];
    return Array.isArray(parsed) ? parsed : [];
  } catch {
    return [];
  }
}

export async function saveOrders(orders: Order[]): Promise<void> {
  const storage = await getAsyncStorage();
  if (!storage) {
    memoryOrders = orders;
    return;
  }

  try {
    await storage.setItem(ORDERS_KEY, JSON.stringify(orders));
  } catch {
    memoryOrders = orders;
  }
}

export async function addOrder(order: Order): Promise<void> {
  const current = await listOrders();
  const next = [order, ...current];
  await saveOrders(next);

  await addNotification({
    type: "ORDER_STATUS",
    orderId: order.id,
    title: `Pedido #${order.id} confirmado`,
    body: "Seu pedido foi registrado com sucesso.",
  });
}

export async function getOrderById(id: string): Promise<Order | null> {
  const orders = await listOrders();
  return orders.find((o) => String(o.id) === String(id)) ?? null;
}

export async function updateOrderById(id: string, patch: Partial<Order>): Promise<Order | null> {
  const current = await listOrders();
  const idx = current.findIndex((o) => String(o.id) === String(id));
  if (idx < 0) return null;

  const updated: Order = {
    ...current[idx],
    ...patch,
    id: current[idx].id,
  };

  const next = [...current];
  next[idx] = updated;
  await saveOrders(next);
  return updated;
}

export function nextStatus(status: OrderStatus): OrderStatus {
  if (status === "Confirmado") return "Pago";
  if (status === "Pago") return "Enviado";
  if (status === "Enviado") return "Entregue";
  return "Entregue";
}

function ensureHistory(order: Order): OrderStatusEvent[] {
  const hist = Array.isArray(order.statusHistory) ? order.statusHistory : [];
  if (hist.length > 0) return hist;

  const baseAt = order.createdAt ?? nowISO();
  return [{ status: order.status ?? "Confirmado", at: baseAt }];
}

export async function advanceOrderStatus(id: string): Promise<Order | null> {
  const order = await getOrderById(id);
  if (!order) return null;

  const newStatus = nextStatus(order.status);
  const at = nowISO();

  const history = ensureHistory(order);
  const already = history.some((h) => h.status === newStatus);
  const nextHistory = already ? history : [...history, { status: newStatus, at }];

  const updated = await updateOrderById(id, { status: newStatus, statusHistory: nextHistory });

  if (updated) {
    await addNotification({
      type: "ORDER_STATUS",
      orderId: updated.id,
      title: `Atualização do pedido #${updated.id}`,
      body: `Status atualizado para: ${updated.status}`,
    });
  }

  return updated;
}

export async function setOrderReview(id: string, stars: number, comment: string): Promise<Order | null> {
  const clamped = Math.max(1, Math.min(5, Number(stars || 0)));
  const updated = await updateOrderById(id, {
    review: { stars: clamped, comment: String(comment ?? ""), updatedAt: nowISO() },
  });

  if (updated) {
    await addNotification({
      type: "ORDER_REVIEW",
      orderId: updated.id,
      title: `Avaliação registrada (#${updated.id})`,
      body: `Obrigado! Você avaliou com ${clamped} estrela(s).`,
    });
  }

  return updated;
}

export async function createReturnRequest(id: string, type: ReturnType, reason: string): Promise<Order | null> {
  const updated = await updateOrderById(id, {
    returnRequest: {
      protocol: makeProtocol(),
      type,
      reason: String(reason ?? ""),
      status: "Em análise",
      createdAt: nowISO(),
      attachments: [],
    },
  });

  if (updated?.returnRequest) {
    await addNotification({
      type: "RETURN_REQUEST",
      orderId: updated.id,
      title: `Solicitação de ${updated.returnRequest.type} (#${updated.id})`,
      body: `Protocolo: ${updated.returnRequest.protocol} — Status: ${updated.returnRequest.status}`,
    });
  }

  return updated;
}

export async function addReturnAttachment(orderId: string, uri: string): Promise<Order | null> {
  const order = await getOrderById(orderId);
  if (!order || !order.returnRequest) return null;

  const attachments = Array.isArray(order.returnRequest.attachments)
    ? order.returnRequest.attachments
    : [];

  const next: ReturnAttachment[] = [
    { id: makeId(), uri: String(uri), createdAt: nowISO() },
    ...attachments,
  ];

  const updated = await updateOrderById(orderId, {
    returnRequest: { ...order.returnRequest, attachments: next },
  });

  return updated;
}

/* --------- TRACKING / LOGISTICS --------- */

export async function setTrackingCode(orderId: string, trackingCode: string): Promise<Order | null> {
  const code = String(trackingCode ?? "").trim();

  const updated = await updateOrderById(orderId, {
    trackingCode: code,
  });

  if (updated) {
    await addNotification({
      type: "LOGISTICS",
      orderId: updated.id,
      title: `Rastreio atualizado (#${updated.id})`,
      body: code ? `Código: ${code}` : "Código removido.",
    });
  }

  return updated;
}

export async function addLogisticsEvent(
  orderId: string,
  params: {
    type: LogisticsEventType;
    title: string;
    description?: string;
    location?: string;
    at?: string; // ISO
  }
): Promise<Order | null> {
  const order = await getOrderById(orderId);
  if (!order) return null;

  const current = Array.isArray(order.logisticsEvents) ? order.logisticsEvents : [];
  const event: LogisticsEvent = {
    id: makeId(),
    at: params.at ?? nowISO(),
    type: params.type,
    title: String(params.title ?? "Atualização logística"),
    description: params.description ? String(params.description) : undefined,
    location: params.location ? String(params.location) : undefined,
  };

  const next = [event, ...current];

  const updated = await updateOrderById(orderId, { logisticsEvents: next });

  if (updated) {
    await addNotification({
      type: "LOGISTICS",
      orderId: updated.id,
      title: `Atualização logística (#${updated.id})`,
      body: event.location ? `${event.title} • ${event.location}` : event.title,
    });
  }

  return updated;
}

export async function clearLogisticsEvents(orderId: string): Promise<Order | null> {
  return updateOrderById(orderId, { logisticsEvents: [] });
}

/* ---------------- INVOICE (mock + contract p/ Bling) ---------------- */

/**
 * CONTRATO (quando plugar backend):
 * - Seu app chamará GET https://<seu-backend>/orders/:id/invoice
 * - Backend consulta Bling e devolve:
 *   { status, issuedAt, number, series, accessKey, danfeUrl }
 *
 * IMPORTANTE:
 * - Token da Bling NUNCA no app.
 * - O app só consome a URL e metadados.
 */

export async function setInvoiceMock(orderId: string): Promise<Order | null> {
  const order = await getOrderById(orderId);
  if (!order) return null;

  const issuedAt = nowISO();
  const invoice: InvoiceInfo = {
    status: "EMITIDA",
    issuedAt,
    number: String(Math.floor(10000 + Math.random() * 89999)),
    series: "1",
    accessKey: makeAccessKeyMock(),
    danfeUrl: `https://example.com/danfe/${encodeURIComponent(orderId)}.pdf`,
  };

  const updated = await updateOrderById(orderId, { invoice });

  if (updated) {
    await addNotification({
      type: "INVOICE",
      orderId: updated.id,
      title: `Nota Fiscal emitida (#${updated.id})`,
      body: `NF ${invoice.number} • Série ${invoice.series}`,
    });
  }

  return updated;
}

export async function clearInvoice(orderId: string): Promise<Order | null> {
  return updateOrderById(orderId, { invoice: { status: "AGUARDANDO" } });
}

/* ---------------- NOTIFICATIONS (in-app) ---------------- */

export async function listNotifications(): Promise<InAppNotification[]> {
  const storage = await getAsyncStorage();
  if (!storage) return memoryNotifs;

  try {
    const raw = await storage.getItem(NOTIFS_KEY);
    if (!raw) return [];
    const parsed = JSON.parse(raw) as InAppNotification[];
    return Array.isArray(parsed) ? parsed : [];
  } catch {
    return [];
  }
}

async function saveNotifications(notifs: InAppNotification[]): Promise<void> {
  const storage = await getAsyncStorage();
  if (!storage) {
    memoryNotifs = notifs;
    return;
  }

  try {
    await storage.setItem(NOTIFS_KEY, JSON.stringify(notifs));
  } catch {
    memoryNotifs = notifs;
  }
}

export async function addNotification(params: {
  type: InAppNotificationType;
  orderId?: string;
  title: string;
  body: string;
}): Promise<void> {
  const current = await listNotifications();
  const notif: InAppNotification = {
    id: makeId(),
    createdAt: nowISO(),
    type: params.type,
    orderId: params.orderId,
    title: params.title,
    body: params.body,
    read: false,
  };
  const next = [notif, ...current];
  await saveNotifications(next);
}

export async function markNotificationRead(id: string): Promise<void> {
  const current = await listNotifications();
  const next = current.map((n) => (String(n.id) === String(id) ? { ...n, read: true } : n));
  await saveNotifications(next);
}

export async function markAllNotificationsRead(): Promise<void> {
  const current = await listNotifications();
  const next = current.map((n) => ({ ...n, read: true }));
  await saveNotifications(next);
}

export async function getUnreadNotificationsCount(): Promise<number> {
  const items = await listNotifications();
  return (items ?? []).filter((n) => !n.read).length;
}

export async function clearNotifications(): Promise<void> {
  const storage = await getAsyncStorage();
  if (!storage) {
    memoryNotifs = [];
    return;
  }
  try {
    await storage.removeItem(NOTIFS_KEY);
  } catch {
    memoryNotifs = [];
  }
}

export async function clearOrders(): Promise<void> {
  const storage = await getAsyncStorage();
  if (!storage) {
    memoryOrders = [];
    return;
  }
  try {
    await storage.removeItem(ORDERS_KEY);
  } catch {
    memoryOrders = [];
  }
}



===== PATH: utils\orderStatus.ts =====
// utils/orderStatus.ts
import type { Order, OrderDraft } from "../types/order";
import type { OrderStatus, OrderTimelineEvent } from "../types/orderStatus";

function uid(prefix = "order") {
  return `${prefix}_${Math.random().toString(16).slice(2)}_${Date.now()}`;
}

export function createInitialOrderFromDraft(draft: OrderDraft): Order {
  const now = new Date().toISOString();

  const status: OrderStatus =
    draft.payment?.status === "paid" ? "paid" : "payment_pending";

  const timeline: OrderTimelineEvent[] = [
    { status: "created", date: now },
    { status, date: now },
  ];

  return {
    ...(draft as any),
    id: String(draft.id ?? uid("order")),
    status,
    timeline,
    createdAt: now,
  } as Order;
}

export function advanceMockStatus(current: OrderStatus): OrderStatus {
  const flow: OrderStatus[] = [
    "created",
    "payment_pending",
    "paid",
    "processing",
    "shipped",
    "delivered",
  ];

  const idx = flow.indexOf(current);
  if (idx < 0) return "created";
  if (idx >= flow.length - 1) return flow[flow.length - 1];
  return flow[idx + 1];
}



===== PATH: utils\orderStorage.ts =====
import AsyncStorage from "@react-native-async-storage/async-storage";
import type { OrderDraft } from "../types/order";

const KEY = "@plugaishop:order_draft";

export async function saveOrderDraft(order: OrderDraft) {
  await AsyncStorage.setItem(KEY, JSON.stringify(order));
}

export async function loadOrderDraft(): Promise<OrderDraft | null> {
  const data = await AsyncStorage.getItem(KEY);
  return data ? JSON.parse(data) : null;
}

export async function clearOrderDraft() {
  await AsyncStorage.removeItem(KEY);
}



===== PATH: utils\orderTimelineAuto.ts =====
// utils/orderTimelineAuto.ts
import type { Order } from "../types/order";
import type { OrderStatus, OrderTimelineEvent } from "../types/orderStatus";

const FLOW: OrderStatus[] = [
  "created",
  "payment_pending",
  "paid",
  "processing",
  "shipped",
  "delivered",
];

export function advanceMockStatus(order: Order): Order {
  if (order.status === "delivered" || order.status === "canceled") {
    return order;
  }

  const idx = FLOW.indexOf(order.status);
  if (idx < 0) return order;

  const nextStatus = FLOW[idx + 1];
  if (!nextStatus) return order;

  const now = new Date().toISOString();
  const timeline = Array.isArray((order as any).timeline)
    ? (order as any).timeline
    : [];

  return {
    ...order,
    status: nextStatus,
    timeline: [
      ...timeline,
      {
        status: nextStatus,
        date: now,
      } as OrderTimelineEvent,
    ],
  };
}



===== PATH: utils\outboxProcessor.ts =====
import NetInfo from "@react-native-community/netinfo";
import { httpJson } from "./httpClient";
import { getOutbox, updateOutbox, type OutboxJob } from "./outboxStorage";

const MAX_ATTEMPTS = 5;

// Aqui você troca depois por endpoints reais (API própria / gateway)
const ENDPOINTS = {
  bling: "https://example.com/api/bling/orders",
  nuvemshop: "https://example.com/api/nuvemshop/orders",
} as const;

function sleep(ms: number) {
  return new Promise((r) => setTimeout(r, ms));
}

export async function processOutboxOnce(): Promise<{ sent: number; remaining: number }> {
  const state = await NetInfo.fetch();
  if (!state.isConnected) return { sent: 0, remaining: (await getOutbox()).length };

  const outbox = await getOutbox();
  if (outbox.length === 0) return { sent: 0, remaining: 0 };

  const remaining: OutboxJob[] = [];
  let sent = 0;

  for (const job of outbox.reverse()) {
    // reverse para enviar mais antigo primeiro
    try {
      const url = ENDPOINTS[job.type];
      await httpJson<any>(url, "POST", job.payload);
      sent += 1;
    } catch {
      const attempts = job.attempts + 1;
      if (attempts < MAX_ATTEMPTS) {
        remaining.unshift({ ...job, attempts });
      }
    }
    await sleep(150); // cadência leve (evita burst)
  }

  await updateOutbox(remaining);
  return { sent, remaining: remaining.length };
}



===== PATH: utils\outboxStorage.ts =====
import AsyncStorage from "@react-native-async-storage/async-storage";

export type OutboxJob = {
  id: string;
  type: "bling" | "nuvemshop";
  createdAt: string;
  payload: any;
  attempts: number;
};

const KEY = "@plugaishop:outbox";

export async function getOutbox(): Promise<OutboxJob[]> {
  const raw = await AsyncStorage.getItem(KEY);
  if (!raw) return [];
  try {
    return JSON.parse(raw) as OutboxJob[];
  } catch {
    return [];
  }
}

export async function enqueueJob(job: Omit<OutboxJob, "attempts">) {
  const list = await getOutbox();
  const next: OutboxJob[] = [{ ...job, attempts: 0 }, ...list];
  await AsyncStorage.setItem(KEY, JSON.stringify(next));
}

export async function updateOutbox(next: OutboxJob[]) {
  await AsyncStorage.setItem(KEY, JSON.stringify(next));
}



===== PATH: utils\paymentBridge.ts =====
import type { Payment } from "../types/order";

export type PixMock = {
  type: "pix";
  qrText: string;
  expiresAt: string; // ISO
};

export type BoletoMock = {
  type: "boleto";
  barcode: string;
  expiresAt: string; // ISO
};

export type CardMock = {
  type: "card";
  last4: string;
  brand: "visa" | "mastercard" | "elo" | "amex" | "other";
};

export type PaymentMockPayload = PixMock | BoletoMock | CardMock;

function addHoursISO(hours: number) {
  const d = new Date();
  d.setHours(d.getHours() + hours);
  return d.toISOString();
}

export function createPayment(method: Payment["method"]): Payment {
  return { method, status: "pending" };
}

export function createPaymentPayload(method: Payment["method"], args?: { last4?: string; brand?: CardMock["brand"] }): PaymentMockPayload {
  if (method === "pix") {
    return {
      type: "pix",
      qrText: `00020126PLUGAISHOP-MOCK-${Date.now()}-END`,
      expiresAt: addHoursISO(2),
    };
  }

  if (method === "boleto") {
    return {
      type: "boleto",
      barcode: `34191.79001 01043.510047 91020.150008 8 ${String(Date.now()).slice(-10)}`,
      expiresAt: addHoursISO(48),
    };
  }

  // card
  const last4 = (args?.last4 ?? "0000").slice(-4);
  const brand = args?.brand ?? "other";
  return { type: "card", last4, brand };
}



===== PATH: utils\paymentMock.ts =====
import type { Payment } from "../types/order";

export function createPayment(method: Payment["method"]): Payment {
  return {
    method,
    status: "pending",
  };
}



===== PATH: utils\pix.ts =====
export function makePixCode(orderId: string) {
  // Mock realista (string longa), suficiente para QR + copiar/colar
  return `00020126PLUGAISHOP.${orderId}.${Date.now()}5204000053039865802BR5920PLUGAI SHOP LTDA6009GOIANIA62070503***6304ABCD`;
}

export function pixExpiresAt(hours = 2) {
  const d = new Date();
  d.setHours(d.getHours() + hours);
  return d.toISOString();
}

export function msLeft(expiresAtISO: string) {
  const end = new Date(expiresAtISO).getTime();
  return Math.max(0, end - Date.now());
}



===== PATH: utils\shippingMock.ts =====
import type { Shipping } from "../types/order";

export function calculateShipping(zip?: string): Shipping {
  if (!zip) {
    return { method: "Padrão", price: 0, deadline: "A calcular" };
  }

  return {
    method: "Correios PAC",
    price: 29.9,
    deadline: "5 a 7 dias úteis",
  };
}



===== PATH: utils\shippingProviders.ts =====
import type { ShippingQuote, ShippingRequest } from "../types/shippingProviders";

export async function quoteCorreios(req: ShippingRequest): Promise<ShippingQuote[]> {
  // mock agora; depois troca por chamada real
  return [
    { provider: "correios", service: "PAC", price: 24.9, deadline: "5 a 7 dias úteis" },
    { provider: "correios", service: "SEDEX", price: 42.9, deadline: "2 a 3 dias úteis" },
  ];
}

export async function quoteLoggi(req: ShippingRequest): Promise<ShippingQuote[]> {
  return [
    { provider: "loggi", service: "Express", price: 55.9, deadline: "24 a 48 horas" },
  ];
}

export async function quoteDropi(req: ShippingRequest): Promise<ShippingQuote[]> {
  return [
    { provider: "dropi", service: "Padrão", price: 29.9, deadline: "5 a 9 dias úteis" },
  ];
}

export async function getAllQuotes(req: ShippingRequest): Promise<ShippingQuote[]> {
  const [c, l, d] = await Promise.all([quoteCorreios(req), quoteLoggi(req), quoteDropi(req)]);
  return [...c, ...l, ...d].sort((a, b) => a.price - b.price);
}



===== PATH: utils\shippingService.ts =====
import type { Shipping } from "../types/order";
import { normalizeCEP, isValidCEP } from "./cep";

export type ShippingOption = Shipping & {
  id: "pac" | "sedex" | "express";
};

function baseByRegion(cep8: string): number {
  // Heurística simples por faixa de CEP (mock)
  // 0–3: Sudeste / 4–6: Sul / 7–9: Centro-Oeste/Norte/Nordeste (aprox.)
  const first = Number(cep8[0] ?? 9);
  if (first <= 3) return 24.9;
  if (first <= 6) return 29.9;
  return 34.9;
}

export function getShippingOptions(zipRaw: string): ShippingOption[] {
  const zip = normalizeCEP(zipRaw);

  if (!isValidCEP(zip)) {
    return [
      { id: "pac", method: "Correios PAC", price: 0, deadline: "Informe o CEP" },
      { id: "sedex", method: "Correios SEDEX", price: 0, deadline: "Informe o CEP" },
      { id: "express", method: "Entrega Expressa", price: 0, deadline: "Informe o CEP" },
    ];
  }

  const base = baseByRegion(zip);

  // Opções mock (mas com cara de real)
  return [
    { id: "pac", method: "Correios PAC", price: base, deadline: "5 a 7 dias úteis" },
    { id: "sedex", method: "Correios SEDEX", price: base + 18.0, deadline: "2 a 3 dias úteis" },
    { id: "express", method: "Entrega Expressa", price: base + 29.0, deadline: "24 a 48 horas" },
  ];
}

export function pickDefaultShipping(zipRaw: string): ShippingOption {
  const options = getShippingOptions(zipRaw);
  // Default: PAC
  return options[0];
}



